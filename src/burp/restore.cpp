/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/***************** gpre version LI-V2.5.9.27139 Firebird 2.5 **********************/
/*
 *	PROGRAM:	JRD Backup and Restore Program
 *	MODULE:		restore.epp
 *	DESCRIPTION:	Restore routine
 *
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 * Toni Martir: Verbose records restored as RESTORE_VERBOSE_INTERVAL,
 * also verbose restoring indexes as DEFERRED when verbose
 * 2003.08.17 Claudio Valderrama: Fix SF Bug #750659.
 * Adriano dos Santos Fernandes
 *
 */

#include "firebird.h"
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include "../burp/burp.h"
#include "../jrd/align.h"
#include "../jrd/common.h"
#include "../jrd/flags.h"
#include "../jrd/license.h"
#include "../jrd/obj.h"
#include "../jrd/ods.h"
#include "../common/stuff.h"
#include "../burp/burp_proto.h"
#include "../burp/canon_proto.h"
#include "../burp/misc_proto.h"
#include "../burp/mvol_proto.h"
#include "../burp/resto_proto.h"
#include "../jrd/gdsassert.h"
#include "../jrd/constants.h"
#include "../remote/protocol.h"
#ifdef DEBUG
#include "../gpre/prett_proto.h"
#endif
#include "../common/classes/ClumpletWriter.h"
#include "../common/classes/UserBlob.h"
#include "../common/classes/SafeArg.h"
#include "memory_routines.h"

using MsgFormat::SafeArg;


//  For service APIs the follow DB handle is a value stored
//  in thread data.  This is also done for other statics generated by
//  GPRE.  This is to avoid multiple threading problems with module
//  level statics.

/*DATABASE DB = STATIC FILENAME "yachts.lnk";*/
/**** GDS Preprocessor Definitions ****/
#ifndef JRD_IBASE_H
#include <ibase.h>
#endif

static const ISC_QUAD
   isc_blob_null = {0, 0};	/* initializer for blobs */
static isc_db_handle
   DB = 0;		/* database handle */

static isc_tr_handle
   gds_trans = 0;		/* default transaction handle */
static ISC_STATUS
   isc_status [20],	/* status vector */
   isc_status2 [20];	/* status vector */
static ISC_LONG
   isc_array_length, 	/* array return size */
   SQLCODE;		/* SQL status code */
static const char
   isc_tpb_29 [4] = {1,9,2,6};

static const char
   isc_tpb_28 [5] = {1,9,2,6,20};

static const char
   isc_tpb_27 [4] = {1,9,2,6};

static const char
   isc_tpb_26 [5] = {1,9,2,6,20};

static const char
   isc_tpb_25 [5] = {1,9,15,6,18};

static const char
   isc_tpb_24 [4] = {1,9,2,6};

static const char
   isc_tpb_23 [5] = {1,9,2,6,20};

static const char
   isc_tpb_22 [4] = {1,9,2,6};

static const char
   isc_tpb_21 [5] = {1,9,2,6,20};

static const char
   isc_tpb_20 [4] = {1,9,2,6};

static const char
   isc_tpb_19 [5] = {1,9,2,6,20};

static const char
   isc_tpb_18 [4] = {1,9,2,6};

static const char
   isc_tpb_17 [5] = {1,9,2,6,20};

static const char
   isc_tpb_16 [4] = {1,9,2,6};

static const char
   isc_tpb_15 [5] = {1,9,2,6,20};

static const char
   isc_tpb_14 [4] = {1,9,2,6};

static const char
   isc_tpb_13 [5] = {1,9,2,6,20};

static const char
   isc_tpb_12 [4] = {1,9,2,6};

static const char
   isc_tpb_11 [5] = {1,9,2,6,20};

static const char
   isc_tpb_10 [4] = {1,9,2,6};

static const char
   isc_tpb_9 [5] = {1,9,2,6,20};

static const char
   isc_tpb_8 [4] = {1,9,2,6};

static const char
   isc_tpb_7 [5] = {1,9,2,6,20};

static const char
   isc_tpb_6 [4] = {1,9,2,6};

static const char
   isc_tpb_5 [6] = {1,9,15,6,18,20};

static const char
   isc_tpb_4 [4] = {1,9,2,6};

static const char
   isc_tpb_3 [4] = {1,9,2,6};

static const char
   isc_tpb_2 [6] = {1,9,15,6,18,20};

static const char
   isc_tpb_1 [4] = {1,9,2,6};

static const char
   isc_tpb_0 [6] = {1,9,15,6,18,20};

static const short
   isc_30l = 238;
static const char
   isc_30 [] = {
   4,2,4,2,1,0,7,0,4,1,1,0,7,0,4,0,3,0,41,3,0,32,0,7,0,7,0,2,7,
   'C',1,'J',13,'R','D','B','$','R','E','L','A','T','I','O','N',
   'S',0,'G',58,59,61,23,0,12,'R','D','B','$','V','I','E','W','_',
   'B','L','R',57,48,23,0,15,'R','D','B','$','S','Y','S','T','E',
   'M','_','F','L','A','G',21,8,0,1,0,0,0,61,23,0,15,'R','D','B',
   '$','S','Y','S','T','E','M','_','F','L','A','G',-1,2,14,0,2,
   1,23,0,17,'R','D','B','$','R','E','L','A','T','I','O','N','_',
   'N','A','M','E',25,0,0,0,1,21,8,0,1,0,0,0,25,0,1,0,1,23,0,16,
   'R','D','B','$','D','B','K','E','Y','_','L','E','N','G','T',
   'H',25,0,2,0,-1,17,0,9,13,12,2,18,0,12,1,11,10,0,1,2,1,25,1,
   0,0,23,1,16,'R','D','B','$','D','B','K','E','Y','_','L','E',
   'N','G','T','H',-1,-1,-1,14,0,1,21,8,0,0,0,0,0,25,0,1,0,-1,-1,
   'L'
   };	/* end of blr string for request isc_30 */

static const short
   isc_39l = 382;
static const char
   isc_39 [] = {
   4,2,4,3,1,0,7,0,4,2,8,0,9,0,9,0,9,0,9,0,7,0,7,0,7,0,7,0,4,1,
   9,0,9,0,9,0,9,0,9,0,7,0,7,0,7,0,7,0,7,0,4,0,1,0,41,3,0,32,0,
   12,0,2,7,'C',1,'J',10,'R','D','B','$','F','I','E','L','D','S',
   0,'G',47,23,0,14,'R','D','B','$','F','I','E','L','D','_','N',
   'A','M','E',25,0,0,0,-1,2,14,1,2,1,23,0,19,'R','D','B','$','C',
   'O','M','P','U','T','E','D','_','S','O','U','R','C','E',41,1,
   0,0,5,0,1,23,0,16,'R','D','B','$','C','O','M','P','U','T','E',
   'D','_','B','L','R',41,1,1,0,6,0,1,23,0,21,'R','D','B','$','V',
   'A','L','I','D','A','T','I','O','N','_','S','O','U','R','C',
   'E',41,1,2,0,7,0,1,23,0,18,'R','D','B','$','V','A','L','I','D',
   'A','T','I','O','N','_','B','L','R',41,1,3,0,8,0,1,21,8,0,1,
   0,0,0,25,1,4,0,-1,17,0,9,13,12,3,18,0,12,2,11,10,0,1,2,1,41,
   2,3,0,7,0,23,1,19,'R','D','B','$','C','O','M','P','U','T','E',
   'D','_','S','O','U','R','C','E',1,41,2,2,0,6,0,23,1,16,'R','D',
   'B','$','C','O','M','P','U','T','E','D','_','B','L','R',1,41,
   2,1,0,5,0,23,1,21,'R','D','B','$','V','A','L','I','D','A','T',
   'I','O','N','_','S','O','U','R','C','E',1,41,2,0,0,4,0,23,1,
   18,'R','D','B','$','V','A','L','I','D','A','T','I','O','N','_',
   'B','L','R',-1,-1,-1,14,1,1,21,8,0,0,0,0,0,25,1,4,0,-1,-1,'L'
   
   };	/* end of blr string for request isc_39 */

static const short
   isc_63l = 90;
static const char
   isc_63 [] = {
   4,2,4,0,3,0,41,3,0,32,0,7,0,7,0,12,0,15,'J',14,'R','D','B','$',
   'G','E','N','E','R','A','T','O','R','S',0,2,1,41,0,2,0,1,0,23,
   0,15,'R','D','B','$','S','Y','S','T','E','M','_','F','L','A',
   'G',1,25,0,0,0,23,0,18,'R','D','B','$','G','E','N','E','R','A',
   'T','O','R','_','N','A','M','E',-1,-1,'L'
   };	/* end of blr string for request isc_63 */

static const short
   isc_68l = 119;
static const char
   isc_68 [] = {
   4,2,4,0,5,0,9,0,41,3,0,32,0,7,0,7,0,7,0,12,0,15,'J',14,'R','D',
   'B','$','G','E','N','E','R','A','T','O','R','S',0,2,1,41,0,3,
   0,2,0,23,0,15,'R','D','B','$','S','Y','S','T','E','M','_','F',
   'L','A','G',1,41,0,0,0,4,0,23,0,15,'R','D','B','$','D','E','S',
   'C','R','I','P','T','I','O','N',1,25,0,1,0,23,0,18,'R','D','B',
   '$','G','E','N','E','R','A','T','O','R','_','N','A','M','E',
   -1,-1,'L'
   };	/* end of blr string for request isc_68 */

static const short
   isc_75l = 214;
static const char
   isc_75 [] = {
   4,2,4,1,4,0,41,3,0,32,0,9,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,
   2,7,'C',2,'J',18,'R','D','B','$','V','I','E','W','_','R','E',
   'L','A','T','I','O','N','S',0,'J',13,'R','D','B','$','R','E',
   'L','A','T','I','O','N','S',1,'G',58,47,23,0,13,'R','D','B',
   '$','V','I','E','W','_','N','A','M','E',25,0,0,0,47,23,1,17,
   'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A',
   'M','E',23,0,17,'R','D','B','$','R','E','L','A','T','I','O',
   'N','_','N','A','M','E',-1,14,1,2,1,23,0,17,'R','D','B','$',
   'R','E','L','A','T','I','O','N','_','N','A','M','E',25,1,0,0,
   1,23,1,12,'R','D','B','$','V','I','E','W','_','B','L','R',41,
   1,1,0,3,0,1,21,8,0,1,0,0,0,25,1,2,0,-1,14,1,1,21,8,0,0,0,0,0,
   25,1,2,0,-1,-1,'L'
   };	/* end of blr string for request isc_75 */

static const short
   isc_83l = 170;
static const char
   isc_83 [] = {
   4,2,4,3,1,0,7,0,4,2,1,0,9,0,4,1,2,0,9,0,7,0,4,0,1,0,41,3,0,32,
   0,12,0,2,7,'C',1,'J',20,'R','D','B','$','S','E','C','U','R',
   'I','T','Y','_','C','L','A','S','S','E','S',0,'G',47,23,0,18,
   'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L',
   'A','S','S',25,0,0,0,-1,2,14,1,2,1,23,0,7,'R','D','B','$','A',
   'C','L',25,1,0,0,1,21,8,0,1,0,0,0,25,1,1,0,-1,17,0,9,13,12,3,
   18,0,12,2,11,10,0,1,2,1,25,2,0,0,23,1,7,'R','D','B','$','A',
   'C','L',-1,-1,-1,14,1,1,21,8,0,0,0,0,0,25,1,1,0,-1,-1,'L'
   };	/* end of blr string for request isc_83 */

static const short
   isc_93l = 170;
static const char
   isc_93 [] = {
   4,2,4,2,1,0,7,0,4,1,2,0,27,7,0,4,0,3,0,27,7,0,7,0,2,7,'C',1,
   'J',11,'R','D','B','$','I','N','D','I','C','E','S',0,'G',47,
   23,0,15,'R','D','B','$','S','Y','S','T','E','M','_','F','L',
   'A','G',21,8,0,1,0,0,0,-1,2,14,0,2,1,23,0,14,'R','D','B','$',
   'S','T','A','T','I','S','T','I','C','S',41,0,0,0,2,0,1,21,8,
   0,1,0,0,0,25,0,1,0,-1,17,0,9,13,12,2,18,0,12,1,11,10,0,1,2,1,
   41,1,0,0,1,0,23,1,14,'R','D','B','$','S','T','A','T','I','S',
   'T','I','C','S',-1,-1,-1,14,0,1,21,8,0,0,0,0,0,25,0,1,0,-1,-1,
   'L'
   };	/* end of blr string for request isc_93 */

static const short
   isc_103l = 138;
static const char
   isc_103 [] = {
   4,2,4,2,1,0,7,0,4,1,1,0,7,0,4,0,1,0,7,0,2,7,'C',1,'J',9,'R',
   'D','B','$','F','I','L','E','S',0,'G',58,59,61,23,0,17,'R','D',
   'B','$','S','H','A','D','O','W','_','N','U','M','B','E','R',
   48,23,0,17,'R','D','B','$','S','H','A','D','O','W','_','N','U',
   'M','B','E','R',21,8,0,0,0,0,0,-1,2,14,0,2,1,21,8,0,1,0,0,0,
   25,0,0,0,-1,17,0,9,13,12,2,18,0,12,1,11,5,0,-1,-1,14,0,1,21,
   8,0,0,0,0,0,25,0,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_103 */

static const short
   isc_110l = 213;
static const char
   isc_110 [] = {
   4,2,4,2,1,0,7,0,4,1,2,0,41,3,0,32,0,7,0,4,0,4,0,41,3,0,32,0,
   41,3,0,32,0,7,0,7,0,2,7,'C',1,'J',18,'R','D','B','$','C','H',
   'A','R','A','C','T','E','R','_','S','E','T','S',0,-1,2,14,0,
   2,1,23,0,24,'R','D','B','$','D','E','F','A','U','L','T','_',
   'C','O','L','L','A','T','E','_','N','A','M','E',41,0,0,0,3,0,
   1,23,0,22,'R','D','B','$','C','H','A','R','A','C','T','E','R',
   '_','S','E','T','_','N','A','M','E',25,0,1,0,1,21,8,0,1,0,0,
   0,25,0,2,0,-1,17,0,9,13,12,2,18,0,12,1,11,10,0,1,2,1,41,1,0,
   0,1,0,23,1,24,'R','D','B','$','D','E','F','A','U','L','T','_',
   'C','O','L','L','A','T','E','_','N','A','M','E',-1,-1,-1,14,
   0,1,21,8,0,0,0,0,0,25,0,2,0,-1,-1,'L'
   };	/* end of blr string for request isc_110 */

static const short
   isc_121l = 139;
static const char
   isc_121 [] = {
   4,2,4,1,2,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'J',18,
   'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S',
   'E','T','S',0,'G',47,23,0,22,'R','D','B','$','C','H','A','R',
   'A','C','T','E','R','_','S','E','T','_','N','A','M','E',25,0,
   0,0,-1,14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,1,23,0,20,'R','D','B',
   '$','C','H','A','R','A','C','T','E','R','_','S','E','T','_',
   'I','D',25,1,1,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   
   };	/* end of blr string for request isc_121 */

static const short
   isc_127l = 139;
static const char
   isc_127 [] = {
   4,2,4,1,2,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'J',18,
   'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S',
   'E','T','S',0,'G',47,23,0,22,'R','D','B','$','C','H','A','R',
   'A','C','T','E','R','_','S','E','T','_','N','A','M','E',25,0,
   0,0,-1,14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,1,23,0,20,'R','D','B',
   '$','C','H','A','R','A','C','T','E','R','_','S','E','T','_',
   'I','D',25,1,1,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   
   };	/* end of blr string for request isc_127 */

static const short
   isc_133l = 160;
static const char
   isc_133 [] = {
   4,2,4,2,1,0,7,0,4,1,1,0,41,3,0,32,0,4,0,2,0,41,3,0,32,0,7,0,
   2,7,'C',1,'J',12,'R','D','B','$','D','A','T','A','B','A','S',
   'E',0,-1,2,14,0,2,1,23,0,22,'R','D','B','$','C','H','A','R',
   'A','C','T','E','R','_','S','E','T','_','N','A','M','E',25,0,
   0,0,1,21,8,0,1,0,0,0,25,0,1,0,-1,17,0,9,13,12,2,18,0,12,1,11,
   10,0,1,2,1,25,1,0,0,23,1,22,'R','D','B','$','C','H','A','R',
   'A','C','T','E','R','_','S','E','T','_','N','A','M','E',-1,-1,
   -1,14,0,1,21,8,0,0,0,0,0,25,0,1,0,-1,-1,'L'
   };	/* end of blr string for request isc_133 */

static const short
   isc_141l = 140;
static const char
   isc_141 [] = {
   4,2,4,2,1,0,7,0,4,1,1,0,9,0,4,0,2,0,9,0,7,0,2,7,'C',1,'J',12,
   'R','D','B','$','D','A','T','A','B','A','S','E',0,-1,2,14,0,
   2,1,23,0,15,'R','D','B','$','D','E','S','C','R','I','P','T',
   'I','O','N',25,0,0,0,1,21,8,0,1,0,0,0,25,0,1,0,-1,17,0,9,13,
   12,2,18,0,12,1,11,10,0,1,2,1,25,1,0,0,23,1,15,'R','D','B','$',
   'D','E','S','C','R','I','P','T','I','O','N',-1,-1,-1,14,0,1,
   21,8,0,0,0,0,0,25,0,1,0,-1,-1,'L'
   };	/* end of blr string for request isc_141 */

static const short
   isc_149l = 145;
static const char
   isc_149 [] = {
   4,2,4,0,4,0,41,3,0,0,1,41,3,0,32,0,41,3,0,32,0,7,0,12,0,15,'J',
   18,'R','D','B','$','V','I','E','W','_','R','E','L','A','T','I',
   'O','N','S',0,2,1,25,0,3,0,23,0,16,'R','D','B','$','V','I','E',
   'W','_','C','O','N','T','E','X','T',1,25,0,0,0,23,0,16,'R','D',
   'B','$','C','O','N','T','E','X','T','_','N','A','M','E',1,25,
   0,1,0,23,0,17,'R','D','B','$','R','E','L','A','T','I','O','N',
   '_','N','A','M','E',1,25,0,2,0,23,0,13,'R','D','B','$','V','I',
   'E','W','_','N','A','M','E',-1,-1,'L'
   };	/* end of blr string for request isc_149 */

static const short
   isc_155l = 253;
static const char
   isc_155 [] = {
   4,2,4,0,12,0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,
   7,0,7,0,7,0,7,0,7,0,7,0,7,0,41,0,0,7,0,12,0,15,'J',19,'R','D',
   'B','$','U','S','E','R','_','P','R','I','V','I','L','E','G',
   'E','S',0,2,1,41,0,5,0,4,0,23,0,13,'R','D','B','$','U','S','E',
   'R','_','T','Y','P','E',1,25,0,0,0,23,0,17,'R','D','B','$','R',
   'E','L','A','T','I','O','N','_','N','A','M','E',1,41,0,7,0,6,
   0,23,0,16,'R','D','B','$','G','R','A','N','T','_','O','P','T',
   'I','O','N',1,25,0,11,0,23,0,13,'R','D','B','$','P','R','I',
   'V','I','L','E','G','E',1,25,0,1,0,23,0,11,'R','D','B','$','G',
   'R','A','N','T','O','R',1,25,0,2,0,23,0,8,'R','D','B','$','U',
   'S','E','R',1,41,0,9,0,8,0,23,0,15,'R','D','B','$','O','B','J',
   'E','C','T','_','T','Y','P','E',1,41,0,3,0,10,0,23,0,14,'R',
   'D','B','$','F','I','E','L','D','_','N','A','M','E',-1,-1,'L'
   
   };	/* end of blr string for request isc_155 */

static const short
   isc_169l = 154;
static const char
   isc_169 [] = {
   4,2,4,0,7,0,41,3,0,32,0,41,3,0,32,0,9,0,7,0,7,0,7,0,7,0,12,0,
   15,'J',9,'R','D','B','$','T','Y','P','E','S',0,2,1,25,0,0,0,
   23,0,14,'R','D','B','$','F','I','E','L','D','_','N','A','M',
   'E',1,25,0,3,0,23,0,8,'R','D','B','$','T','Y','P','E',1,25,0,
   1,0,23,0,13,'R','D','B','$','T','Y','P','E','_','N','A','M',
   'E',1,41,0,5,0,4,0,23,0,15,'R','D','B','$','S','Y','S','T','E',
   'M','_','F','L','A','G',1,41,0,2,0,6,0,23,0,15,'R','D','B','$',
   'D','E','S','C','R','I','P','T','I','O','N',-1,-1,'L'
   };	/* end of blr string for request isc_169 */

static const short
   isc_178l = 117;
static const char
   isc_178 [] = {
   4,2,4,0,3,0,41,0,0,0,4,41,3,0,32,0,7,0,12,0,15,'J',20,'R','D',
   'B','$','T','R','I','G','G','E','R','_','M','E','S','S','A',
   'G','E','S',0,2,1,25,0,0,0,23,0,11,'R','D','B','$','M','E','S',
   'S','A','G','E',1,25,0,2,0,23,0,18,'R','D','B','$','M','E','S',
   'S','A','G','E','_','N','U','M','B','E','R',1,25,0,1,0,23,0,
   16,'R','D','B','$','T','R','I','G','G','E','R','_','N','A','M',
   'E',-1,-1,'L'
   };	/* end of blr string for request isc_178 */

static const short
   isc_183l = 132;
static const char
   isc_183 [] = {
   4,2,4,1,1,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'J',12,'R',
   'D','B','$','T','R','I','G','G','E','R','S',0,'D',21,8,0,1,0,
   0,0,'G',58,47,23,0,15,'R','D','B','$','S','Y','S','T','E','M',
   '_','F','L','A','G',21,8,0,1,0,0,0,47,23,0,16,'R','D','B','$',
   'T','R','I','G','G','E','R','_','N','A','M','E',25,0,0,0,-1,
   14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,-1,14,1,1,21,8,0,0,0,0,0,25,
   1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_183 */

static const short
   isc_188l = 319;
static const char
   isc_188 [] = {
   4,2,4,0,16,0,41,3,0,32,0,9,0,9,0,9,0,41,3,0,32,0,7,0,7,0,7,0,
   7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,12,0,15,'J',12,'R','D','B','$',
   'T','R','I','G','G','E','R','S',0,2,1,25,0,5,0,23,0,20,'R','D',
   'B','$','T','R','I','G','G','E','R','_','I','N','A','C','T',
   'I','V','E',1,25,0,6,0,23,0,20,'R','D','B','$','T','R','I','G',
   'G','E','R','_','S','E','Q','U','E','N','C','E',1,25,0,0,0,23,
   0,16,'R','D','B','$','T','R','I','G','G','E','R','_','N','A',
   'M','E',1,25,0,7,0,23,0,16,'R','D','B','$','T','R','I','G','G',
   'E','R','_','T','Y','P','E',1,41,0,9,0,8,0,23,0,9,'R','D','B',
   '$','F','L','A','G','S',1,41,0,11,0,10,0,23,0,15,'R','D','B',
   '$','S','Y','S','T','E','M','_','F','L','A','G',1,41,0,1,0,12,
   0,23,0,18,'R','D','B','$','T','R','I','G','G','E','R','_','S',
   'O','U','R','C','E',1,41,0,2,0,13,0,23,0,15,'R','D','B','$',
   'T','R','I','G','G','E','R','_','B','L','R',1,41,0,3,0,14,0,
   23,0,15,'R','D','B','$','D','E','S','C','R','I','P','T','I',
   'O','N',1,41,0,4,0,15,0,23,0,17,'R','D','B','$','R','E','L',
   'A','T','I','O','N','_','N','A','M','E',-1,-1,'L'
   };	/* end of blr string for request isc_188 */

static const short
   isc_206l = 374;
static const char
   isc_206 [] = {
   4,2,4,0,20,0,41,3,0,32,0,9,0,9,0,9,0,9,0,41,3,0,32,0,7,0,7,0,
   7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,12,0,15,'J',
   12,'R','D','B','$','T','R','I','G','G','E','R','S',0,2,1,25,
   0,6,0,23,0,20,'R','D','B','$','T','R','I','G','G','E','R','_',
   'I','N','A','C','T','I','V','E',1,25,0,7,0,23,0,20,'R','D','B',
   '$','T','R','I','G','G','E','R','_','S','E','Q','U','E','N',
   'C','E',1,25,0,0,0,23,0,16,'R','D','B','$','T','R','I','G','G',
   'E','R','_','N','A','M','E',1,25,0,8,0,23,0,16,'R','D','B','$',
   'T','R','I','G','G','E','R','_','T','Y','P','E',1,41,0,1,0,9,
   0,23,0,14,'R','D','B','$','D','E','B','U','G','_','I','N','F',
   'O',1,41,0,11,0,10,0,23,0,13,'R','D','B','$','V','A','L','I',
   'D','_','B','L','R',1,41,0,13,0,12,0,23,0,9,'R','D','B','$',
   'F','L','A','G','S',1,41,0,15,0,14,0,23,0,15,'R','D','B','$',
   'S','Y','S','T','E','M','_','F','L','A','G',1,41,0,2,0,16,0,
   23,0,18,'R','D','B','$','T','R','I','G','G','E','R','_','S',
   'O','U','R','C','E',1,41,0,3,0,17,0,23,0,15,'R','D','B','$',
   'T','R','I','G','G','E','R','_','B','L','R',1,41,0,4,0,18,0,
   23,0,15,'R','D','B','$','D','E','S','C','R','I','P','T','I',
   'O','N',1,41,0,5,0,19,0,23,0,17,'R','D','B','$','R','E','L',
   'A','T','I','O','N','_','N','A','M','E',-1,-1,'L'
   };	/* end of blr string for request isc_206 */

static const short
   isc_228l = 262;
static const char
   isc_228 [] = {
   4,2,4,0,12,0,41,3,0,32,0,41,3,0,32,0,9,0,9,0,9,0,7,0,7,0,7,0,
   7,0,7,0,7,0,7,0,12,0,15,'J',12,'R','D','B','$','T','R','I','G',
   'G','E','R','S',0,2,1,25,0,5,0,23,0,20,'R','D','B','$','T','R',
   'I','G','G','E','R','_','S','E','Q','U','E','N','C','E',1,25,
   0,0,0,23,0,17,'R','D','B','$','R','E','L','A','T','I','O','N',
   '_','N','A','M','E',1,25,0,6,0,23,0,16,'R','D','B','$','T','R',
   'I','G','G','E','R','_','T','Y','P','E',1,25,0,1,0,23,0,16,'R',
   'D','B','$','T','R','I','G','G','E','R','_','N','A','M','E',
   1,41,0,8,0,7,0,23,0,15,'R','D','B','$','S','Y','S','T','E','M',
   '_','F','L','A','G',1,41,0,2,0,9,0,23,0,18,'R','D','B','$','T',
   'R','I','G','G','E','R','_','S','O','U','R','C','E',1,41,0,3,
   0,10,0,23,0,15,'R','D','B','$','T','R','I','G','G','E','R','_',
   'B','L','R',1,41,0,4,0,11,0,23,0,15,'R','D','B','$','D','E',
   'S','C','R','I','P','T','I','O','N',-1,-1,'L'
   };	/* end of blr string for request isc_228 */

static const short
   isc_242l = 113;
static const char
   isc_242 [] = {
   4,2,4,0,4,0,9,0,41,3,0,32,0,9,0,7,0,12,0,15,'J',20,'R','D','B',
   '$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S',
   'E','S',0,2,1,25,0,0,0,23,0,7,'R','D','B','$','A','C','L',1,
   25,0,1,0,23,0,18,'R','D','B','$','S','E','C','U','R','I','T',
   'Y','_','C','L','A','S','S',1,41,0,2,0,3,0,23,0,15,'R','D','B',
   '$','D','E','S','C','R','I','P','T','I','O','N',-1,-1,'L'
   };	/* end of blr string for request isc_242 */

static const short
   isc_248l = 86;
static const char
   isc_248 [] = {
   4,2,4,0,4,0,41,3,0,32,0,41,3,0,32,0,7,0,7,0,12,0,15,'J',9,'R',
   'D','B','$','R','O','L','E','S',0,2,1,41,0,0,0,2,0,23,0,14,'R',
   'D','B','$','O','W','N','E','R','_','N','A','M','E',1,41,0,1,
   0,3,0,23,0,13,'R','D','B','$','R','O','L','E','_','N','A','M',
   'E',-1,-1,'L'
   };	/* end of blr string for request isc_248 */

static const short
   isc_254l = 144;
static const char
   isc_254 [] = {
   4,2,4,0,8,0,9,0,41,3,0,32,0,41,3,0,32,0,7,0,7,0,7,0,7,0,7,0,
   12,0,15,'J',9,'R','D','B','$','R','O','L','E','S',0,2,1,41,0,
   4,0,3,0,23,0,15,'R','D','B','$','S','Y','S','T','E','M','_',
   'F','L','A','G',1,41,0,0,0,5,0,23,0,15,'R','D','B','$','D','E',
   'S','C','R','I','P','T','I','O','N',1,41,0,1,0,6,0,23,0,14,'R',
   'D','B','$','O','W','N','E','R','_','N','A','M','E',1,41,0,2,
   0,7,0,23,0,13,'R','D','B','$','R','O','L','E','_','N','A','M',
   'E',-1,-1,'L'
   };	/* end of blr string for request isc_254 */

static const short
   isc_264l = 247;
static const char
   isc_264 [] = {
   4,2,4,0,12,0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,41,0,0,4,0,
   41,0,0,4,0,41,0,0,12,0,7,0,7,0,7,0,7,0,7,0,7,0,12,0,15,'J',24,
   'R','D','B','$','R','E','L','A','T','I','O','N','_','C','O',
   'N','S','T','R','A','I','N','T','S',0,2,1,41,0,0,0,6,0,23,0,
   14,'R','D','B','$','I','N','D','E','X','_','N','A','M','E',1,
   41,0,3,0,7,0,23,0,22,'R','D','B','$','I','N','I','T','I','A',
   'L','L','Y','_','D','E','F','E','R','R','E','D',1,41,0,4,0,8,
   0,23,0,14,'R','D','B','$','D','E','F','E','R','R','A','B','L',
   'E',1,41,0,1,0,9,0,23,0,17,'R','D','B','$','R','E','L','A','T',
   'I','O','N','_','N','A','M','E',1,41,0,5,0,10,0,23,0,19,'R',
   'D','B','$','C','O','N','S','T','R','A','I','N','T','_','T',
   'Y','P','E',1,41,0,2,0,11,0,23,0,19,'R','D','B','$','C','O',
   'N','S','T','R','A','I','N','T','_','N','A','M','E',-1,-1,'L'
   
   };	/* end of blr string for request isc_264 */

static const short
   isc_278l = 327;
static const char
   isc_278 [] = {
   4,2,4,0,19,0,41,3,0,32,0,41,0,0,0,1,9,0,9,0,9,0,9,0,9,0,41,3,
   0,32,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,12,0,15,'J',
   13,'R','D','B','$','R','E','L','A','T','I','O','N','S',0,2,1,
   25,0,0,0,23,0,17,'R','D','B','$','R','E','L','A','T','I','O',
   'N','_','N','A','M','E',1,41,0,1,0,8,0,23,0,17,'R','D','B','$',
   'E','X','T','E','R','N','A','L','_','F','I','L','E',1,41,0,2,
   0,9,0,23,0,24,'R','D','B','$','E','X','T','E','R','N','A','L',
   '_','D','E','S','C','R','I','P','T','I','O','N',1,41,0,3,0,10,
   0,23,0,11,'R','D','B','$','R','U','N','T','I','M','E',1,41,0,
   4,0,11,0,23,0,15,'R','D','B','$','D','E','S','C','R','I','P',
   'T','I','O','N',1,41,0,5,0,12,0,23,0,15,'R','D','B','$','V',
   'I','E','W','_','S','O','U','R','C','E',1,41,0,6,0,13,0,23,0,
   12,'R','D','B','$','V','I','E','W','_','B','L','R',1,41,0,7,
   0,14,0,23,0,18,'R','D','B','$','S','E','C','U','R','I','T','Y',
   '_','C','L','A','S','S',1,41,0,16,0,15,0,23,0,9,'R','D','B',
   '$','F','L','A','G','S',1,41,0,18,0,17,0,23,0,15,'R','D','B',
   '$','S','Y','S','T','E','M','_','F','L','A','G',-1,-1,'L'
   };	/* end of blr string for request isc_278 */

static const short
   isc_299l = 358;
static const char
   isc_299 [] = {
   4,2,4,0,21,0,41,3,0,32,0,41,0,0,0,1,9,0,9,0,9,0,9,0,9,0,41,3,
   0,32,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,12,
   0,15,'J',13,'R','D','B','$','R','E','L','A','T','I','O','N',
   'S',0,2,1,25,0,0,0,23,0,17,'R','D','B','$','R','E','L','A','T',
   'I','O','N','_','N','A','M','E',1,41,0,9,0,8,0,23,0,17,'R','D',
   'B','$','R','E','L','A','T','I','O','N','_','T','Y','P','E',
   1,41,0,1,0,10,0,23,0,17,'R','D','B','$','E','X','T','E','R',
   'N','A','L','_','F','I','L','E',1,41,0,2,0,11,0,23,0,24,'R',
   'D','B','$','E','X','T','E','R','N','A','L','_','D','E','S',
   'C','R','I','P','T','I','O','N',1,41,0,3,0,12,0,23,0,11,'R',
   'D','B','$','R','U','N','T','I','M','E',1,41,0,4,0,13,0,23,0,
   15,'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N',
   1,41,0,5,0,14,0,23,0,15,'R','D','B','$','V','I','E','W','_',
   'S','O','U','R','C','E',1,41,0,6,0,15,0,23,0,12,'R','D','B',
   '$','V','I','E','W','_','B','L','R',1,41,0,7,0,16,0,23,0,18,
   'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L',
   'A','S','S',1,41,0,18,0,17,0,23,0,9,'R','D','B','$','F','L',
   'A','G','S',1,41,0,20,0,19,0,23,0,15,'R','D','B','$','S','Y',
   'S','T','E','M','_','F','L','A','G',-1,-1,'L'
   };	/* end of blr string for request isc_299 */

static const short
   isc_322l = 202;
static const char
   isc_322 [] = {
   4,2,4,0,10,0,41,0,0,8,0,41,3,0,32,0,41,3,0,32,0,41,0,0,12,0,
   41,0,0,12,0,7,0,7,0,7,0,7,0,7,0,12,0,15,'J',19,'R','D','B','$',
   'R','E','F','_','C','O','N','S','T','R','A','I','N','T','S',
   0,2,1,41,0,3,0,5,0,23,0,15,'R','D','B','$','D','E','L','E','T',
   'E','_','R','U','L','E',1,41,0,4,0,6,0,23,0,15,'R','D','B','$',
   'U','P','D','A','T','E','_','R','U','L','E',1,41,0,0,0,7,0,23,
   0,16,'R','D','B','$','M','A','T','C','H','_','O','P','T','I',
   'O','N',1,41,0,1,0,8,0,23,0,17,'R','D','B','$','C','O','N','S',
   'T','_','N','A','M','E','_','U','Q',1,41,0,2,0,9,0,23,0,19,'R',
   'D','B','$','C','O','N','S','T','R','A','I','N','T','_','N',
   'A','M','E',-1,-1,'L'
   };	/* end of blr string for request isc_322 */

static const short
   isc_334l = 247;
static const char
   isc_334 [] = {
   4,2,4,0,9,0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,9,0,7,0,7,0,
   7,0,7,0,7,0,12,0,15,'J',24,'R','D','B','$','P','R','O','C','E',
   'D','U','R','E','_','P','A','R','A','M','E','T','E','R','S',
   0,2,1,25,0,0,0,23,0,16,'R','D','B','$','F','I','E','L','D','_',
   'S','O','U','R','C','E',1,25,0,4,0,23,0,20,'R','D','B','$','P',
   'A','R','A','M','E','T','E','R','_','N','U','M','B','E','R',
   1,25,0,5,0,23,0,18,'R','D','B','$','P','A','R','A','M','E','T',
   'E','R','_','T','Y','P','E',1,25,0,1,0,23,0,18,'R','D','B','$',
   'P','A','R','A','M','E','T','E','R','_','N','A','M','E',1,41,
   0,7,0,6,0,23,0,15,'R','D','B','$','S','Y','S','T','E','M','_',
   'F','L','A','G',1,25,0,2,0,23,0,18,'R','D','B','$','P','R','O',
   'C','E','D','U','R','E','_','N','A','M','E',1,41,0,3,0,8,0,23,
   0,15,'R','D','B','$','D','E','S','C','R','I','P','T','I','O',
   'N',-1,-1,'L'
   };	/* end of blr string for request isc_334 */

static const short
   isc_345l = 469;
static const char
   isc_345 [] = {
   4,2,4,0,23,0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,
   9,0,9,0,9,0,41,3,0,32,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,
   7,0,7,0,7,0,7,0,7,0,7,0,12,0,15,'J',24,'R','D','B','$','P','R',
   'O','C','E','D','U','R','E','_','P','A','R','A','M','E','T',
   'E','R','S',0,2,1,25,0,0,0,23,0,16,'R','D','B','$','F','I','E',
   'L','D','_','S','O','U','R','C','E',1,25,0,8,0,23,0,20,'R','D',
   'B','$','P','A','R','A','M','E','T','E','R','_','N','U','M',
   'B','E','R',1,25,0,9,0,23,0,18,'R','D','B','$','P','A','R','A',
   'M','E','T','E','R','_','T','Y','P','E',1,25,0,1,0,23,0,18,'R',
   'D','B','$','P','A','R','A','M','E','T','E','R','_','N','A',
   'M','E',1,41,0,2,0,10,0,23,0,17,'R','D','B','$','R','E','L',
   'A','T','I','O','N','_','N','A','M','E',1,41,0,3,0,11,0,23,0,
   14,'R','D','B','$','F','I','E','L','D','_','N','A','M','E',1,
   41,0,13,0,12,0,23,0,23,'R','D','B','$','P','A','R','A','M','E',
   'T','E','R','_','M','E','C','H','A','N','I','S','M',1,41,0,15,
   0,14,0,23,0,13,'R','D','B','$','N','U','L','L','_','F','L','A',
   'G',1,41,0,17,0,16,0,23,0,15,'R','D','B','$','S','Y','S','T',
   'E','M','_','F','L','A','G',1,41,0,19,0,18,0,23,0,16,'R','D',
   'B','$','C','O','L','L','A','T','I','O','N','_','I','D',1,41,
   0,4,0,20,0,23,0,18,'R','D','B','$','D','E','F','A','U','L','T',
   '_','S','O','U','R','C','E',1,41,0,5,0,21,0,23,0,17,'R','D',
   'B','$','D','E','F','A','U','L','T','_','V','A','L','U','E',
   1,41,0,6,0,22,0,23,0,15,'R','D','B','$','D','E','S','C','R',
   'I','P','T','I','O','N',1,25,0,7,0,23,0,18,'R','D','B','$','P',
   'R','O','C','E','D','U','R','E','_','N','A','M','E',-1,-1,'L'
   
   };	/* end of blr string for request isc_345 */

static const short
   isc_370l = 311;
static const char
   isc_370 [] = {
   4,2,4,0,15,0,9,0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,9,0,9,0,
   7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,12,0,15,'J',14,'R','D','B',
   '$','P','R','O','C','E','D','U','R','E','S',0,2,1,25,0,6,0,23,
   0,21,'R','D','B','$','P','R','O','C','E','D','U','R','E','_',
   'O','U','T','P','U','T','S',1,41,0,8,0,7,0,23,0,20,'R','D','B',
   '$','P','R','O','C','E','D','U','R','E','_','I','N','P','U',
   'T','S',1,25,0,0,0,23,0,17,'R','D','B','$','P','R','O','C','E',
   'D','U','R','E','_','B','L','R',1,25,0,1,0,23,0,18,'R','D','B',
   '$','P','R','O','C','E','D','U','R','E','_','N','A','M','E',
   1,41,0,10,0,9,0,23,0,15,'R','D','B','$','S','Y','S','T','E',
   'M','_','F','L','A','G',1,41,0,2,0,11,0,23,0,14,'R','D','B',
   '$','O','W','N','E','R','_','N','A','M','E',1,41,0,3,0,12,0,
   23,0,18,'R','D','B','$','S','E','C','U','R','I','T','Y','_',
   'C','L','A','S','S',1,41,0,4,0,13,0,23,0,15,'R','D','B','$',
   'D','E','S','C','R','I','P','T','I','O','N',1,41,0,5,0,14,0,
   23,0,20,'R','D','B','$','P','R','O','C','E','D','U','R','E',
   '_','S','O','U','R','C','E',-1,-1,'L'
   };	/* end of blr string for request isc_370 */

static const short
   isc_387l = 398;
static const char
   isc_387 [] = {
   4,2,4,0,21,0,9,0,41,3,0,32,0,9,0,41,3,0,32,0,41,3,0,32,0,9,0,
   9,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,
   12,0,15,'J',14,'R','D','B','$','P','R','O','C','E','D','U','R',
   'E','S',0,2,1,25,0,7,0,23,0,21,'R','D','B','$','P','R','O','C',
   'E','D','U','R','E','_','O','U','T','P','U','T','S',1,41,0,9,
   0,8,0,23,0,20,'R','D','B','$','P','R','O','C','E','D','U','R',
   'E','_','I','N','P','U','T','S',1,25,0,0,0,23,0,17,'R','D','B',
   '$','P','R','O','C','E','D','U','R','E','_','B','L','R',1,25,
   0,1,0,23,0,18,'R','D','B','$','P','R','O','C','E','D','U','R',
   'E','_','N','A','M','E',1,41,0,2,0,10,0,23,0,14,'R','D','B',
   '$','D','E','B','U','G','_','I','N','F','O',1,41,0,12,0,11,0,
   23,0,13,'R','D','B','$','V','A','L','I','D','_','B','L','R',
   1,41,0,14,0,13,0,23,0,15,'R','D','B','$','S','Y','S','T','E',
   'M','_','F','L','A','G',1,41,0,16,0,15,0,23,0,18,'R','D','B',
   '$','P','R','O','C','E','D','U','R','E','_','T','Y','P','E',
   1,41,0,3,0,17,0,23,0,14,'R','D','B','$','O','W','N','E','R',
   '_','N','A','M','E',1,41,0,4,0,18,0,23,0,18,'R','D','B','$',
   'S','E','C','U','R','I','T','Y','_','C','L','A','S','S',1,41,
   0,5,0,19,0,23,0,15,'R','D','B','$','D','E','S','C','R','I','P',
   'T','I','O','N',1,41,0,6,0,20,0,23,0,20,'R','D','B','$','P',
   'R','O','C','E','D','U','R','E','_','S','O','U','R','C','E',
   -1,-1,'L'
   };	/* end of blr string for request isc_387 */

static const short
   isc_410l = 129;
static const char
   isc_410 [] = {
   4,2,4,3,1,0,7,0,4,2,1,0,7,0,4,1,1,0,7,0,4,0,1,0,41,3,0,32,0,
   12,0,2,7,'C',1,'J',18,'R','D','B','$','I','N','D','E','X','_',
   'S','E','G','M','E','N','T','S',0,'G',47,23,0,14,'R','D','B',
   '$','I','N','D','E','X','_','N','A','M','E',25,0,0,0,-1,2,14,
   1,2,1,21,8,0,1,0,0,0,25,1,0,0,-1,17,0,9,13,12,3,18,0,12,2,11,
   5,0,-1,-1,14,1,1,21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_410 */

static const short
   isc_419l = 190;
static const char
   isc_419 [] = {
   4,2,4,1,1,0,7,0,4,0,2,0,41,3,0,32,0,41,3,0,32,0,12,0,2,7,'C',
   2,'J',19,'R','D','B','$','R','E','L','A','T','I','O','N','_',
   'F','I','E','L','D','S',0,'J',18,'R','D','B','$','I','N','D',
   'E','X','_','S','E','G','M','E','N','T','S',1,'G',58,47,23,1,
   14,'R','D','B','$','F','I','E','L','D','_','N','A','M','E',23,
   0,14,'R','D','B','$','F','I','E','L','D','_','N','A','M','E',
   58,47,23,1,14,'R','D','B','$','I','N','D','E','X','_','N','A',
   'M','E',25,0,1,0,47,23,0,17,'R','D','B','$','R','E','L','A',
   'T','I','O','N','_','N','A','M','E',25,0,0,0,-1,14,1,2,1,21,
   8,0,1,0,0,0,25,1,0,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,0,0,-1,-1,
   'L'
   };	/* end of blr string for request isc_419 */

static const short
   isc_425l = 116;
static const char
   isc_425 [] = {
   4,2,4,0,3,0,41,3,0,32,0,41,3,0,32,0,7,0,12,0,15,'J',18,'R','D',
   'B','$','I','N','D','E','X','_','S','E','G','M','E','N','T',
   'S',0,2,1,25,0,2,0,23,0,18,'R','D','B','$','F','I','E','L','D',
   '_','P','O','S','I','T','I','O','N',1,25,0,0,0,23,0,14,'R','D',
   'B','$','I','N','D','E','X','_','N','A','M','E',1,25,0,1,0,23,
   0,14,'R','D','B','$','F','I','E','L','D','_','N','A','M','E',
   -1,-1,'L'
   };	/* end of blr string for request isc_425 */

static const short
   isc_430l = 349;
static const char
   isc_430 [] = {
   4,2,4,0,17,0,41,3,0,32,0,9,0,9,0,41,3,0,32,0,9,0,41,3,0,32,0,
   7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,12,0,15,'J',11,'R',
   'D','B','$','I','N','D','I','C','E','S',0,2,1,25,0,6,0,23,0,
   17,'R','D','B','$','S','E','G','M','E','N','T','_','C','O','U',
   'N','T',1,25,0,0,0,23,0,14,'R','D','B','$','I','N','D','E','X',
   '_','N','A','M','E',1,41,0,8,0,7,0,23,0,15,'R','D','B','$','S',
   'Y','S','T','E','M','_','F','L','A','G',1,41,0,1,0,9,0,23,0,
   18,'R','D','B','$','E','X','P','R','E','S','S','I','O','N','_',
   'B','L','R',1,41,0,2,0,10,0,23,0,21,'R','D','B','$','E','X',
   'P','R','E','S','S','I','O','N','_','S','O','U','R','C','E',
   1,41,0,3,0,11,0,23,0,15,'R','D','B','$','F','O','R','E','I',
   'G','N','_','K','E','Y',1,41,0,4,0,12,0,23,0,15,'R','D','B',
   '$','D','E','S','C','R','I','P','T','I','O','N',1,41,0,14,0,
   13,0,23,0,14,'R','D','B','$','I','N','D','E','X','_','T','Y',
   'P','E',1,25,0,15,0,23,0,18,'R','D','B','$','I','N','D','E',
   'X','_','I','N','A','C','T','I','V','E',1,25,0,16,0,23,0,15,
   'R','D','B','$','U','N','I','Q','U','E','_','F','L','A','G',
   1,25,0,5,0,23,0,17,'R','D','B','$','R','E','L','A','T','I','O',
   'N','_','N','A','M','E',-1,-1,'L'
   };	/* end of blr string for request isc_430 */

static const short
   isc_449l = 852;
static const char
   isc_449 [] = {
   4,2,4,0,51,0,41,3,0,32,0,9,0,9,0,9,0,9,0,9,0,9,0,9,0,9,0,41,
   0,0,-128,0,41,3,0,32,0,9,0,9,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,
   0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,
   0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,
   0,12,0,15,'J',10,'R','D','B','$','F','I','E','L','D','S',0,2,
   1,25,0,14,0,23,0,16,'R','D','B','$','F','I','E','L','D','_',
   'L','E','N','G','T','H',1,25,0,15,0,23,0,14,'R','D','B','$',
   'F','I','E','L','D','_','T','Y','P','E',1,25,0,0,0,23,0,14,'R',
   'D','B','$','F','I','E','L','D','_','N','A','M','E',1,41,0,1,
   0,19,0,23,0,18,'R','D','B','$','D','E','F','A','U','L','T','_',
   'S','O','U','R','C','E',1,41,0,2,0,20,0,23,0,18,'R','D','B',
   '$','M','I','S','S','I','N','G','_','S','O','U','R','C','E',
   1,41,0,22,0,21,0,23,0,20,'R','D','B','$','C','H','A','R','A',
   'C','T','E','R','_','L','E','N','G','T','H',1,41,0,25,0,24,0,
   23,0,18,'R','D','B','$','E','X','T','E','R','N','A','L','_',
   'S','C','A','L','E',1,41,0,27,0,26,0,23,0,17,'R','D','B','$',
   'E','X','T','E','R','N','A','L','_','T','Y','P','E',1,41,0,29,
   0,28,0,23,0,19,'R','D','B','$','E','X','T','E','R','N','A','L',
   '_','L','E','N','G','T','H',1,41,0,31,0,30,0,23,0,14,'R','D',
   'B','$','D','I','M','E','N','S','I','O','N','S',1,41,0,3,0,32,
   0,23,0,15,'R','D','B','$','D','E','S','C','R','I','P','T','I',
   'O','N',1,41,0,34,0,33,0,23,0,13,'R','D','B','$','N','U','L',
   'L','_','F','L','A','G',1,41,0,'$',0,35,0,23,0,15,'R','D','B',
   '$','S','Y','S','T','E','M','_','F','L','A','G',1,41,0,4,0,37,
   0,23,0,21,'R','D','B','$','V','A','L','I','D','A','T','I','O',
   'N','_','S','O','U','R','C','E',1,41,0,5,0,38,0,23,0,18,'R',
   'D','B','$','V','A','L','I','D','A','T','I','O','N','_','B',
   'L','R',1,41,0,6,0,39,0,23,0,17,'R','D','B','$','D','E','F',
   'A','U','L','T','_','V','A','L','U','E',1,41,0,7,0,40,0,23,0,
   17,'R','D','B','$','M','I','S','S','I','N','G','_','V','A','L',
   'U','E',1,41,0,8,0,41,0,23,0,16,'R','D','B','$','Q','U','E',
   'R','Y','_','H','E','A','D','E','R',1,41,0,9,0,42,0,23,0,15,
   'R','D','B','$','E','D','I','T','_','S','T','R','I','N','G',
   1,41,0,10,0,43,0,23,0,14,'R','D','B','$','Q','U','E','R','Y',
   '_','N','A','M','E',1,41,0,11,0,44,0,23,0,19,'R','D','B','$',
   'C','O','M','P','U','T','E','D','_','S','O','U','R','C','E',
   1,41,0,12,0,45,0,23,0,16,'R','D','B','$','C','O','M','P','U',
   'T','E','D','_','B','L','R',1,41,0,46,0,18,0,23,0,18,'R','D',
   'B','$','F','I','E','L','D','_','S','U','B','_','T','Y','P',
   'E',1,41,0,47,0,16,0,23,0,16,'R','D','B','$','C','O','L','L',
   'A','T','I','O','N','_','I','D',1,41,0,48,0,17,0,23,0,20,'R',
   'D','B','$','C','H','A','R','A','C','T','E','R','_','S','E',
   'T','_','I','D',1,41,0,49,0,23,0,23,0,18,'R','D','B','$','S',
   'E','G','M','E','N','T','_','L','E','N','G','T','H',1,41,0,50,
   0,13,0,23,0,15,'R','D','B','$','F','I','E','L','D','_','S','C',
   'A','L','E',-1,-1,'L'
   };	/* end of blr string for request isc_449 */

static const short
   isc_502l = 885;
static const char
   isc_502 [] = {
   4,2,4,0,53,0,41,3,0,32,0,9,0,9,0,9,0,9,0,9,0,9,0,9,0,9,0,41,
   0,0,-128,0,41,3,0,32,0,9,0,9,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,
   0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,
   0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,
   0,7,0,7,0,12,0,15,'J',10,'R','D','B','$','F','I','E','L','D',
   'S',0,2,1,25,0,14,0,23,0,16,'R','D','B','$','F','I','E','L',
   'D','_','L','E','N','G','T','H',1,25,0,15,0,23,0,14,'R','D',
   'B','$','F','I','E','L','D','_','T','Y','P','E',1,25,0,0,0,23,
   0,14,'R','D','B','$','F','I','E','L','D','_','N','A','M','E',
   1,41,0,17,0,16,0,23,0,19,'R','D','B','$','F','I','E','L','D',
   '_','P','R','E','C','I','S','I','O','N',1,41,0,1,0,21,0,23,0,
   18,'R','D','B','$','D','E','F','A','U','L','T','_','S','O','U',
   'R','C','E',1,41,0,2,0,22,0,23,0,18,'R','D','B','$','M','I',
   'S','S','I','N','G','_','S','O','U','R','C','E',1,41,0,24,0,
   23,0,23,0,20,'R','D','B','$','C','H','A','R','A','C','T','E',
   'R','_','L','E','N','G','T','H',1,41,0,27,0,26,0,23,0,18,'R',
   'D','B','$','E','X','T','E','R','N','A','L','_','S','C','A',
   'L','E',1,41,0,29,0,28,0,23,0,17,'R','D','B','$','E','X','T',
   'E','R','N','A','L','_','T','Y','P','E',1,41,0,31,0,30,0,23,
   0,19,'R','D','B','$','E','X','T','E','R','N','A','L','_','L',
   'E','N','G','T','H',1,41,0,33,0,32,0,23,0,14,'R','D','B','$',
   'D','I','M','E','N','S','I','O','N','S',1,41,0,3,0,34,0,23,0,
   15,'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N',
   1,41,0,'$',0,35,0,23,0,13,'R','D','B','$','N','U','L','L','_',
   'F','L','A','G',1,41,0,38,0,37,0,23,0,15,'R','D','B','$','S',
   'Y','S','T','E','M','_','F','L','A','G',1,41,0,4,0,39,0,23,0,
   21,'R','D','B','$','V','A','L','I','D','A','T','I','O','N','_',
   'S','O','U','R','C','E',1,41,0,5,0,40,0,23,0,18,'R','D','B',
   '$','V','A','L','I','D','A','T','I','O','N','_','B','L','R',
   1,41,0,6,0,41,0,23,0,17,'R','D','B','$','D','E','F','A','U',
   'L','T','_','V','A','L','U','E',1,41,0,7,0,42,0,23,0,17,'R',
   'D','B','$','M','I','S','S','I','N','G','_','V','A','L','U',
   'E',1,41,0,8,0,43,0,23,0,16,'R','D','B','$','Q','U','E','R',
   'Y','_','H','E','A','D','E','R',1,41,0,9,0,44,0,23,0,15,'R',
   'D','B','$','E','D','I','T','_','S','T','R','I','N','G',1,41,
   0,10,0,45,0,23,0,14,'R','D','B','$','Q','U','E','R','Y','_',
   'N','A','M','E',1,41,0,11,0,46,0,23,0,19,'R','D','B','$','C',
   'O','M','P','U','T','E','D','_','S','O','U','R','C','E',1,41,
   0,12,0,47,0,23,0,16,'R','D','B','$','C','O','M','P','U','T',
   'E','D','_','B','L','R',1,41,0,48,0,20,0,23,0,18,'R','D','B',
   '$','F','I','E','L','D','_','S','U','B','_','T','Y','P','E',
   1,41,0,49,0,18,0,23,0,16,'R','D','B','$','C','O','L','L','A',
   'T','I','O','N','_','I','D',1,41,0,50,0,19,0,23,0,20,'R','D',
   'B','$','C','H','A','R','A','C','T','E','R','_','S','E','T',
   '_','I','D',1,41,0,51,0,25,0,23,0,18,'R','D','B','$','S','E',
   'G','M','E','N','T','_','L','E','N','G','T','H',1,41,0,52,0,
   13,0,23,0,15,'R','D','B','$','F','I','E','L','D','_','S','C',
   'A','L','E',-1,-1,'L'
   };	/* end of blr string for request isc_502 */

static const short
   isc_557l = 263;
static const char
   isc_557 [] = {
   4,2,4,0,10,0,41,3,0,32,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,
   12,0,15,'J',22,'R','D','B','$','F','U','N','C','T','I','O','N',
   '_','A','R','G','U','M','E','N','T','S',0,2,1,25,0,1,0,23,0,
   16,'R','D','B','$','F','I','E','L','D','_','L','E','N','G','T',
   'H',1,25,0,2,0,23,0,15,'R','D','B','$','F','I','E','L','D','_',
   'S','C','A','L','E',1,25,0,3,0,23,0,14,'R','D','B','$','F','I',
   'E','L','D','_','T','Y','P','E',1,25,0,4,0,23,0,13,'R','D','B',
   '$','M','E','C','H','A','N','I','S','M',1,25,0,5,0,23,0,21,'R',
   'D','B','$','A','R','G','U','M','E','N','T','_','P','O','S',
   'I','T','I','O','N',1,25,0,0,0,23,0,17,'R','D','B','$','F','U',
   'N','C','T','I','O','N','_','N','A','M','E',1,41,0,7,0,6,0,23,
   0,20,'R','D','B','$','C','H','A','R','A','C','T','E','R','_',
   'S','E','T','_','I','D',1,41,0,9,0,8,0,23,0,18,'R','D','B','$',
   'F','I','E','L','D','_','S','U','B','_','T','Y','P','E',-1,-1,
   'L'
   };	/* end of blr string for request isc_557 */

static const short
   isc_569l = 296;
static const char
   isc_569 [] = {
   4,2,4,0,12,0,41,3,0,32,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,
   7,0,7,0,12,0,15,'J',22,'R','D','B','$','F','U','N','C','T','I',
   'O','N','_','A','R','G','U','M','E','N','T','S',0,2,1,25,0,1,
   0,23,0,16,'R','D','B','$','F','I','E','L','D','_','L','E','N',
   'G','T','H',1,25,0,2,0,23,0,15,'R','D','B','$','F','I','E','L',
   'D','_','S','C','A','L','E',1,25,0,3,0,23,0,14,'R','D','B','$',
   'F','I','E','L','D','_','T','Y','P','E',1,25,0,4,0,23,0,13,'R',
   'D','B','$','M','E','C','H','A','N','I','S','M',1,25,0,5,0,23,
   0,21,'R','D','B','$','A','R','G','U','M','E','N','T','_','P',
   'O','S','I','T','I','O','N',1,25,0,0,0,23,0,17,'R','D','B','$',
   'F','U','N','C','T','I','O','N','_','N','A','M','E',1,41,0,7,
   0,6,0,23,0,19,'R','D','B','$','F','I','E','L','D','_','P','R',
   'E','C','I','S','I','O','N',1,41,0,9,0,8,0,23,0,20,'R','D','B',
   '$','C','H','A','R','A','C','T','E','R','_','S','E','T','_',
   'I','D',1,41,0,11,0,10,0,23,0,18,'R','D','B','$','F','I','E',
   'L','D','_','S','U','B','_','T','Y','P','E',-1,-1,'L'
   };	/* end of blr string for request isc_569 */

static const short
   isc_583l = 255;
static const char
   isc_583 [] = {
   4,2,4,0,10,0,41,3,0,32,0,41,0,0,32,0,41,0,0,0,1,41,3,0,32,0,
   9,0,7,0,7,0,7,0,7,0,7,0,12,0,15,'J',13,'R','D','B','$','F','U',
   'N','C','T','I','O','N','S',0,2,1,25,0,5,0,23,0,17,'R','D','B',
   '$','F','U','N','C','T','I','O','N','_','T','Y','P','E',1,25,
   0,0,0,23,0,14,'R','D','B','$','Q','U','E','R','Y','_','N','A',
   'M','E',1,25,0,6,0,23,0,19,'R','D','B','$','R','E','T','U','R',
   'N','_','A','R','G','U','M','E','N','T',1,25,0,1,0,23,0,14,'R',
   'D','B','$','E','N','T','R','Y','P','O','I','N','T',1,25,0,2,
   0,23,0,15,'R','D','B','$','M','O','D','U','L','E','_','N','A',
   'M','E',1,25,0,3,0,23,0,17,'R','D','B','$','F','U','N','C','T',
   'I','O','N','_','N','A','M','E',1,41,0,4,0,7,0,23,0,15,'R','D',
   'B','$','D','E','S','C','R','I','P','T','I','O','N',1,41,0,9,
   0,8,0,23,0,15,'R','D','B','$','S','Y','S','T','E','M','_','F',
   'L','A','G',-1,-1,'L'
   };	/* end of blr string for request isc_583 */

static const short
   isc_595l = 227;
static const char
   isc_595 [] = {
   4,2,4,0,9,0,41,0,0,32,0,41,0,0,0,1,41,3,0,32,0,9,0,7,0,7,0,7,
   0,7,0,7,0,12,0,15,'J',11,'R','D','B','$','F','I','L','T','E',
   'R','S',0,2,1,25,0,4,0,23,0,19,'R','D','B','$','O','U','T','P',
   'U','T','_','S','U','B','_','T','Y','P','E',1,25,0,5,0,23,0,
   18,'R','D','B','$','I','N','P','U','T','_','S','U','B','_','T',
   'Y','P','E',1,25,0,0,0,23,0,14,'R','D','B','$','E','N','T','R',
   'Y','P','O','I','N','T',1,25,0,1,0,23,0,15,'R','D','B','$','M',
   'O','D','U','L','E','_','N','A','M','E',1,25,0,2,0,23,0,17,'R',
   'D','B','$','F','U','N','C','T','I','O','N','_','N','A','M',
   'E',1,41,0,7,0,6,0,23,0,15,'R','D','B','$','S','Y','S','T','E',
   'M','_','F','L','A','G',1,41,0,3,0,8,0,23,0,15,'R','D','B','$',
   'D','E','S','C','R','I','P','T','I','O','N',-1,-1,'L'
   };	/* end of blr string for request isc_595 */

static const short
   isc_606l = 178;
static const char
   isc_606 [] = {
   4,2,4,0,6,0,41,0,0,0,1,8,0,8,0,7,0,7,0,7,0,12,0,15,'J',9,'R',
   'D','B','$','F','I','L','E','S',0,2,1,25,0,3,0,23,0,17,'R','D',
   'B','$','S','H','A','D','O','W','_','N','U','M','B','E','R',
   1,25,0,1,0,23,0,15,'R','D','B','$','F','I','L','E','_','L','E',
   'N','G','T','H',1,25,0,2,0,23,0,14,'R','D','B','$','F','I','L',
   'E','_','S','T','A','R','T',1,25,0,4,0,23,0,17,'R','D','B','$',
   'F','I','L','E','_','S','E','Q','U','E','N','C','E',1,25,0,0,
   0,23,0,13,'R','D','B','$','F','I','L','E','_','N','A','M','E',
   1,25,0,5,0,23,0,14,'R','D','B','$','F','I','L','E','_','F','L',
   'A','G','S',-1,-1,'L'
   };	/* end of blr string for request isc_606 */

static const short
   isc_614l = 136;
static const char
   isc_614 [] = {
   4,2,4,0,4,0,41,3,0,32,0,8,0,8,0,7,0,12,0,15,'J',20,'R','D','B',
   '$','F','I','E','L','D','_','D','I','M','E','N','S','I','O',
   'N','S',0,2,1,25,0,1,0,23,0,15,'R','D','B','$','U','P','P','E',
   'R','_','B','O','U','N','D',1,25,0,2,0,23,0,15,'R','D','B','$',
   'L','O','W','E','R','_','B','O','U','N','D',1,25,0,3,0,23,0,
   13,'R','D','B','$','D','I','M','E','N','S','I','O','N',1,25,
   0,0,0,23,0,14,'R','D','B','$','F','I','E','L','D','_','N','A',
   'M','E',-1,-1,'L'
   };	/* end of blr string for request isc_614 */

static const short
   isc_620l = 582;
static const char
   isc_620 [] = {
   4,2,4,0,33,0,41,3,0,32,0,41,3,0,32,0,9,0,9,0,41,3,0,32,0,9,0,
   41,0,0,-128,0,9,0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,41,3,0,
   32,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,
   7,0,7,0,7,0,7,0,7,0,7,0,7,0,12,0,15,'J',19,'R','D','B','$','R',
   'E','L','A','T','I','O','N','_','F','I','E','L','D','S',0,2,
   1,25,0,0,0,23,0,16,'R','D','B','$','F','I','E','L','D','_','S',
   'O','U','R','C','E',1,25,0,1,0,23,0,14,'R','D','B','$','F','I',
   'E','L','D','_','N','A','M','E',1,41,0,13,0,12,0,23,0,16,'R',
   'D','B','$','C','O','L','L','A','T','I','O','N','_','I','D',
   1,41,0,15,0,14,0,23,0,13,'R','D','B','$','N','U','L','L','_',
   'F','L','A','G',1,41,0,2,0,16,0,23,0,17,'R','D','B','$','D',
   'E','F','A','U','L','T','_','V','A','L','U','E',1,41,0,3,0,17,
   0,23,0,18,'R','D','B','$','D','E','F','A','U','L','T','_','S',
   'O','U','R','C','E',1,41,0,19,0,18,0,23,0,15,'R','D','B','$',
   'U','P','D','A','T','E','_','F','L','A','G',1,41,0,4,0,20,0,
   23,0,16,'R','D','B','$','C','O','M','P','L','E','X','_','N',
   'A','M','E',1,41,0,22,0,21,0,23,0,15,'R','D','B','$','S','Y',
   'S','T','E','M','_','F','L','A','G',1,41,0,5,0,24,0,23,0,15,
   'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N',
   1,41,0,6,0,25,0,23,0,15,'R','D','B','$','E','D','I','T','_',
   'S','T','R','I','N','G',1,41,0,7,0,26,0,23,0,16,'R','D','B',
   '$','Q','U','E','R','Y','_','H','E','A','D','E','R',1,41,0,8,
   0,27,0,23,0,14,'R','D','B','$','Q','U','E','R','Y','_','N','A',
   'M','E',1,41,0,9,0,28,0,23,0,18,'R','D','B','$','S','E','C',
   'U','R','I','T','Y','_','C','L','A','S','S',1,41,0,10,0,29,0,
   23,0,14,'R','D','B','$','B','A','S','E','_','F','I','E','L',
   'D',1,41,0,31,0,30,0,23,0,16,'R','D','B','$','V','I','E','W',
   '_','C','O','N','T','E','X','T',1,41,0,32,0,23,0,23,0,18,'R',
   'D','B','$','F','I','E','L','D','_','P','O','S','I','T','I',
   'O','N',1,25,0,11,0,23,0,17,'R','D','B','$','R','E','L','A',
   'T','I','O','N','_','N','A','M','E',-1,-1,'L'
   };	/* end of blr string for request isc_620 */

static const short
   isc_655l = 151;
static const char
   isc_655 [] = {
   4,2,4,0,8,0,41,0,0,0,4,9,0,41,3,0,32,0,7,0,7,0,7,0,7,0,7,0,12,
   0,15,'J',14,'R','D','B','$','E','X','C','E','P','T','I','O',
   'N','S',0,2,1,41,0,4,0,3,0,23,0,15,'R','D','B','$','S','Y','S',
   'T','E','M','_','F','L','A','G',1,41,0,0,0,5,0,23,0,11,'R','D',
   'B','$','M','E','S','S','A','G','E',1,41,0,1,0,6,0,23,0,15,'R',
   'D','B','$','D','E','S','C','R','I','P','T','I','O','N',1,41,
   0,2,0,7,0,23,0,18,'R','D','B','$','E','X','C','E','P','T','I',
   'O','N','_','N','A','M','E',-1,-1,'L'
   };	/* end of blr string for request isc_655 */

static const short
   isc_665l = 178;
static const char
   isc_665 [] = {
   4,2,4,3,1,0,7,0,4,2,1,0,7,0,4,1,2,0,7,0,7,0,4,0,1,0,41,3,0,32,
   0,12,0,2,7,'C',1,'J',11,'R','D','B','$','I','N','D','I','C',
   'E','S',0,'G',47,23,0,14,'R','D','B','$','I','N','D','E','X',
   '_','N','A','M','E',25,0,0,0,-1,2,14,1,2,1,21,8,0,1,0,0,0,25,
   1,0,0,1,23,0,18,'R','D','B','$','I','N','D','E','X','_','I',
   'N','A','C','T','I','V','E',25,1,1,0,-1,17,0,9,13,12,3,18,0,
   12,2,10,0,1,2,1,25,2,0,0,23,1,18,'R','D','B','$','I','N','D',
   'E','X','_','I','N','A','C','T','I','V','E',-1,-1,-1,14,1,1,
   21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_665 */

static const short
   isc_675l = 336;
static const char
   isc_675 [] = {
   4,2,4,0,18,0,9,0,41,3,0,32,0,41,3,0,32,0,9,0,41,3,0,32,0,7,0,
   7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,12,0,15,'J',
   14,'R','D','B','$','C','O','L','L','A','T','I','O','N','S',0,
   2,1,41,0,0,0,5,0,23,0,23,'R','D','B','$','S','P','E','C','I',
   'F','I','C','_','A','T','T','R','I','B','U','T','E','S',1,41,
   0,1,0,6,0,23,0,23,'R','D','B','$','B','A','S','E','_','C','O',
   'L','L','A','T','I','O','N','_','N','A','M','E',1,41,0,2,0,7,
   0,23,0,17,'R','D','B','$','F','U','N','C','T','I','O','N','_',
   'N','A','M','E',1,41,0,3,0,8,0,23,0,15,'R','D','B','$','D','E',
   'S','C','R','I','P','T','I','O','N',1,41,0,10,0,9,0,23,0,15,
   'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G',
   1,41,0,12,0,11,0,23,0,24,'R','D','B','$','C','O','L','L','A',
   'T','I','O','N','_','A','T','T','R','I','B','U','T','E','S',
   1,41,0,14,0,13,0,23,0,20,'R','D','B','$','C','H','A','R','A',
   'C','T','E','R','_','S','E','T','_','I','D',1,41,0,16,0,15,0,
   23,0,16,'R','D','B','$','C','O','L','L','A','T','I','O','N',
   '_','I','D',1,41,0,4,0,17,0,23,0,18,'R','D','B','$','C','O',
   'L','L','A','T','I','O','N','_','N','A','M','E',-1,-1,'L'
   };	/* end of blr string for request isc_675 */

static const short
   isc_695l = 336;
static const char
   isc_695 [] = {
   4,2,4,0,18,0,9,0,41,3,0,32,0,41,3,0,32,0,9,0,41,3,0,32,0,7,0,
   7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,12,0,15,'J',
   14,'R','D','B','$','C','O','L','L','A','T','I','O','N','S',0,
   2,1,41,0,0,0,5,0,23,0,23,'R','D','B','$','S','P','E','C','I',
   'F','I','C','_','A','T','T','R','I','B','U','T','E','S',1,41,
   0,1,0,6,0,23,0,23,'R','D','B','$','B','A','S','E','_','C','O',
   'L','L','A','T','I','O','N','_','N','A','M','E',1,41,0,2,0,7,
   0,23,0,17,'R','D','B','$','F','U','N','C','T','I','O','N','_',
   'N','A','M','E',1,41,0,3,0,8,0,23,0,15,'R','D','B','$','D','E',
   'S','C','R','I','P','T','I','O','N',1,41,0,10,0,9,0,23,0,15,
   'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G',
   1,41,0,12,0,11,0,23,0,24,'R','D','B','$','C','O','L','L','A',
   'T','I','O','N','_','A','T','T','R','I','B','U','T','E','S',
   1,41,0,14,0,13,0,23,0,20,'R','D','B','$','C','H','A','R','A',
   'C','T','E','R','_','S','E','T','_','I','D',1,41,0,16,0,15,0,
   23,0,16,'R','D','B','$','C','O','L','L','A','T','I','O','N',
   '_','I','D',1,41,0,4,0,17,0,23,0,18,'R','D','B','$','C','O',
   'L','L','A','T','I','O','N','_','N','A','M','E',-1,-1,'L'
   };	/* end of blr string for request isc_695 */

static const short
   isc_715l = 106;
static const char
   isc_715 [] = {
   4,2,4,0,4,0,41,3,0,32,0,41,3,0,32,0,7,0,7,0,12,0,15,'J',21,'R',
   'D','B','$','C','H','E','C','K','_','C','O','N','S','T','R',
   'A','I','N','T','S',0,2,1,41,0,0,0,2,0,23,0,16,'R','D','B','$',
   'T','R','I','G','G','E','R','_','N','A','M','E',1,41,0,1,0,3,
   0,23,0,19,'R','D','B','$','C','O','N','S','T','R','A','I','N',
   'T','_','N','A','M','E',-1,-1,'L'
   };	/* end of blr string for request isc_715 */

static const short
   isc_721l = 347;
static const char
   isc_721 [] = {
   4,2,4,0,18,0,41,3,0,32,0,9,0,41,3,0,32,0,41,3,0,32,0,41,3,0,
   32,0,8,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,12,
   0,15,'J',18,'R','D','B','$','C','H','A','R','A','C','T','E',
   'R','_','S','E','T','S',0,2,1,41,0,7,0,6,0,23,0,23,'R','D','B',
   '$','B','Y','T','E','S','_','P','E','R','_','C','H','A','R',
   'A','C','T','E','R',1,41,0,0,0,8,0,23,0,17,'R','D','B','$','F',
   'U','N','C','T','I','O','N','_','N','A','M','E',1,41,0,1,0,9,
   0,23,0,15,'R','D','B','$','D','E','S','C','R','I','P','T','I',
   'O','N',1,41,0,11,0,10,0,23,0,15,'R','D','B','$','S','Y','S',
   'T','E','M','_','F','L','A','G',1,41,0,13,0,12,0,23,0,20,'R',
   'D','B','$','C','H','A','R','A','C','T','E','R','_','S','E',
   'T','_','I','D',1,41,0,2,0,14,0,23,0,24,'R','D','B','$','D',
   'E','F','A','U','L','T','_','C','O','L','L','A','T','E','_',
   'N','A','M','E',1,41,0,5,0,15,0,23,0,24,'R','D','B','$','N',
   'U','M','B','E','R','_','O','F','_','C','H','A','R','A','C',
   'T','E','R','S',1,41,0,3,0,16,0,23,0,15,'R','D','B','$','F',
   'O','R','M','_','O','F','_','U','S','E',1,41,0,4,0,17,0,23,0,
   22,'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S',
   'E','T','_','N','A','M','E',-1,-1,'L'
   };	/* end of blr string for request isc_721 */

static const short
   isc_741l = 141;
static const char
   isc_741 [] = {
   4,2,4,1,1,0,7,0,4,0,2,0,41,3,0,32,0,41,3,0,32,0,12,0,2,7,'C',
   1,'J',19,'R','D','B','$','R','E','L','A','T','I','O','N','_',
   'F','I','E','L','D','S',0,'D',21,8,0,1,0,0,0,'G',58,47,23,0,
   17,'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A',
   'M','E',25,0,1,0,47,23,0,14,'R','D','B','$','F','I','E','L',
   'D','_','N','A','M','E',25,0,0,0,-1,14,1,2,1,21,8,0,1,0,0,0,
   25,1,0,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_741 */

static const short
   isc_747l = 107;
static const char
   isc_747 [] = {
   4,2,4,1,1,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'J',13,'R',
   'D','B','$','R','E','L','A','T','I','O','N','S',0,'D',21,8,0,
   1,0,0,0,'G',47,23,0,17,'R','D','B','$','R','E','L','A','T','I',
   'O','N','_','N','A','M','E',25,0,0,0,-1,14,1,2,1,21,8,0,1,0,
   0,0,25,1,0,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_747 */

static const short
   isc_752l = 75;
static const char
   isc_752 [] = {
   4,2,4,0,2,0,41,0,0,0,1,8,0,12,0,15,'J',9,'R','D','B','$','F',
   'I','L','E','S',0,2,1,25,0,1,0,23,0,14,'R','D','B','$','F','I',
   'L','E','_','S','T','A','R','T',1,25,0,0,0,23,0,13,'R','D','B',
   '$','F','I','L','E','_','N','A','M','E',-1,-1,'L'
   };	/* end of blr string for request isc_752 */

static const short
   isc_756l = 152;
static const char
   isc_756 [] = {
   4,2,4,2,1,0,7,0,4,1,1,0,41,3,0,32,0,4,0,2,0,41,3,0,32,0,7,0,
   2,7,'C',1,'J',12,'R','D','B','$','D','A','T','A','B','A','S',
   'E',0,-1,2,14,0,2,1,23,0,18,'R','D','B','$','S','E','C','U',
   'R','I','T','Y','_','C','L','A','S','S',25,0,0,0,1,21,8,0,1,
   0,0,0,25,0,1,0,-1,17,0,9,13,12,2,18,0,12,1,11,10,0,1,2,1,25,
   1,0,0,23,1,18,'R','D','B','$','S','E','C','U','R','I','T','Y',
   '_','C','L','A','S','S',-1,-1,-1,14,0,1,21,8,0,0,0,0,0,25,0,
   1,0,-1,-1,'L'
   };	/* end of blr string for request isc_756 */

static const short
   isc_764l = 243;
static const char
   isc_764 [] = {
   4,2,4,3,1,0,7,0,4,2,1,0,41,3,0,32,0,4,1,4,0,41,3,0,32,0,41,3,
   0,32,0,41,3,0,32,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'J',
   13,'R','D','B','$','R','E','L','A','T','I','O','N','S',0,'G',
   47,23,0,17,'R','D','B','$','R','E','L','A','T','I','O','N','_',
   'N','A','M','E',25,0,0,0,-1,2,14,1,2,1,23,0,17,'R','D','B','$',
   'D','E','F','A','U','L','T','_','C','L','A','S','S',25,1,0,0,
   1,23,0,18,'R','D','B','$','S','E','C','U','R','I','T','Y','_',
   'C','L','A','S','S',25,1,1,0,1,23,0,14,'R','D','B','$','O','W',
   'N','E','R','_','N','A','M','E',25,1,2,0,1,21,8,0,1,0,0,0,25,
   1,3,0,-1,17,0,9,13,12,3,18,0,12,2,11,10,0,1,2,1,25,2,0,0,23,
   1,14,'R','D','B','$','O','W','N','E','R','_','N','A','M','E',
   -1,-1,-1,14,1,1,21,8,0,0,0,0,0,25,1,3,0,-1,-1,'L'
   };	/* end of blr string for request isc_764 */

static const short
   isc_776l = 215;
static const char
   isc_776 [] = {
   4,2,4,3,1,0,7,0,4,2,1,0,41,3,0,32,0,4,1,3,0,41,3,0,32,0,41,3,
   0,32,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'J',14,'R','D',
   'B','$','P','R','O','C','E','D','U','R','E','S',0,'G',47,23,
   0,18,'R','D','B','$','P','R','O','C','E','D','U','R','E','_',
   'N','A','M','E',25,0,0,0,-1,2,14,1,2,1,23,0,18,'R','D','B','$',
   'S','E','C','U','R','I','T','Y','_','C','L','A','S','S',25,1,
   0,0,1,23,0,14,'R','D','B','$','O','W','N','E','R','_','N','A',
   'M','E',25,1,1,0,1,21,8,0,1,0,0,0,25,1,2,0,-1,17,0,9,13,12,3,
   18,0,12,2,11,10,0,1,2,1,25,2,0,0,23,1,14,'R','D','B','$','O',
   'W','N','E','R','_','N','A','M','E',-1,-1,-1,14,1,1,21,8,0,0,
   0,0,0,25,1,2,0,-1,-1,'L'
   };	/* end of blr string for request isc_776 */

static const short
   isc_787l = 178;
static const char
   isc_787 [] = {
   4,2,4,3,1,0,7,0,4,2,1,0,7,0,4,1,2,0,7,0,7,0,4,0,1,0,41,3,0,32,
   0,12,0,2,7,'C',1,'J',11,'R','D','B','$','I','N','D','I','C',
   'E','S',0,'G',47,23,0,14,'R','D','B','$','I','N','D','E','X',
   '_','N','A','M','E',25,0,0,0,-1,2,14,1,2,1,21,8,0,1,0,0,0,25,
   1,0,0,1,23,0,18,'R','D','B','$','I','N','D','E','X','_','I',
   'N','A','C','T','I','V','E',25,1,1,0,-1,17,0,9,13,12,3,18,0,
   12,2,10,0,1,2,1,25,2,0,0,23,1,18,'R','D','B','$','I','N','D',
   'E','X','_','I','N','A','C','T','I','V','E',-1,-1,-1,14,1,1,
   21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_787 */

static const short
   isc_797l = 218;
static const char
   isc_797 [] = {
   4,2,4,1,2,0,41,3,0,32,0,7,0,4,0,2,0,41,0,0,12,0,7,0,12,0,2,7,
   'C',2,'J',24,'R','D','B','$','R','E','L','A','T','I','O','N',
   '_','C','O','N','S','T','R','A','I','N','T','S',0,'J',11,'R',
   'D','B','$','I','N','D','I','C','E','S',1,'G',58,47,23,0,19,
   'R','D','B','$','C','O','N','S','T','R','A','I','N','T','_',
   'T','Y','P','E',25,0,0,0,58,47,23,0,14,'R','D','B','$','I','N',
   'D','E','X','_','N','A','M','E',23,1,14,'R','D','B','$','I',
   'N','D','E','X','_','N','A','M','E',47,23,1,18,'R','D','B','$',
   'I','N','D','E','X','_','I','N','A','C','T','I','V','E',25,0,
   1,0,-1,14,1,2,1,23,1,14,'R','D','B','$','I','N','D','E','X',
   '_','N','A','M','E',25,1,0,0,1,21,8,0,1,0,0,0,25,1,1,0,-1,14,
   1,1,21,8,0,0,0,0,0,25,1,1,0,-1,-1,'L'
   };	/* end of blr string for request isc_797 */

static const short
   isc_804l = 267;
static const char
   isc_804 [] = {
   4,2,4,4,1,0,7,0,4,3,1,0,7,0,4,2,1,0,7,0,4,1,3,0,41,3,0,32,0,
   7,0,7,0,4,0,1,0,7,0,12,0,2,7,'C',1,'J',11,'R','D','B','$','I',
   'N','D','I','C','E','S',0,'G',58,47,23,0,18,'R','D','B','$',
   'I','N','D','E','X','_','I','N','A','C','T','I','V','E',25,0,
   0,0,61,23,0,15,'R','D','B','$','F','O','R','E','I','G','N','_',
   'K','E','Y',-1,2,14,1,2,1,23,0,14,'R','D','B','$','I','N','D',
   'E','X','_','N','A','M','E',25,1,0,0,1,21,8,0,1,0,0,0,25,1,1,
   0,1,23,0,18,'R','D','B','$','I','N','D','E','X','_','I','N',
   'A','C','T','I','V','E',25,1,2,0,-1,17,0,9,13,12,3,18,0,12,2,
   11,10,0,2,2,1,25,2,0,0,23,2,18,'R','D','B','$','I','N','D','E',
   'X','_','I','N','A','C','T','I','V','E',-1,12,4,11,10,0,1,2,
   1,25,4,0,0,23,1,18,'R','D','B','$','I','N','D','E','X','_','I',
   'N','A','C','T','I','V','E',-1,-1,-1,14,1,1,21,8,0,0,0,0,0,25,
   1,1,0,-1,-1,'L'
   };	/* end of blr string for request isc_804 */

static const short
   isc_817l = 178;
static const char
   isc_817 [] = {
   4,2,4,3,1,0,7,0,4,2,1,0,7,0,4,1,2,0,7,0,7,0,4,0,1,0,41,3,0,32,
   0,12,0,2,7,'C',1,'J',11,'R','D','B','$','I','N','D','I','C',
   'E','S',0,'G',47,23,0,14,'R','D','B','$','I','N','D','E','X',
   '_','N','A','M','E',25,0,0,0,-1,2,14,1,2,1,21,8,0,1,0,0,0,25,
   1,0,0,1,23,0,18,'R','D','B','$','I','N','D','E','X','_','I',
   'N','A','C','T','I','V','E',25,1,1,0,-1,17,0,9,13,12,3,18,0,
   12,2,10,0,1,2,1,25,2,0,0,23,1,18,'R','D','B','$','I','N','D',
   'E','X','_','I','N','A','C','T','I','V','E',-1,-1,-1,14,1,1,
   21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_817 */


#define gds_blob_null	isc_blob_null	/* compatibility symbols */
#define gds_status	isc_status
#define gds_status2	isc_status2
#define gds_array_length	isc_array_length
#define gds_count	isc_count
#define gds_slack	isc_slack
#define gds_utility	isc_utility	/* end of compatibility symbols */

#ifndef isc_version4
    Generate a compile-time error.
    Picking up a V3 include file after preprocessing with V4 GPRE.
#endif

/**** end of GPRE definitions ****/


#define DB			tdgbl->db_handle
#define gds_trans	tdgbl->tr_handle
#define isc_status	tdgbl->status_vector


namespace // unnamed, private
{


const int DB_VERSION_DDL4		= 40;  // ods4 db
const int DB_VERSION_DDL5		= 50;  // ods5 db
const int DB_VERSION_DDL8		= 80;  // ods8 db, IB4
const int DB_VERSION_DDL9		= 90;  // ods9 db, IB5
const int DB_VERSION_DDL10		= 100; // ods10 db, IB6, FB1, FB1.5
const int DB_VERSION_DDL11		= 110; // ods11 db, FB2
const int DB_VERSION_DDL11_1	= 111; // ods11.1 db, FB2.1
const int DB_VERSION_DDL11_2	= 112; // ods11.2 db, FB2.5

const int DB_VERSION_OLDEST_SUPPORTED = DB_VERSION_DDL8;  // IB4.0 is ods8

const int DEFERRED_ACTIVE		= 3;	// RDB$INDEX_INACTIVE setting for Foreign Keys
										// This setting is used temporarily while
										// restoring a database. This was required
										// in order to differentiate a partial
										// "inactive" state of SOME indices from
										// "inactive" state of ALL indices (gbak -i)
										// -bsriram, 11-May-1999      BUG: 10016


const int RESTORE_VERBOSE_INTERVAL	= 10000;
const int burp_msg_fac				= 12;

enum scan_attr_t
{
	NO_SKIP		= 0,	// Not in skipping and scanning mode
	BEFORE_SKIP	= 1,	// After skipping, before scanning next byte for valid attribute
	AFTER_SKIP	= 2	// After skipping and after scanning next byte for valid attribute
};

void	add_files(BurpGlobals* tdgbl, const char*);
void	bad_attribute(scan_attr_t, att_type, USHORT);
void	check_db_version(BurpGlobals* tdgbl);
void	create_database(BurpGlobals* tdgbl, const TEXT*);
void	decompress(BurpGlobals* tdgbl, UCHAR*, USHORT);
void	eat_blob(BurpGlobals* tdgbl);
void	eat_text(BurpGlobals* tdgbl);
void	eat_text2(BurpGlobals* tdgbl);
burp_rel*	find_relation(BurpGlobals* tdgbl, const TEXT*);
void	fix_security_class_name(BurpGlobals* tdgbl, TEXT* sec_class, bool is_field);
// CVC: when do these functions return false indeed???
// get_acl and get_index are the only exceptions but ironically their
// returned value is not checked by the caller!
bool	get_acl(BurpGlobals* tdgbl, const TEXT*, ISC_QUAD*, ISC_QUAD*);
void	get_array(BurpGlobals* tdgbl, burp_rel*, UCHAR*);
void	get_blob(BurpGlobals* tdgbl, const burp_fld*, UCHAR*);
void	get_blr_blob(BurpGlobals* tdgbl, ISC_QUAD&, bool);
bool	get_character_set(BurpGlobals* tdgbl);
bool	get_chk_constraint(BurpGlobals* tdgbl);
bool	get_collation(BurpGlobals* tdgbl);
rec_type	get_data(BurpGlobals* tdgbl, burp_rel*);
bool	get_exception(BurpGlobals* tdgbl);
burp_fld*	get_field(BurpGlobals* tdgbl, burp_rel*);
bool	get_field_dimensions(BurpGlobals* tdgbl);
bool	get_files(BurpGlobals* tdgbl);
bool	get_filter(BurpGlobals* tdgbl);
bool	get_function(BurpGlobals* tdgbl);
void	get_function_arg(BurpGlobals* tdgbl, bool skip_arguments);
bool	get_generator(BurpGlobals* tdgbl);
bool	get_global_field(BurpGlobals* tdgbl);
bool	get_index(BurpGlobals* tdgbl, const burp_rel*);
void	get_misc_blob(BurpGlobals* tdgbl, ISC_QUAD&, bool);
SLONG	get_numeric(BurpGlobals* tdgbl);
SINT64  get_int64(BurpGlobals* tdgbl);
bool	get_procedure(BurpGlobals* tdgbl);
bool	get_procedure_prm (BurpGlobals* tdgbl, GDS_NAME );
bool	get_ref_constraint(BurpGlobals* tdgbl);
bool	get_rel_constraint(BurpGlobals* tdgbl);
bool	get_relation(BurpGlobals* tdgbl);
bool	get_relation_data(BurpGlobals* tdgbl);
bool	get_sql_roles(BurpGlobals* tdgbl);
bool	get_mapping(BurpGlobals* tdgbl);
bool	get_security_class(BurpGlobals* tdgbl);
void	get_source_blob(BurpGlobals* tdgbl, ISC_QUAD&, bool);
USHORT	get_text(BurpGlobals* tdgbl, TEXT*, ULONG);
USHORT	get_text2(BurpGlobals* tdgbl, TEXT* text, ULONG length);
bool	get_trigger(BurpGlobals* tdgbl);
bool	get_trigger_message(BurpGlobals* tdgbl);
bool	get_trigger_old (BurpGlobals* tdgbl, burp_rel*);
bool	get_type(BurpGlobals* tdgbl);
bool	get_user_privilege(BurpGlobals* tdgbl);
bool	get_view(BurpGlobals* tdgbl, burp_rel*);
void	ignore_array(BurpGlobals* tdgbl, burp_rel*);
void	ignore_blob(BurpGlobals* tdgbl);
rec_type	ignore_data(BurpGlobals* tdgbl, burp_rel*);
void	realign(BurpGlobals* tdgbl, UCHAR*, const burp_rel*);
#ifdef sparc
USHORT	recompute_length(BurpGlobals* tdgbl, burp_rel*);
#endif
bool	restore(BurpGlobals* tdgbl, const TEXT*, const TEXT*);
void	restore_security_class(BurpGlobals* tdgbl, const TEXT*, const TEXT*);
USHORT	get_view_base_relation_count(BurpGlobals* tdgbl, const TEXT*, USHORT);
void	store_blr_gen_id(BurpGlobals* tdgbl, const TEXT*, SINT64, const ISC_QUAD*);
void	update_global_field(BurpGlobals* tdgbl);
void	update_view_dbkey_lengths(BurpGlobals* tdgbl);
void	fix_system_generators(BurpGlobals* tdgbl);
void	general_on_error();
#ifdef DEBUG
UCHAR	debug_on = 0;   // able to turn this on in the debugger
#endif

#ifdef sparc
const SSHORT old_sparcs[] =
    {0, 0, 0, 2, 0, 0, 0, 0, 2, 4, 4, 4, 8, 8, 0, 0, 8, 8, 8};
#endif

//MVOL_read returns int
static inline int get(BurpGlobals* tdgbl)
{
	if (--(tdgbl->io_cnt) >= 0)
		return *(tdgbl->io_ptr)++;

	return MVOL_read(&tdgbl->io_cnt, &tdgbl->io_ptr);
}

static inline att_type get_attribute(att_type* att, BurpGlobals* tdgbl)
{
	*att = (att_type) get(tdgbl);
	return *att;
}

static inline rec_type get_record(rec_type *rec, BurpGlobals* tdgbl)
{
	*rec = (rec_type) get(tdgbl);
	return *rec;
}

#define GET_TEXT(text)	get_text(tdgbl, (text), sizeof(text))
#define GET_TEXT2(text)	get_text2(tdgbl, (text), sizeof(text))

static inline void get_skip(BurpGlobals* tdgbl, ULONG n)
{
	MVOL_skip_block(tdgbl, n);
}

static inline UCHAR* get_block(BurpGlobals* tdgbl, UCHAR* p, ULONG n)
{
	return MVOL_read_block(tdgbl, p, n);
}

// When skipping started, scan_next_attr will be changed from NO_SKIP
// to BEFORE_SKIP. When scanning for next valid attribute after skipping,
// it will flip-flop between BEFORE_SKIP and AFTER_SKIP. When next valid
// attribute is found, it will be changed back to NO_SKIP by 'skip_scan'

static inline void skip_init(scan_attr_t* scan_next_attr)
{
	*scan_next_attr = NO_SKIP;
}

static inline void skip_scan(scan_attr_t* scan_next_attr)
{
	if (*scan_next_attr == AFTER_SKIP)
		*scan_next_attr = BEFORE_SKIP;
	else if (*scan_next_attr == BEFORE_SKIP)
		*scan_next_attr = NO_SKIP;
	//else 0; => nothing, no change in the original macro
}

// User Privilege Flags

const int USER_PRIV_USER			= 1;
const int USER_PRIV_GRANTOR			= 2;
const int USER_PRIV_PRIVILEGE		= 4;
const int USER_PRIV_GRANT_OPTION	= 8;
const int USER_PRIV_OBJECT_NAME		= 16;
const int USER_PRIV_FIELD_NAME		= 32;
const int USER_PRIV_USER_TYPE		= 64;
const int USER_PRIV_OBJECT_TYPE		= 128;

} // namespace


int RESTORE_restore (const TEXT* file_name, const TEXT* database_name)
{
   struct isc_762_struct {
          short isc_763;	/* isc_utility */
   } isc_762;
   struct isc_760_struct {
          char  isc_761 [32];	/* RDB$SECURITY_CLASS */
   } isc_760;
   struct isc_757_struct {
          char  isc_758 [32];	/* RDB$SECURITY_CLASS */
          short isc_759;	/* isc_utility */
   } isc_757;
   struct isc_774_struct {
          short isc_775;	/* isc_utility */
   } isc_774;
   struct isc_772_struct {
          char  isc_773 [32];	/* RDB$OWNER_NAME */
   } isc_772;
   struct isc_767_struct {
          char  isc_768 [32];	/* RDB$DEFAULT_CLASS */
          char  isc_769 [32];	/* RDB$SECURITY_CLASS */
          char  isc_770 [32];	/* RDB$OWNER_NAME */
          short isc_771;	/* isc_utility */
   } isc_767;
   struct isc_765_struct {
          char  isc_766 [32];	/* RDB$RELATION_NAME */
   } isc_765;
   struct isc_785_struct {
          short isc_786;	/* isc_utility */
   } isc_785;
   struct isc_783_struct {
          char  isc_784 [32];	/* RDB$OWNER_NAME */
   } isc_783;
   struct isc_779_struct {
          char  isc_780 [32];	/* RDB$SECURITY_CLASS */
          char  isc_781 [32];	/* RDB$OWNER_NAME */
          short isc_782;	/* isc_utility */
   } isc_779;
   struct isc_777_struct {
          char  isc_778 [32];	/* RDB$PROCEDURE_NAME */
   } isc_777;
   struct isc_795_struct {
          short isc_796;	/* isc_utility */
   } isc_795;
   struct isc_793_struct {
          short isc_794;	/* RDB$INDEX_INACTIVE */
   } isc_793;
   struct isc_790_struct {
          short isc_791;	/* isc_utility */
          short isc_792;	/* RDB$INDEX_INACTIVE */
   } isc_790;
   struct isc_788_struct {
          char  isc_789 [32];	/* RDB$INDEX_NAME */
   } isc_788;
   struct isc_801_struct {
          char  isc_802 [32];	/* RDB$INDEX_NAME */
          short isc_803;	/* isc_utility */
   } isc_801;
   struct isc_798_struct {
          char  isc_799 [12];	/* RDB$CONSTRAINT_TYPE */
          short isc_800;	/* RDB$INDEX_INACTIVE */
   } isc_798;
   struct isc_815_struct {
          short isc_816;	/* RDB$INDEX_INACTIVE */
   } isc_815;
   struct isc_813_struct {
          short isc_814;	/* isc_utility */
   } isc_813;
   struct isc_811_struct {
          short isc_812;	/* RDB$INDEX_INACTIVE */
   } isc_811;
   struct isc_807_struct {
          char  isc_808 [32];	/* RDB$INDEX_NAME */
          short isc_809;	/* isc_utility */
          short isc_810;	/* RDB$INDEX_INACTIVE */
   } isc_807;
   struct isc_805_struct {
          short isc_806;	/* RDB$INDEX_INACTIVE */
   } isc_805;
   struct isc_825_struct {
          short isc_826;	/* isc_utility */
   } isc_825;
   struct isc_823_struct {
          short isc_824;	/* RDB$INDEX_INACTIVE */
   } isc_823;
   struct isc_820_struct {
          short isc_821;	/* isc_utility */
          short isc_822;	/* RDB$INDEX_INACTIVE */
   } isc_820;
   struct isc_818_struct {
          char  isc_819 [32];	/* RDB$INDEX_NAME */
   } isc_818;
/**************************************
 *
 *	R E S T O R E _ r e s t o r e
 *
 **************************************
 *
 * Functional description
 *	Recreate a database from a backup.
 *
 **************************************/
	isc_req_handle  req_handle1 = 0, req_handle2 = 0, req_handle3 = 0;
	isc_req_handle	req_handle4 = 0, req_handle5 = 0;
	/*BASED_ON RDB$INDICES.RDB$INDEX_NAME index_name;*/
	char
	   index_name[32];


	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	tdgbl->io_ptr = NULL;
	tdgbl->io_cnt = 0;

	tdgbl->relations = NULL;
	tdgbl->procedures = NULL;
	tdgbl->RESTORE_format = 0;
	tdgbl->RESTORE_ods = 0;
	tdgbl->global_trans = 0;

	tdgbl->gbl_sw_transportable = tdgbl->gbl_sw_compress = false;

	if (!restore(tdgbl, file_name, database_name))
		return FINI_ERROR;

	BURP_verbose (76);
	// msg 76 creating indexes

	/*COMMIT;*/
	{
	isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		// Fix for bug_no 8055:
		// don't throw away the database just because an index
		// could not be made
		long error_code;
		while (error_code = tdgbl->status_vector[1])
		{
			switch (error_code)
			{
				case isc_sort_mem_err:
				case isc_no_dup:
					strcpy(index_name, (TEXT *)tdgbl->status_vector[3]);
					BURP_print_status(false, tdgbl->status_vector);
					/*FOR (REQUEST_HANDLE req_handle3)
						IDX IN RDB$INDICES WITH IDX.RDB$INDEX_NAME EQ index_name*/
					{
                                        if (!req_handle3)
                                           isc_compile_request (NULL, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle3, (short) sizeof(isc_817), (char*) isc_817);
					isc_vtov ((const char*) index_name, (char*) isc_818.isc_819, 32);
                                        isc_start_and_send (NULL, (FB_API_HANDLE*) &req_handle3, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_818, (short) 0);
					while (1)
					   {
                                           isc_receive (NULL, (FB_API_HANDLE*) &req_handle3, (short) 1, (short) 4, &isc_820, (short) 0);
					   if (!isc_820.isc_821) break;

						BURP_verbose(243, index_name);
						/*MODIFY IDX USING*/
						{
							/*IDX.RDB$INDEX_INACTIVE*/
							isc_820.isc_822 = TRUE;
						/*END_MODIFY;*/
						isc_823.isc_824 = isc_820.isc_822;
                                                isc_send (NULL, (FB_API_HANDLE*) &req_handle3, (short) 2, (short) 2, &isc_823, (short) 0);
						}
						BURP_print(false, 240, index_name);
						// msg 240 Index \"%s\" failed to activate because:
						if ( error_code == isc_no_dup )
						{
							BURP_print(false, 241);
							// msg 241 The unique index has duplicate values or NULLs
							BURP_print(false, 242);
							// msg 242 Delete or Update duplicate values or NULLs, and activate index with
						}
						else
						{
							BURP_print(false, 244);
							// msg 244 Not enough disk space to create the sort file for an index
							BURP_print(false, 245);
							// msg 245 Set the TMP environment variable to a directory on a filesystem that does have enough space, and activate index with
						}
						BURP_print(false, 243, index_name);
						// msg 243 ALTER INDEX \"%s\" ACTIVE;
					/*END_FOR;*/
                                           isc_send (NULL, (FB_API_HANDLE*) &req_handle3, (short) 3, (short) 2, &isc_825, (short) 0);
					   }
					}
					// don't bring the database on-line
					tdgbl->flag_on_line = false;
					break;
				default:
					general_on_error ();
				break;
			}
			/*COMMIT*/
			{
			isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				continue;
			/*END_ERROR*/
			   }
			}
		}
	/*END_ERROR;*/
	   }
	}

	if (tdgbl->global_trans)
	{
		BURP_verbose (68);
		// msg 68 committing meta data
		/*EXEC SQL COMMIT TRANSACTION tdgbl->global_trans;*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &tdgbl->global_trans);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			general_on_error ();
		// Check to see if there is a warning
		if (gds_status[0] == isc_arg_gds && gds_status[1] == 0 && gds_status[2] != isc_arg_end)
		{
			BURP_print_warning(gds_status);
		}
	}

	// Activate the indices for foreign keys / expression indices and do another commit
	if (!tdgbl->gbl_sw_deactivate_indexes)
	{
		// Block added to verbose index creation by Toni Martir
		// Always try to activate deferred indices - it helps for some broken backups,
		// and in normal cases doesn't take much time to look for such indices. AP-2008.
		/*EXEC SQL SET TRANSACTION ISOLATION LEVEL READ COMMITTED NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 6, isc_tpb_0);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_1);
			SQLCODE = isc_sqlcode(isc_status);
			}

		// Activate first indexes that are not foreign keys
		/*FOR (REQUEST_HANDLE req_handle1) IDS IN RDB$INDICES WITH
			IDS.RDB$INDEX_INACTIVE EQ DEFERRED_ACTIVE AND
			IDS.RDB$FOREIGN_KEY MISSING*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_804), (char*) isc_804);
		isc_805.isc_806 = DEFERRED_ACTIVE;
		if (req_handle1)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 2, &isc_805, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 1, (short) 36, &isc_807, (short) 0);
		   if (!isc_807.isc_809 || isc_status [1]) break;

			MISC_terminate(/*IDS.RDB$INDEX_NAME*/
				       isc_807.isc_808, index_name,
				(ULONG) MISC_symbol_length(/*IDS.RDB$INDEX_NAME*/
							   isc_807.isc_808, sizeof(/*IDS.RDB$INDEX_NAME*/
	 isc_807.isc_808)),
				sizeof(index_name));
			BURP_verbose(285, index_name);
			// activating and creating deferred index %s
			/*MODIFY IDS USING*/
			{
				/*IDS.RDB$INDEX_INACTIVE*/
				isc_807.isc_810 = FALSE;
			/*END_MODIFY;*/
			isc_815.isc_816 = isc_807.isc_810;
                        isc_send (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 4, (short) 2, &isc_815, (short) 0);;
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error();
			/*END_ERROR;*/
			   }
			}

			/*SAVE*/
			{
			isc_commit_retaining (isc_status, (FB_API_HANDLE*) &gds_trans);;
			// existing ON_ERROR continues past error, beck
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				BURP_print (false, 173, index_name);
				BURP_print_status(false, isc_status);
				/*MODIFY IDS USING*/
				{
					/*IDS.RDB$INDEX_INACTIVE*/
					isc_807.isc_810 = TRUE;
				/*END_MODIFY;*/
				isc_811.isc_812 = isc_807.isc_810;
                                isc_send (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 2, (short) 2, &isc_811, (short) 0);;
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
				tdgbl->flag_on_line = false;
			/*END_ERROR;*/
			   }
			}
		/*END_FOR;*/
                   isc_send (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 3, (short) 2, &isc_813, (short) 0);
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
		MISC_release_request_silent(req_handle1);
		/*COMMIT;*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

		/*EXEC SQL SET TRANSACTION ISOLATION LEVEL READ COMMITTED NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 6, isc_tpb_2);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_3);
			SQLCODE = isc_sqlcode(isc_status);
			}

		// Only activate Foreign keys that have been marked for deferred
		// activation.
		// -bsriram, 11-May-1999             BUG: 10016

		// In case error happens creating FK, triggers don't let set
		// INACTIVE = TRUE for FK index. Therefore use separate
		// transaction be able to rollback when needed.
		// AP, 2005

		/*FOR (REQUEST_HANDLE req_handle1)
			CNST IN RDB$RELATION_CONSTRAINTS
			CROSS IDS IN RDB$INDICES WITH
			CNST.RDB$CONSTRAINT_TYPE EQ FOREIGN_KEY AND
			CNST.RDB$INDEX_NAME EQ IDS.RDB$INDEX_NAME AND
			IDS.RDB$INDEX_INACTIVE EQ DEFERRED_ACTIVE*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_797), (char*) isc_797);
		isc_vtov ((const char*) FOREIGN_KEY, (char*) isc_798.isc_799, 12);
		isc_798.isc_800 = DEFERRED_ACTIVE;
		if (req_handle1)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 14, &isc_798, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 1, (short) 34, &isc_801, (short) 0);
		   if (!isc_801.isc_803 || isc_status [1]) break;

			MISC_terminate(/*IDS.RDB$INDEX_NAME*/
				       isc_801.isc_802, index_name,
				(ULONG) MISC_symbol_length(/*IDS.RDB$INDEX_NAME*/
							   isc_801.isc_802, sizeof(/*IDS.RDB$INDEX_NAME*/
	 isc_801.isc_802)),
				sizeof(index_name));
			BURP_verbose(285, index_name);
			// activating and creating deferred index %s

			bool fError = false;
			isc_tr_handle activateIndexTran = 0;
			ISC_STATUS_ARRAY local_status_vector;
			ISC_STATUS* local_status = local_status_vector;

			/*START_TRANSACTION activateIndexTran;*/
			{
			isc_start_transaction (NULL, (FB_API_HANDLE*) &activateIndexTran, (short) 1, &DB, (short) 4, isc_tpb_4);
			}
			/*FOR (TRANSACTION_HANDLE activateIndexTran REQUEST_HANDLE req_handle5)
				IND1 IN RDB$INDICES WITH IND1.RDB$INDEX_NAME EQ IDS.RDB$INDEX_NAME*/
			{
                        if (!req_handle5)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle5, (short) sizeof(isc_787), (char*) isc_787);
			isc_vtov ((const char*) isc_801.isc_802, (char*) isc_788.isc_789, 32);
			if (req_handle5)
			   {
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle5, (FB_API_HANDLE*) &activateIndexTran, (short) 0, (short) 32, &isc_788, (short) 0);
			   }
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle5, (short) 1, (short) 4, &isc_790, (short) 0);
			   if (!isc_790.isc_791 || isc_status [1]) break;
				/*MODIFY IND1 USING*/
				{
						/*IND1.RDB$INDEX_INACTIVE*/
						isc_790.isc_792 = FALSE;
				/*END_MODIFY;*/
				isc_793.isc_794 = isc_790.isc_792;
                                isc_send (NULL, (FB_API_HANDLE*) &req_handle5, (short) 2, (short) 2, &isc_793, (short) 0);
				}
			/*END_FOR;*/
                           isc_send (isc_status, (FB_API_HANDLE*) &req_handle5, (short) 3, (short) 2, &isc_795, (short) 0);
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				fError = true;
				memcpy(local_status, isc_status, sizeof (ISC_STATUS_ARRAY));
			/*END_ERROR;*/
			   }
			}
			MISC_release_request_silent(req_handle5);

			if (!fError)
			{
				/*COMMIT activateIndexTran;*/
				{
				isc_commit_transaction (isc_status, (FB_API_HANDLE*) &activateIndexTran);;
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					fError = true;
					memcpy(local_status, isc_status, sizeof (ISC_STATUS_ARRAY));
				/*END_ERROR;*/
				   }
				}
			}
			if (fError)
			{
				/*ROLLBACK activateIndexTran;*/
				{
				isc_rollback_transaction (isc_status, (FB_API_HANDLE*) &activateIndexTran);;
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
				BURP_print (false, 173, index_name);
				BURP_print_status(false, local_status);
				tdgbl->flag_on_line = false;
			}
		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
		MISC_release_request_silent(req_handle1);
		/*COMMIT;*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}

	/*EXEC SQL SET TRANSACTION ISOLATION LEVEL READ COMMITTED NO_AUTO_UNDO;*/
	{
	isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 6, isc_tpb_5);
	SQLCODE = isc_sqlcode(isc_status);
	}
	if (gds_status[1])
		/*EXEC SQL SET TRANSACTION;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_6);
		SQLCODE = isc_sqlcode(isc_status);
		}

	// AB: Recalculate RDB$DBKEY_LENGTH for VIEWS
	// When VIEWs are not processed in correct dependency order
	// then on create time it doesn't know anything from the
	// VIEW that's referenced.
	//
	update_view_dbkey_lengths(tdgbl);

	// Change ownership of any procedures necessary

	for (burp_prc* procedure = tdgbl->procedures; procedure; procedure = procedure->prc_next)
	{
		if (procedure->prc_owner[0])
		{
			/*FOR (REQUEST_HANDLE req_handle4)
				X IN RDB$PROCEDURES WITH X.RDB$PROCEDURE_NAME EQ procedure->prc_name*/
			{
                        if (!req_handle4)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle4, (short) sizeof(isc_776), (char*) isc_776);
			isc_vtov ((const char*) procedure->prc_name, (char*) isc_777.isc_778, 32);
			if (req_handle4)
			   {
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle4, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_777, (short) 0);
			   }
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 1, (short) 66, &isc_779, (short) 0);
			   if (!isc_779.isc_782 || isc_status [1]) break;

				/*MODIFY X*/
				{
					strcpy (/*X.RDB$OWNER_NAME*/
						isc_779.isc_781, procedure->prc_owner);
				/*END_MODIFY;*/
				isc_ftof (isc_779.isc_781, 32, isc_783.isc_784, 32);
                                isc_send (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 2, (short) 32, &isc_783, (short) 0);;
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					MISC_release_request_silent(req_handle4);
					general_on_error ();
				/*END_ERROR;*/
				   }
				}

				restore_security_class(tdgbl, procedure->prc_owner, /*X.RDB$SECURITY_CLASS*/
										    isc_779.isc_780);

			/*END_FOR;*/
                           isc_send (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 3, (short) 2, &isc_785, (short) 0);
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				MISC_release_request_silent(req_handle4);
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
		}
	}

	MISC_release_request_silent(req_handle4);

	// Change ownership of any relations necessary

	for (burp_rel* relation = tdgbl->relations; relation; relation = relation->rel_next)
	{
		if (relation->rel_owner[0])
		{
			/*FOR (REQUEST_HANDLE req_handle2)
				X IN RDB$RELATIONS WITH X.RDB$RELATION_NAME EQ relation->rel_name*/
			{
                        if (!req_handle2)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle2, (short) sizeof(isc_764), (char*) isc_764);
			isc_vtov ((const char*) relation->rel_name, (char*) isc_765.isc_766, 32);
			if (req_handle2)
			   {
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle2, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_765, (short) 0);
			   }
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 1, (short) 98, &isc_767, (short) 0);
			   if (!isc_767.isc_771 || isc_status [1]) break;
				/*MODIFY X*/
				{
					strcpy (/*X.RDB$OWNER_NAME*/
						isc_767.isc_770, relation->rel_owner);
				/*END_MODIFY;*/
				isc_ftof (isc_767.isc_770, 32, isc_772.isc_773, 32);
                                isc_send (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 2, (short) 32, &isc_772, (short) 0);;
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					MISC_release_request_silent(req_handle2);
					general_on_error ();
				/*END_ERROR;*/
				   }
				}

				restore_security_class(tdgbl, relation->rel_owner, /*X.RDB$SECURITY_CLASS*/
										   isc_767.isc_769);
				restore_security_class(tdgbl, relation->rel_owner, /*X.RDB$DEFAULT_CLASS*/
										   isc_767.isc_768);

			/*END_FOR;*/
                           isc_send (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 3, (short) 2, &isc_774, (short) 0);
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				MISC_release_request_silent(req_handle2);
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
		}
	}

	MISC_release_request_silent(req_handle2);

	// Now that changing ownership of tables is over, it is safe to
	// update the database security class in RDB$DATABASE

	if (tdgbl->database_security_class[0]) // Do it only if it's not NULL
	{
		/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$DATABASE*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_756), (char*) isc_756);
		if (req_handle1)
		   {
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 34, &isc_757, (short) 0);
		   if (!isc_757.isc_759 || isc_status [1]) break;
			/*MODIFY X USING*/
			{
				strncpy(/*X.RDB$SECURITY_CLASS*/
					isc_757.isc_758, tdgbl->database_security_class,
					sizeof(/*X.RDB$SECURITY_CLASS*/
					       isc_757.isc_758));
			/*END_MODIFY;*/
			isc_ftof (isc_757.isc_758, 32, isc_760.isc_761, 32);
                        isc_send (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 1, (short) 32, &isc_760, (short) 0);;
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				MISC_release_request_silent(req_handle1);
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
		/*END_FOR;*/
                   isc_send (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 2, (short) 2, &isc_762, (short) 0);
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			MISC_release_request_silent(req_handle1);
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

		MISC_release_request_silent(req_handle1);
	}

	// Fix values of system generators.
	fix_system_generators(tdgbl);

	/*COMMIT;*/
	{
	isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	// Check to see if there is a warning
	if (gds_status[0] == isc_arg_gds && gds_status[1] == 0 && gds_status[2] != isc_arg_end)
	{
		BURP_print_warning(gds_status);
	}

	BURP_verbose (88);
	// msg 88 finishing, closing, and going home

	//FB_UINT64 cumul_count =
	MVOL_fini_read();

	if (tdgbl->gbl_stat_flags)
		BURP_verbose(369);
	// msg 369 total statistics

	// Close database before we attach to it again.
	/*FINISH*/
	{
	if (DB)
	   isc_detach_database (isc_status, &DB);;
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	// attach database again to put it online

	Firebird::ClumpletWriter dpb(Firebird::ClumpletReader::Tagged, MAX_DPB_SIZE, isc_dpb_version1);
	tdgbl->uSvc->getAddressPath(dpb);

	if (tdgbl->flag_on_line)
	{
		dpb.insertTag(isc_dpb_online);
	}

	if (tdgbl->gbl_sw_user)
	{
		dpb.insertString(isc_dpb_user_name, tdgbl->gbl_sw_user, strlen(tdgbl->gbl_sw_user));
	}
	if (tdgbl->gbl_sw_password)
	{
		dpb.insertString(tdgbl->uSvc->isService() ? isc_dpb_password_enc : isc_dpb_password,
							 tdgbl->gbl_sw_password, strlen(tdgbl->gbl_sw_password));
	}
	if (tdgbl->gbl_sw_tr_user)
	{
		dpb.insertString(isc_dpb_trusted_auth, tdgbl->gbl_sw_tr_user, strlen(tdgbl->gbl_sw_tr_user));
	}

	dpb.insertByte(isc_dpb_no_db_triggers, 1);

	// set forced writes to the value which was in the header
	dpb.insertByte(isc_dpb_force_write, tdgbl->hdr_forced_writes ? 1 : 0);

	FB_API_HANDLE db_handle = 0;
	if (isc_attach_database(tdgbl->status_vector, 0, database_name, &db_handle,
							dpb.getBufferLength(), reinterpret_cast<const SCHAR*>(dpb.getBuffer())))
	{
		general_on_error();
	}
	if (isc_detach_database (tdgbl->status_vector, &db_handle))
		general_on_error();

	if (!tdgbl->flag_on_line)
	{
		BURP_print(false, 246);
		// msg 246 Database is not online due to failure to activate one or more indices.
		BURP_print(false, 247);
		// msg 247 Run gfix -online to bring database online without active indices.
		return FINI_DB_NOT_ONLINE;
	}

	// If the database is to be restored ReadOnly, set it to read_only now!
	if (tdgbl->gbl_sw_mode && tdgbl->gbl_sw_mode_val)
	{
		BURP_verbose (280);
		// msg 280: setting database to read-only access

		dpb.reset(isc_dpb_version1);
		if (tdgbl->gbl_sw_user)
		{
			dpb.insertString(isc_dpb_user_name, tdgbl->gbl_sw_user, strlen(tdgbl->gbl_sw_user));
		}
		if (tdgbl->gbl_sw_password)
		{
			dpb.insertString(tdgbl->uSvc->isService() ? isc_dpb_password_enc : isc_dpb_password,
							 tdgbl->gbl_sw_password, strlen(tdgbl->gbl_sw_password));
		}
		if (tdgbl->gbl_sw_tr_user)
		{
			dpb.insertString(isc_dpb_trusted_auth, tdgbl->gbl_sw_tr_user, strlen(tdgbl->gbl_sw_tr_user));
		}

		dpb.insertByte(isc_dpb_set_db_readonly, 1);
		dpb.insertByte(isc_dpb_no_db_triggers, 1);

		if (isc_attach_database(tdgbl->status_vector, 0, database_name, &db_handle,
								dpb.getBufferLength(), reinterpret_cast<const SCHAR*>(dpb.getBuffer())))
		{
			general_on_error();
		}
		if (isc_detach_database (tdgbl->status_vector, &db_handle))
			general_on_error();

	}

	return FINI_OK;
}

namespace // unnamed, private
{

void add_files(BurpGlobals* tdgbl, const char* file_name)
{
   struct isc_753_struct {
          char  isc_754 [256];	/* RDB$FILE_NAME */
          ISC_LONG isc_755;	/* RDB$FILE_START */
   } isc_753;
/**************************************
 *
 *	a d d _ f i l e s
 *
 **************************************
 *
 * Functional description
 *	This should be a multi-file database.
 *	Store files and starting
 *	addresses & commit this much.
 *
 **************************************/
	isc_req_handle  req_handle1 = 0;

	// store the RDB$FILES records

	SLONG start = 201; // Magic number, can be taken from some constant?
	SLONG count = 0;

	for (burp_fil* file = tdgbl->gbl_sw_files; file; file = file->fil_next)
	{
		if (file->fil_name != file_name)
		{
			count++;
			/*STORE (REQUEST_HANDLE req_handle1)
				X IN RDB$FILES*/
			{
			
                        if (!req_handle1)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_752), (char*) isc_752);
			if (req_handle1)
			   {
				strcpy (/*X.RDB$FILE_NAME*/
					isc_753.isc_754, file->fil_name.c_str());
				/*X.RDB$FILE_START*/
				isc_753.isc_755 = start;
			/*END_STORE;*/
			   
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 260, &isc_753, (short) 0);
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
				MISC_release_request_silent(req_handle1);
			BURP_verbose (57, SafeArg() << file->fil_name.c_str() << start);
			// msg 57 adding file %s, starting at page %ld
		}
		else if (((SLONG) file->fil_length) >= start - 1)
			file->fil_length -= start - 1;
		else
		{
			BURP_print (false, 96, SafeArg() << file->fil_length << (start - 1));
			// msg 96  length given for initial file (%ld) is less than minimum (%ld)
			file->fil_length = 0;
		}

		start += file->fil_length;
	}

	if (count)
	{
		BURP_verbose (70);
		// msg 70 committing secondary files
		/*COMMIT*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
		// existing ON_ERROR continues past error, beck
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			BURP_print (false, 174);
			// msg 174 cannot commit files
			BURP_print_status (false, tdgbl->status_vector);
			/*ROLLBACK;*/
			{
			isc_rollback_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
		/*END_ERROR;*/
		   }
		}

		/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_7);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_8);
			SQLCODE = isc_sqlcode(isc_status);
			}
	}
}

void bad_attribute(scan_attr_t scan_next_attr, att_type bad_attr, USHORT type)
{
/**************************************
 *
 *	b a d _ a t t r i b u t e
 *
 **************************************
 *
 * Functional description
 *	We ran into an unsupported attribute.
 *	but it isn't the end of the world.
 *	We will try to skip some bad data and
 *	look for next valid attribute to continue the process.
 *
 **************************************/
	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	SLONG skip_count = 0;

	if (!tdgbl->gbl_sw_skip_count)
	{
		static const SafeArg dummy;
		TEXT t_name[128];
		fb_msg_format(NULL, burp_msg_fac, type, sizeof(t_name), t_name, dummy);
		BURP_print (false, 80, SafeArg() << t_name << int(bad_attr));
		// msg 80  don't recognize %s attribute %ld -- continuing
		int skip_l = get(tdgbl);
		if (skip_l)
			get_skip(tdgbl, skip_l);
	}
	else
	{
		if (scan_next_attr == NO_SKIP)
		{
			skip_count = tdgbl->gbl_sw_skip_count;
			get_skip(tdgbl, skip_count);
			BURP_print (false, 203, SafeArg() << skip_count << int(bad_attr));
			// msg 203: skipped %d bytes after reading a bad attribute %d
		}
		else
		{
			++skip_count;
			BURP_print (false, 205, SafeArg() << skip_count << int(bad_attr));
			// msg 205: skipped %d bytes looking for next valid attribute, encountered attribute %d
		}
		scan_next_attr = AFTER_SKIP;
	}
}

void check_db_version(BurpGlobals* tdgbl)
{
   struct isc_745_struct {
          short isc_746;	/* isc_utility */
   } isc_745;
   struct isc_742_struct {
          char  isc_743 [32];	/* RDB$FIELD_NAME */
          char  isc_744 [32];	/* RDB$RELATION_NAME */
   } isc_742;
   struct isc_750_struct {
          short isc_751;	/* isc_utility */
   } isc_750;
   struct isc_748_struct {
          char  isc_749 [32];	/* RDB$RELATION_NAME */
   } isc_748;
/**************************************
 *
 *	c h e c k _ d b _ v e r s i o n
 *
 **************************************
 *
 * Functional description
 *	Find the ODS version number of the database.
 *
 **************************************/
	struct rel_field_t
	{
		const char* rel;
		const char* fld;
		int ods_version;
	};

	tdgbl->RESTORE_ods = DB_VERSION_DDL4;

	const rel_field_t relations[] =
	{
		{"RDB$TRIGGERS",	0,	DB_VERSION_DDL5}, // IB3.3
		{"RDB$PROCEDURES",	0,	DB_VERSION_DDL8}, // IB4
		{"RDB$ROLES",		0,	DB_VERSION_DDL9}, // IB5
		{0, 0, 0}
	};

	isc_req_handle req_handle = 0;
	for (const rel_field_t* rel = relations; rel->rel; ++rel)
	{
		/*FOR (REQUEST_HANDLE req_handle)
			FIRST 1 X IN RDB$RELATIONS
			WITH X.RDB$RELATION_NAME = rel->rel*/
		{
                if (!req_handle)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle, (short) sizeof(isc_747), (char*) isc_747);
		isc_vtov ((const char*) rel->rel, (char*) isc_748.isc_749, 32);
		if (req_handle)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_748, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle, (short) 1, (short) 2, &isc_750, (short) 0);
		   if (!isc_750.isc_751 || isc_status [1]) break;
			tdgbl->RESTORE_ods = rel->ods_version;
		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	MISC_release_request_silent(req_handle);

	if (tdgbl->RESTORE_ods < DB_VERSION_DDL8)
		return;

	const rel_field_t rel_fields[] =
	{
		{"RDB$FIELDS",					"RDB$FIELD_PRECISION",	DB_VERSION_DDL10},		// FB1, FB1.5
		{"RDB$ROLES",					"RDB$DESCRIPTION",		DB_VERSION_DDL11},		// FB2
		{"RDB$RELATIONS",				"RDB$RELATION_TYPE",	DB_VERSION_DDL11_1},	// FB2.1
		{"RDB$PROCEDURE_PARAMETERS",	"RDB$FIELD_NAME",		DB_VERSION_DDL11_2},	// FB2.5
		{0, 0, 0}
	};

	isc_req_handle req_handle2 = 0;
	for (const rel_field_t* rf = rel_fields; rf->rel; ++rf)
	{
		/*FOR (REQUEST_HANDLE req_handle2)
			FIRST 1 X2 IN RDB$RELATION_FIELDS
			WITH X2.RDB$RELATION_NAME = rf->rel
			AND X2.RDB$FIELD_NAME = rf->fld*/
		{
                if (!req_handle2)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle2, (short) sizeof(isc_741), (char*) isc_741);
		isc_vtov ((const char*) rf->fld, (char*) isc_742.isc_743, 32);
		isc_vtov ((const char*) rf->rel, (char*) isc_742.isc_744, 32);
		if (req_handle2)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle2, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 64, &isc_742, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 1, (short) 2, &isc_745, (short) 0);
		   if (!isc_745.isc_746 || isc_status [1]) break;
			tdgbl->RESTORE_ods = rf->ods_version;
		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	MISC_release_request_silent(req_handle2);
}

void create_database(BurpGlobals* tdgbl, const TEXT* file_name)
{
/**************************************
 *
 *	c r e a t e _ d a t a b a s e
 *
 **************************************
 *
 * Functional description
 *	create the new database, looking
 *	to see if there are any interesting
 *	things to do.
 *
 **************************************/

	// Get (physical) database record

	ULONG page_size = DEFAULT_PAGE_SIZE;
	// sweep_interval = -1;
	// sweep_interval = 0xFFFFFFFF;
	ULONG sweep_interval = MAX_ULONG;
	bool no_reserve = false;
	bool db_read_only = false, SQL_dialect_flag = false;
	bool forced_writes = true; // turned on by default
	ULONG page_buffers = 0;
	USHORT SQL_dialect = 0;

	att_type attribute;
	rec_type record;
	if (get_record(&record, tdgbl) == rec_physical_db)
	{
		while (get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_SQL_dialect:
				SQL_dialect_flag = true;
				SQL_dialect = (USHORT) get_numeric(tdgbl);
				break;

			case att_page_size:
				page_size = get_numeric(tdgbl);
				break;

			case att_sweep_interval:
				sweep_interval = get_numeric(tdgbl);
				break;

			case att_forced_writes:
				forced_writes = get_numeric(tdgbl) != FALSE;
				break;

			case att_no_reserve:
				no_reserve = get_numeric(tdgbl) != FALSE;
				break;

			case att_db_read_only:
				db_read_only = get_numeric(tdgbl) != FALSE;
				break;

			case att_page_buffers:
				page_buffers = get_numeric(tdgbl);
				break;

			default:
				{
					const SSHORT l = get(tdgbl);
					if (l) {
						get_skip(tdgbl, l);
					}
					break;
				}
			}
		}
		get_record(&record, tdgbl);
	}

	if (record != rec_database)
		BURP_error_redirect (NULL, 32);
		// msg 32 Expected database description record

	if (tdgbl->gbl_sw_page_size)
	{
		if (tdgbl->gbl_sw_page_size < page_size)
		{
			BURP_print (false, 110, SafeArg() << page_size << tdgbl->gbl_sw_page_size);
			// msg 110 Reducing the database page size from %ld bytes to %ld bytes
		}
		page_size = tdgbl->gbl_sw_page_size;
	}

	tdgbl->hdr_forced_writes = forced_writes;

	if (tdgbl->gbl_sw_no_reserve)
		no_reserve = tdgbl->gbl_sw_no_reserve;

	// Override attribute setting with user requirement
	if (tdgbl->gbl_sw_mode)
		db_read_only = tdgbl->gbl_sw_mode_val;
	else
	{
		// No access mode specified by user. Use attribute settings. Since the
		// database is set to readOnly only after making it Online in
		// RESTORE_restore(), pass on this information through Global structures
		tdgbl->gbl_sw_mode = true;
		tdgbl->gbl_sw_mode_val = db_read_only;
	}

	if (tdgbl->gbl_sw_page_buffers)
		page_buffers = tdgbl->gbl_sw_page_buffers;

	Firebird::ClumpletWriter dpb(Firebird::ClumpletReader::Tagged, MAX_DPB_SIZE, isc_dpb_version1);
	tdgbl->uSvc->getAddressPath(dpb);
	dpb.insertInt(isc_dpb_page_size, page_size & 0xff00);
	dpb.insertString(isc_dpb_gbak_attach, GDS_VERSION, strlen(GDS_VERSION));

	if (sweep_interval != MAX_ULONG)
	{
		dpb.insertInt(isc_dpb_sweep_interval, sweep_interval);
	}

	// If the database is to be restored "read_only", fillup the data pages
	if (no_reserve || db_read_only)
	{
		dpb.insertByte(isc_dpb_no_reserve, 1);
	}
	if (tdgbl->gbl_sw_user)
	{
		dpb.insertString(isc_dpb_user_name, tdgbl->gbl_sw_user, strlen(tdgbl->gbl_sw_user));
	}
	if (tdgbl->gbl_sw_password)
	{
		dpb.insertString(tdgbl->uSvc->isService() ? isc_dpb_password_enc : isc_dpb_password,
							 tdgbl->gbl_sw_password, strlen(tdgbl->gbl_sw_password));
	}
	if (tdgbl->gbl_sw_tr_user)
	{
		dpb.insertString(isc_dpb_trusted_auth, tdgbl->gbl_sw_tr_user, strlen(tdgbl->gbl_sw_tr_user));
	}
	if (page_buffers)
	{
		dpb.insertInt(isc_dpb_set_page_buffers, page_buffers);
	}

	// Turn off sync writes during restore
	dpb.insertByte(isc_dpb_force_write, 0);

	// which SQL dialect that this database speaks
	// When we restore backup files that came from prior
	// to V6, we force the SQL database dialect to 1

	dpb.insertByte(isc_dpb_sql_dialect, SQL_dialect_flag ? SQL_dialect : SQL_DIALECT_V5);

	// start database up shut down,
	// use single-user mode to avoid conflicts during restore process
	dpb.insertByte(isc_dpb_shutdown, isc_dpb_shut_attachment | isc_dpb_shut_single);
	dpb.insertInt(isc_dpb_shutdown_delay, 0);
	dpb.insertInt(isc_dpb_overwrite, tdgbl->gbl_sw_overwrite);

	dpb.insertByte(isc_dpb_no_db_triggers, 1);

	ISC_STATUS_ARRAY status_vector;

	if (tdgbl->gbl_sw_fix_fss_metadata)
	{
		dpb.insertString(isc_dpb_lc_ctype, tdgbl->gbl_sw_fix_fss_metadata,
			strlen(tdgbl->gbl_sw_fix_fss_metadata));
	}

	if (isc_create_database(status_vector, 0, file_name, &DB,
							dpb.getBufferLength(), reinterpret_cast<const SCHAR*>(dpb.getBuffer()),
							0))
	{
		BURP_error_redirect (status_vector, 33, SafeArg() << file_name);
		// msg 33 failed to create database %s
	}

	if (tdgbl->gbl_sw_version && !tdgbl->uSvc->isService())
	{
		BURP_print(true, 139, file_name);
		// msg 139 Version(s) for database "%s"
		isc_version(&DB, BURP_output_version, (void*)"\t%s\n");
	}

	BURP_verbose (74, SafeArg() << file_name << page_size);
	// msg 74 created database %s, page_size %ld bytes
}

void decompress(BurpGlobals*	tdgbl,
				UCHAR*			buffer,
				USHORT			length)
{
/**************************************
 *
 *	d e c o m p r e s s
 *
 **************************************
 *
 * Functional description
 *	Get a number of compressed bytes.
 *
 **************************************/
	UCHAR* p = buffer;
	const UCHAR* const end = p + length;

	while (p < end)
	{
		// This change was made to restore National Semi-Conductor's corrupted
		// gbak file and it is in the code base now.  -Andrew

		// so count really only to 255
		SSHORT count = (SCHAR) get(tdgbl);
		if (count > 0)
		{
			if (end - p < count)
			{
				BURP_print (false, 202, SafeArg() << count << (end - p));
				// msg 202: adjusting a decompression length error: invalid length  %d was adjusted to %d
				count = end - p;
			}
			p = get_block(tdgbl, p, count);
		}
		else if (count < 0)
		{
			if (end + count < p)
			{
				BURP_print(false, 202, SafeArg() << count << (p - end));
				// msg 202: adjusting a decompression length error: invalid length %d was adjusted to %d
				count = p - end;
			}
			const UCHAR c = get(tdgbl);
			memset (p, c, -count);
			p += -count;
		}
	}

	if (p > end) {
		BURP_error_redirect (NULL, 34);
		// msg 34 RESTORE: decompression length error
	}
}

void eat_blob(BurpGlobals* tdgbl)
{
/**************************************
 *
 *	e a t _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Discard a blob from backup file
 *
 **************************************/

	const SLONG length = get_numeric(tdgbl);

	get_skip(tdgbl, length);
}

// *****************************
// e a t _ t e x t
// *****************************
// Discard a text field from the backup file.
void eat_text(BurpGlobals* tdgbl)
{
	const ULONG l = get(tdgbl);
	if (l)
		MVOL_skip_block(tdgbl, l);
}

// *****************************
// e a t _ t e x t 2
// *****************************
// Discard a text field from the backup file, using USHORT length indicator.
void eat_text2(BurpGlobals* tdgbl)
{
	UCHAR lenstr[sizeof(USHORT)] = "";
	get_block(tdgbl, lenstr, sizeof(lenstr));
	USHORT len = (USHORT) gds__vax_integer(lenstr, sizeof(lenstr));
	if (len)
		MVOL_skip_block(tdgbl, len);
}

burp_rel* find_relation(BurpGlobals* tdgbl, const TEXT* name)
{
/**************************************
 *
 *	f i n d _ r e l a t i o n
 *
 **************************************
 *
 * Functional description
 *	Given a relation name, find the relation block.  If there isn't
 *	one, produce a fatal error.
 *
 **************************************/

	// Why isn't strcmp used here?
	for (burp_rel* relation = tdgbl->relations; relation; relation = relation->rel_next)
	{
		for (const TEXT* p = relation->rel_name, *q = name; *p == *q; p++, q++) {
			if (!*p)
				return relation;
		}
	}

	BURP_error_redirect (NULL, 35, SafeArg() << name);
	// msg 35 can't find relation %s

	return NULL;
}

void fix_security_class_name(BurpGlobals* tdgbl, TEXT* sec_class, bool is_field)
{
/**************************************
 *
 *	f i x _ s e c u r i t y _ c l a s s _ n a m e
 *
 **************************************
 *
 * Functional description
 *	Reassign a proper (unique) name for auto-generated
 *  security classes.
 *
 **************************************/

	const char* const prefix = is_field ? SQL_FLD_SECCLASS_PREFIX : SQL_SECCLASS_PREFIX;
	const int prefix_length = is_field ? SQL_FLD_SECCLASS_PREFIX_LEN : SQL_SECCLASS_PREFIX_LEN;

	if (strncmp(sec_class, prefix, prefix_length))
		return;

	if (tdgbl->RESTORE_ods < DB_VERSION_DDL11_2)
		return;

	ISC_STATUS_ARRAY status_vector;

	isc_req_handle& handle = tdgbl->handles_fix_security_class_name_req_handle1;

	if (!handle)
	{
		UCHAR blr_buffer[BUFFER_TINY];
		UCHAR* blr = blr_buffer;

		add_byte(blr, blr_version5);
		add_byte(blr, blr_begin);

		add_byte(blr, blr_message);
		add_byte(blr, 0);
		add_word(blr, 1);

		add_byte(blr, blr_int64);
		add_byte(blr, 0);

		add_byte(blr, blr_send);
		add_byte(blr, 0);

		add_byte(blr, blr_begin);
		add_byte(blr, blr_assignment);

		add_byte(blr, blr_gen_id);
		add_string(blr, SQL_SECCLASS_GENERATOR);

		add_byte(blr, blr_literal);
		add_byte(blr, blr_int64);
		add_byte(blr, 0);
		add_int64(blr, 1);

		add_byte(blr, blr_parameter);
		add_byte(blr, 0);
		add_word(blr, 0);

		add_byte(blr, blr_end);
		add_byte(blr, blr_end);
		add_byte(blr, blr_eoc);

		const USHORT blr_length = blr - blr_buffer;
		fb_assert(blr_length <= sizeof(blr_buffer));

		if (isc_compile_request(status_vector, &DB, &handle,
							    blr_length, (const SCHAR*) blr_buffer))
		{
			BURP_error_redirect(status_vector, 316);
			// msg 316 Failed while fixing the security class name
		}
	}

	if (isc_start_request(status_vector, &handle, &gds_trans, 0))
	{
		BURP_error_redirect(status_vector, 316);
		// msg 316 Failed while fixing the security class name
	}

	SINT64 id = 0;

	if (isc_receive(status_vector, &handle, 0, sizeof(SINT64), &id, 0))
	{
		BURP_error_redirect(status_vector, 316);
		// msg 316 Failed while fixing the security class name
	}

	fb_assert(id);

	snprintf(sec_class, MAX_SQL_IDENTIFIER_SIZE, "%s%" SQUADFORMAT, prefix, id);
}

void general_on_error()
{
/**************************************
 *
 *	g e n e r a l _ o n _ e r r o r
 *
 **************************************
 *
 * Functional description
 *	Handle any general ON_ERROR clause during restore.
 *
 **************************************/
	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	if (isc_status[1] == isc_malformed_string)
	{
		Firebird::Arg::StatusVector oldVector(isc_status);
		Firebird::Arg::Gds newVector(isc_gbak_invalid_metadata);
		newVector.append(oldVector);
		newVector.copyTo(isc_status);
	}
	BURP_print_status (true, isc_status);

	BURP_abort ();
}

bool get_acl(BurpGlobals*	tdgbl,
			 const TEXT*	owner_nm,
			 ISC_QUAD*		blob_id,
			 ISC_QUAD*		new_blob_id)
{
/**************************************
 *
 *	g e t _ a c l
 *
 **************************************
 *
 * Functional description
 *
 *	open the blob that contains the ACL list
 *	get the ACL list of a relation
 *	replace the owner of the relation in the ACL list with
 *	  the creator of the relation
 *	create a new blob
 *	store the new ACL list in the new blob
 *
 **************************************/

	static const UCHAR blr_items[] =
	{
		isc_info_blob_max_segment,
		isc_info_blob_total_length,
		isc_info_blob_num_segments
	};

	// If the blob is null, don't store it.  It will be restored as null.

	if (!blob_id->gds_quad_high && !blob_id->gds_quad_low)
		return false;

	// Open the blob and get it's vital statistics

	ISC_STATUS_ARRAY status_vector;
	UserBlob blob(status_vector);

	if (! blob.open(DB, gds_trans, *blob_id))
	{
		// msg 24 isc_open_blob failed
		BURP_error_redirect (status_vector, 24);
	}

	UCHAR blob_info[32];
	if (!blob.getInfo(sizeof(blr_items), blr_items, sizeof(blob_info), blob_info))
	{
		// msg 20 isc_blob_info failed
		BURP_error_redirect (status_vector, 20);
	}

	ULONG length = 0;
	UCHAR item;
	USHORT max_segment;
	ULONG num_segments;
	const UCHAR* p = blob_info;

	while ((item = *p++) != isc_info_end)
	{
		const USHORT l = (USHORT) gds__vax_integer (p, 2);
		p += 2;
		const SLONG n = gds__vax_integer (p, l);
		p += l;
		switch (item)
		{
		case isc_info_blob_max_segment:
			max_segment = (USHORT) n;
			break;

		case isc_info_blob_total_length:
			length = n;
			break;

		case isc_info_blob_num_segments:
			num_segments = n;

			// we assume that the ACL list was written out as
			// in one big segment

			if (num_segments > 1) {
				// CVC: I can't see the effect of assert(true)
				fb_assert (num_segments > 1);
			}
			break;

		default:
			// msg 79 don't understand blob info item %ld
			BURP_print (false, 79, SafeArg() << int(item));
			// CVC: do you return, without closing the blob, dear function???
			if (!blob.close())
			{
				BURP_error_redirect (status_vector, 23);
				// msg 23 isc_close_blob failed
			}
			return false;
		}
	}

	if (!length)
	{
		if (!blob.close())
		{
			BURP_error_redirect (status_vector, 23);
			// msg 23 isc_close_blob failed
		}
		return false;
	}

	// Rdb sometimes gets the length messed up

	if (length < max_segment)
		length = max_segment;

	fb_assert(length <= ULONG(MAX_SLONG));

	// Allocate a buffer large enough for the largest segment and start grinding.

	BlobBuffer static_buffer;
	UCHAR* buffer = static_buffer.getBuffer(length);

	size_t return_length = 0;
	if (!blob.getData(length, buffer, return_length))
	{
		// msg 22 gds_$get_segment failed
		BURP_error_redirect (status_vector, 22);
	}
	// protect ourselves
	length = return_length;

	if (!blob.close())
	{
		// msg 23 isc_close_blob failed
		BURP_error_redirect (status_vector, 23);
	}

	const UCHAR* from = buffer + 3; // skip ACL_version, ACL_id_list, and id_person
	const SLONG id_person_len = (SLONG) *from;

	const UCHAR* c_1 = (UCHAR*) owner_nm;
	const size_t owner_nm_len = strlen(owner_nm);
	fb_assert(owner_nm_len <= size_t(MAX_UCHAR));

	// If some day, ACLs become bigger than MAX_SLONG, we should review this code.
	const SLONG bufSize = SLONG(length) - id_person_len + SLONG(owner_nm_len);
	fb_assert(bufSize > 0);
	BlobBuffer new_static_buffer;
	UCHAR* const new_buffer = new_static_buffer.getBuffer(bufSize);

	from = buffer;
	UCHAR* to = new_buffer;
	*to++ = *from++; // copy ACL_verion
	*to++ = *from++; // copy ACL_id_list
	*to++ = *from++; // copy id_person
	*to++ = UCHAR(owner_nm_len);

	size_t new_len = 4; //new_len + 4; Previously, new_len was set to zero at the top
	// from = buffer + id_person_len + 4; redundant, see 2nd loop below.
	for (ULONG cnt = 0; cnt < owner_nm_len; cnt++)
	{
		*to++ = *c_1++;
		new_len++;
	}

	const UCHAR* const end_buffer = buffer + length;
	for (from = buffer + id_person_len + 4; from < end_buffer; from++)
	{
		*to++ = *from;
		new_len++;
	}

	if (!blob.create(DB, gds_trans, *new_blob_id))
	{
		// msg 37 isc_create_blob failed
		BURP_error_redirect (status_vector, 37);
	}

	if (!blob.putData(new_len, new_buffer))
	{
		// msg 38 isc_put_segment failed
		BURP_error_redirect (status_vector, 38);
	}

	if (!blob.close())
	{
		// msg 23 isc_close_blob failed
		BURP_error_redirect (status_vector, 23);
	}

	return true;
}

void get_array(BurpGlobals* tdgbl, burp_rel* relation, UCHAR* record_buffer)
{
/**************************************
 *
 *	g e t _ a r r a y
 *
 **************************************
 *
 * Functional description
 *	Read array data from input file to nice,
 *	shiney, new array.
 *
 **************************************/
	burp_fld*		field = NULL;
	ISC_STATUS_ARRAY	status_vector;
	USHORT		count, field_number, field_length = 0;
	UCHAR*		buffer = NULL;
	UCHAR*		p = NULL;
	UCHAR		blr_buffer[200]; // enough for a sdl with 16 dimensions
	lstring		xdr_slice;

	// don't free something you don't allocate
	lstring xdr_buffer;
	xdr_buffer.lstr_allocated = 0;
	xdr_buffer.lstr_address = NULL;

	// Pick up attributes
	SLONG		fld_ranges[2 * MAX_DIMENSION];
	SLONG       slice_length = 0;
	SLONG       *range;
	const SLONG* end_ranges;
	scan_attr_t scan_next_attr;
	skip_init(&scan_next_attr);
	att_type	attribute;
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_blob_data)
	{
		switch (attribute)
		{
		case att_blob_field_number:
			field_number = (USHORT) get_numeric(tdgbl);
			for (field = relation->rel_fields; field; field = field->fld_next) {
				if (field->fld_number == field_number)
					break;
			}
			if (!field) {
				BURP_error_redirect (NULL, 36);
				// msg 36 Can't find field for blob
			}

			field_length = field->fld_length;
			if (field->fld_type == blr_varying)
				field_length += sizeof(USHORT);
			slice_length = field_length;
			//
			// Copy the ranges onto a buffer and let the program
			// mess with the copy rather than the original
			//
			memcpy(fld_ranges, field->fld_ranges, sizeof(fld_ranges));
			break;

		case att_array_dimensions:
			field->fld_dimensions = (SSHORT) get_numeric(tdgbl);
			end_ranges = fld_ranges + 2 * field->fld_dimensions;
			for (range = fld_ranges; range < end_ranges; range += 2)
			{
				if (get_attribute(&attribute, tdgbl) != att_array_range_low)
					bad_attribute (scan_next_attr, attribute, 58);
					// msg 58 array
				else
					range[0] = get_numeric(tdgbl);
				if (get_attribute(&attribute, tdgbl) != att_array_range_high)
					bad_attribute (scan_next_attr, attribute, 58);
					// msg 58 array
				else
					range[1] = get_numeric(tdgbl);
				slice_length *= (range[1] - range[0] + 1);
			}
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 58);
			// msg 58 array
			break;
		}
	}

	SLONG return_length = get(tdgbl);
	return_length |= get(tdgbl) << 8;
	return_length |= get(tdgbl) << 16;
	return_length |= get(tdgbl) << 24;

	ISC_QUAD* blob_id = (ISC_QUAD*) ((UCHAR*) record_buffer + field->fld_offset);

	SLONG last_element_dim[MAX_DIMENSION];
	if (return_length != slice_length)
	{
		int upper, lower;
		//
		// Ugh!  The full array wasn't returned and versions of gbak prior to
		// V3.2I don't explicitly signal this.  We must recompute the top
		// element to restore.
		//
		// Double Ugh!  gbak (Versions prior to 5.0) while backing up calculates
		// the top dimensions incorrectly So whatever was written as top dimensions
		// is useless. 5.0 gbak has written correct dimensions, but what the heck
		// we'll calculate it again
		//

		int elements_remaining = return_length / field_length;
		//
		// Backup (versions prior to 5.0) has surely written wrong dimensions.
		// Ignore whatever is read in fld_ranges and calculate the dimensions
		// of the last element. field->fld_ranges has the max dimensions.
		// last_element_dim holds only the upper bounds of each dimension.
		//
		for (int i1 = 0, i3 = 0; i1 < field->fld_dimensions; i1++)
		{
			int divisor = 1;
			for (int i2 = (2 * (i1 + 1) + 1); i2 <= field->fld_dimensions * 2; i2 += 2)
				divisor *= (field->fld_ranges[i2] - field->fld_ranges[i2 - 1] + 1);
			last_element_dim[i1] = (elements_remaining - 1) / divisor + field->fld_ranges[i3];
			elements_remaining  -= (last_element_dim[i1] - field->fld_ranges[i3]) * divisor;
			i3 += 2;
		}

		int current_dim;
#ifdef DEBUG
		fprintf(stderr, "\nLast element upper bounds read from backup file:\n");
		for (current_dim = 1; current_dim < field->fld_dimensions * 2; current_dim += 2)
			fprintf(stderr, "%ld ", fld_ranges[current_dim]);
		fprintf(stderr, "\nCalculated Last element upper bounds :\n");
		for (current_dim = 0; current_dim < field->fld_dimensions; current_dim++)
			fprintf(stderr, "%ld ", last_element_dim[current_dim]);
		fprintf(stderr, "return_length = %ld\n", return_length);
		fprintf(stderr, "elements_returned = %ld\n", return_length / field_length);
		fprintf(stderr, "Max dims[");
		for (current_dim = 1; current_dim < field->fld_dimensions * 2; current_dim += 2)
			fprintf(stderr, "%ld ", field->fld_ranges[current_dim]);
		fprintf(stderr, "]");
#endif
		int data_at = 0;
		//
		// We have an irregurlar shaped slice to write. The following for loop
		// chops the array into writable rectangular/square slice and sends it
		// to the engine. When the loop cycles through all dimensions, we would
		// have written the whole of the irregular slice.
		//
		for (current_dim = 0; current_dim < field->fld_dimensions; current_dim++)
		{
			UCHAR* blr = blr_buffer;
			bool dont_write = false;

			// build the sdl

			add_byte(blr, isc_sdl_version1);

			add_byte(blr, isc_sdl_struct);
			add_byte(blr, 1);

			switch (field->fld_type)
			{
			case blr_text:
			case blr_varying:
				if (field->fld_type == blr_text)
					add_byte(blr, blr_text2);
				else
					add_byte(blr, blr_varying2);
				add_word(blr, field->fld_character_set_id);
				add_word(blr, field->fld_length);
				break;
			case blr_short:
			case blr_long:
			case blr_quad:
			case blr_int64:
				add_byte(blr, field->fld_type);
				add_byte(blr, field->fld_scale);
				break;
			default:
				add_byte(blr, field->fld_type);
			}

			add_byte(blr, isc_sdl_relation);
			add_string(blr, relation->rel_name);
			add_byte(blr, isc_sdl_field);
			add_string(blr, field->fld_name);

			// each element spec starts here

#ifdef DEBUG
			fprintf(stderr, "\nBounds written[");
#endif
			int elements_written = 1;
			end_ranges = field->fld_ranges + 2 * field->fld_dimensions;
			//
			// Here is the important work. Calculate the the bounds to be written
			// so that the resulting slice is a rectangular/square slice.
			// For a 2 dimensional array of size 1..N, 1..M, which is partially
			// filled, we have already calculated the dims of last element. Say
			// if this was x,y (x is row, y is column) then we do
			//    isc_put_slice(1..x-1, 1..M);
			//    isc_put_slice(x..x, 1..y);
			// similarly for a 3D array [N,M,K] whose last element dims are (x,y,z)
			//    isc_put_slice(1..x-1, 1..M, 1..K);
			//    isc_put_slice(x..x, 1..y-1, 1..K);
			//    isc_put_slice(x..x, y..y, 1..z);
			// This is applicable for any number of dimensions.
			// Special cases:
			// for example in case of a 2D array (10,10) and if the last element
			// dims were (1,2), we would just do a isc_put_slice(1..1, 1..2).
			// This is applied for any number of dimensions.
			//
			for (range = field->fld_ranges, count = 0; range < end_ranges; range += 2, count++)
			{
				add_byte(blr, isc_sdl_do2);
				add_byte(blr, count);
				//
				// Normally we loop through all dimensions chopping off slices
				// and writing them. This works fine but this also means that
				// we blindly put slices without actually figuring out if we
				// really need to do so. For eg: if we have a 2D array of
				// size [10,4] and the last element dims are [6,4] then all
				// we need to do is is to put one slice as
				//   isc_put_slice(1..6,1..4)
				// rather than looping through the dimensions and putting
				//   isc_put_slice(1..5,1..4)
				//   isc_put_slice(6..6,1..4)
				// we could extend this logic to any no of dims. The following
				// if condition figures out such cases. This combined with
				// the Special case should optimize the no of isc_put_slice
				// we perform.
				//
				if (current_dim + 1 == field->fld_dimensions - 1 &&
					field->fld_dimensions - count == 2 && last_element_dim[count + 1]  == range[3])
				{
					add_byte(blr, isc_sdl_long_integer);
					add_long(blr, range[0]);
					lower = range[0];
					add_byte(blr, isc_sdl_long_integer);
					add_long(blr, last_element_dim[count]);
					upper = last_element_dim[count];
					elements_written *= (upper - lower + 1);
					range += 2;
					count++;
					add_byte(blr, isc_sdl_do2);
					add_byte(blr, count);
					add_byte(blr, isc_sdl_long_integer);
					add_long(blr, range[0]);
					lower = range[0];
					add_byte(blr, isc_sdl_long_integer);
					add_long(blr, last_element_dim[count]);
					upper = last_element_dim[count];
					elements_written *= (upper - lower + 1);
					++current_dim;
					break;
				}
				if (current_dim == count)
				{
					add_byte(blr, isc_sdl_long_integer);
					add_long(blr, range[0]);
					lower = range[0];
					add_byte(blr, isc_sdl_long_integer);
					upper = (current_dim == field->fld_dimensions - 1) ?
						last_element_dim[count] : (last_element_dim[count] - 1);
					if (upper < range[0])
					{
						// see Special Case above

						dont_write = true;
						break;
					}
					add_long(blr, upper);
				}
				else if (current_dim < count)
				{
					add_byte(blr, isc_sdl_long_integer);
					add_long(blr, range[0]);
					add_byte(blr, isc_sdl_long_integer);
					add_long(blr, range[1]);
					upper = range[1];
					lower = range[0];
				}
				else if (current_dim > count)
				{
					add_byte(blr, isc_sdl_long_integer);
					add_long(blr, last_element_dim[count]);
					add_byte(blr, isc_sdl_long_integer);
					add_long(blr, last_element_dim[count]);
					upper = lower = last_element_dim[count];
				}
				elements_written *= (upper - lower + 1);
#ifdef DEBUG
				fprintf(stderr, "%d..%d ", lower, upper);
#endif
			}
			if (dont_write)
				continue;
#ifdef DEBUG
			fprintf(stderr, "]");
			fprintf(stderr, "\n Elements Written=%d  ", elements_written);
#endif

			add_byte(blr, isc_sdl_element);
			add_byte(blr, 1);
			add_byte(blr, isc_sdl_scalar);
			add_byte(blr, 0);
			add_byte(blr, field->fld_dimensions);

			for (count = 0; count < field->fld_dimensions; count++)
			{
				add_byte(blr, isc_sdl_variable);
				add_byte(blr, count);
			}

			add_byte(blr, isc_sdl_eoc);

#ifdef DEBUG
			if (debug_on)
				PRETTY_print_sdl (blr_buffer, NULL, NULL, 0);
#endif

			const USHORT blr_length = blr - blr_buffer;

			if (data_at == 0)
			{
				buffer = BURP_alloc (return_length);
				SLONG lcount;
				if (tdgbl->gbl_sw_transportable)
				{
					if (get_attribute(&attribute, tdgbl) != att_xdr_array)
						// msg 55 Expected XDR record length
						BURP_error_redirect (NULL, 55);
					else
					{
						lcount = get(tdgbl);
						lcount |= get(tdgbl) << 8;
						lcount |= get(tdgbl) << 16;
						lcount |= get(tdgbl) << 24;
						xdr_buffer.lstr_length = xdr_buffer.lstr_allocated = lcount;
						xdr_buffer.lstr_address = BURP_alloc(lcount);
						xdr_slice.lstr_allocated = xdr_slice.lstr_length = return_length;
						xdr_slice.lstr_address = buffer;
						p = xdr_buffer.lstr_address;
					}
				}
				else
				{
					p = buffer;
					lcount = return_length;
				}

				if (lcount)
					get_block(tdgbl, p, lcount);

				if (tdgbl->gbl_sw_transportable)
					CAN_slice (&xdr_buffer, &xdr_slice, FALSE, /*blr_length,*/ blr_buffer);
			}

			if (isc_put_slice(status_vector, &DB, &gds_trans,
							  blob_id, blr_length, reinterpret_cast<const char*>(blr_buffer),
							  0,	// param length for subset of an array handling
							  NULL,	// param for subset of an array handling
							  elements_written * field->fld_length, buffer + data_at))
			{
				BURP_print (false, 81, field->fld_name);
				// msg 81 error accessing blob field %s -- continuing
				BURP_print_status (true, status_vector);
#ifdef DEBUG
				PRETTY_print_sdl (blr_buffer, NULL, NULL, 0);
#endif
				return;
			}
			data_at += elements_written * field->fld_length;
#ifdef DEBUG
			fprintf(stderr, "next data_at = %d\n", data_at);
#endif
		}
	}
	else
	{
		// This is the regular case we've got the entire array
		UCHAR* blr = blr_buffer;

		// build the sdl

		add_byte(blr, isc_sdl_version1);

		add_byte(blr, isc_sdl_struct);
		add_byte(blr, 1);

		switch (field->fld_type)
		{
		case blr_text:
		case blr_varying:
			if (field->fld_type == blr_text)
				add_byte(blr, blr_text2);
			else
				add_byte(blr, blr_varying2);
			add_word(blr, field->fld_character_set_id);
			add_word(blr, field->fld_length);
			break;
		case blr_short:
		case blr_long:
		case blr_quad:
		case blr_int64:
			add_byte(blr, field->fld_type);
			add_byte(blr, field->fld_scale);
			break;
		default:
			add_byte(blr, field->fld_type);
		}

		add_byte(blr, isc_sdl_relation);
		add_string(blr, relation->rel_name);
		add_byte(blr, isc_sdl_field);
		add_string(blr, field->fld_name);

		// each element spec starts here

		for (range = fld_ranges, count = 0; range < end_ranges; range += 2, count++)
		{
			add_byte(blr, isc_sdl_do2);
			add_byte(blr, count);
			add_byte(blr, isc_sdl_long_integer);
			add_long(blr, range[0]);
			add_byte(blr, isc_sdl_long_integer);
			add_long(blr, range[1]);
		}

		add_byte(blr, isc_sdl_element);
		add_byte(blr, 1);
		add_byte(blr, isc_sdl_scalar);
		add_byte(blr, 0);
		add_byte(blr, field->fld_dimensions);

		for (count = 0; count < field->fld_dimensions; count++)
		{
			add_byte(blr, isc_sdl_variable);
			add_byte(blr, count);
		}

		add_byte(blr, isc_sdl_eoc);

#ifdef DEBUG
		if (debug_on)
			PRETTY_print_sdl (blr_buffer, NULL, NULL, 0);
#endif

		const USHORT blr_length = blr - blr_buffer;

		buffer = BURP_alloc (return_length);
		SLONG lcount;
		if (tdgbl->gbl_sw_transportable)
		{
			if (get_attribute(&attribute, tdgbl) != att_xdr_array)
				BURP_error_redirect (NULL, 55);
				// msg 55 Expected XDR record length
			else
			{
				xdr_buffer.lstr_allocated = get(tdgbl);
				xdr_buffer.lstr_allocated |= get(tdgbl) << 8;
				xdr_buffer.lstr_allocated |= get(tdgbl) << 16;
				xdr_buffer.lstr_allocated |= get(tdgbl) << 24;
				lcount = xdr_buffer.lstr_length = xdr_buffer.lstr_allocated;
				xdr_buffer.lstr_address = BURP_alloc (xdr_buffer.lstr_allocated);
				xdr_slice.lstr_allocated = xdr_slice.lstr_length = return_length;
				xdr_slice.lstr_address = buffer;
				p = xdr_buffer.lstr_address;
			}
		}
		else
		{
			p = buffer;
			lcount = return_length;
		}

		if (lcount)
			get_block(tdgbl, p, lcount);

		if (tdgbl->gbl_sw_transportable)
			CAN_slice (&xdr_buffer, &xdr_slice, FALSE, /*blr_length,*/ blr_buffer);


		if (isc_put_slice(status_vector, &DB, &gds_trans,
						  blob_id, blr_length,
						  reinterpret_cast<const char*>(blr_buffer),
						  0,	  // param length for subset of an array handling
						  NULL,  // param for subset of an array handling
						  return_length, buffer))
		{
			BURP_print (false, 81, field->fld_name);
			// msg 81 error accessing blob field %s -- continuing
			BURP_print_status (false, status_vector);
#ifdef DEBUG
			PRETTY_print_sdl (blr_buffer, NULL, NULL, 0);
#endif
			return;
		}
	}

	BURP_free (buffer);
	if (tdgbl->gbl_sw_transportable && xdr_buffer.lstr_allocated)
		BURP_free (xdr_buffer.lstr_address);
}

void get_blob(BurpGlobals* tdgbl, const burp_fld* fields, UCHAR* record_buffer)
{
/**************************************
 *
 *	g e t _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Read blob attributes and copy data from input file to nice,
 *	shiny, new blob.
 *
 **************************************/

	// Pick up attributes

	ULONG segments = 0;
	USHORT field_number = MAX_USHORT;
	USHORT max_segment = 0;
	UCHAR blob_type = 0;

	att_type	attribute;
	scan_attr_t	scan_next_attr;
	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_blob_data)
	{
		switch (attribute)
		{
		case att_blob_field_number:
			field_number = (USHORT) get_numeric(tdgbl);
			break;

		case att_blob_max_segment:
			max_segment = (USHORT) get_numeric(tdgbl);
			break;

		case att_blob_number_segments:
			segments = get_numeric(tdgbl);
			break;

		case att_blob_type:
			blob_type = (UCHAR) get_numeric(tdgbl);
			break;

		default:
			bad_attribute(scan_next_attr, attribute, 64);
			// msg 64 blob
			break;
		}
	}

	// Find the field associated with the blob
	const burp_fld* field;
	for (field = fields; field; field = field->fld_next) {
		if (field->fld_number == field_number)
			break;
	}

	if (!field) {
		BURP_error_redirect (NULL, 36);
		// msg 36 Can't find field for blob
	}

	// Create new blob

	ISC_QUAD* blob_id = (ISC_QUAD*) ((UCHAR*) record_buffer + field->fld_offset);
	ISC_STATUS_ARRAY status_vector;
	UserBlob blob(status_vector);
	const UCHAR blob_desc[] = {isc_bpb_version1, isc_bpb_type, 1, blob_type};

	if (!blob.create(DB, gds_trans, *blob_id, sizeof(blob_desc), blob_desc))
	{
		BURP_error_redirect (status_vector, 37);
		// msg 37 isc_create_blob failed
	}

	// Allocate blob buffer if static buffer is too short
	BlobBuffer static_buffer;
	UCHAR* const buffer = static_buffer.getBuffer(max_segment);

	// Eat up blob segments

	for (; segments > 0; --segments )
	{
		USHORT length = get(tdgbl);
		length |= get(tdgbl) << 8;
		if (length)
		{
			get_block(tdgbl, buffer, length);
		}
		if (!blob.putSegment(length, buffer))
		{
			BURP_error_redirect (status_vector, 38);
			// msg 38 isc_put_segment failed
		}
	}

	if (!blob.close())
		BURP_error_redirect (status_vector, 23);
		// msg 23 isc_close_blob failed
}


void get_blr_blob(BurpGlobals* tdgbl, ISC_QUAD& blob_id, bool glb_trans)
{
/**************************************
 *
 *	g e t _ b l r _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Read blob attributes and copy data from input file to nice,
 *	shiney, new blob.
 *
 **************************************/

	size_t length = get_numeric(tdgbl);

	// Create new blob

	isc_tr_handle local_trans;
	if (glb_trans && tdgbl->global_trans)
		local_trans = tdgbl->global_trans;
	else
		local_trans = gds_trans;

	ISC_STATUS_ARRAY	status_vector;
	UserBlob blob(status_vector);
	if (!blob.create(DB, local_trans, blob_id))
	{
		BURP_error_redirect (status_vector, 37);
		// msg 37 isc_create_blob failed
	}

	BlobBuffer static_buffer;
	UCHAR* const buffer = static_buffer.getBuffer(length + 1);

	if (length)
	{
		UCHAR* p = get_block(tdgbl, buffer, length);
		// Make sure it has an eoc
		if (p[-1] != blr_eoc) {
			p[0] = blr_eoc;
			length++;
		}
	}

	if (!blob.putData(length, buffer))
	{
		BURP_error_redirect (status_vector, 38);
		// msg 38 isc_put_segment failed
	}

	if (!blob.close())
		BURP_error_redirect (status_vector, 23);
		// msg 23 isc_close_blob failed
}

bool get_character_set(BurpGlobals* tdgbl)
{
   struct isc_722_struct {
          char  isc_723 [32];	/* RDB$FUNCTION_NAME */
          ISC_QUAD isc_724;	/* RDB$DESCRIPTION */
          char  isc_725 [32];	/* RDB$DEFAULT_COLLATE_NAME */
          char  isc_726 [32];	/* RDB$FORM_OF_USE */
          char  isc_727 [32];	/* RDB$CHARACTER_SET_NAME */
          ISC_LONG isc_728;	/* RDB$NUMBER_OF_CHARACTERS */
          short isc_729;	/* gds__null_flag */
          short isc_730;	/* RDB$BYTES_PER_CHARACTER */
          short isc_731;	/* gds__null_flag */
          short isc_732;	/* gds__null_flag */
          short isc_733;	/* gds__null_flag */
          short isc_734;	/* RDB$SYSTEM_FLAG */
          short isc_735;	/* gds__null_flag */
          short isc_736;	/* RDB$CHARACTER_SET_ID */
          short isc_737;	/* gds__null_flag */
          short isc_738;	/* gds__null_flag */
          short isc_739;	/* gds__null_flag */
          short isc_740;	/* gds__null_flag */
   } isc_722;
/**************************************
 *
 *	g e t _ c h a r a c t e r _ s e t
 *
 **************************************
 *
 * Functional description
 *	Restore data for user defined character sets
 *
 **************************************/
	class AbortException
	{
	};

	att_type		attribute;
	scan_attr_t		scan_next_attr;

	try
	{
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_character_sets_req_handle1)
			X IN RDB$CHARACTER_SETS*/
		{
		
                if (!tdgbl->handles_get_character_sets_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_character_sets_req_handle1, (short) sizeof(isc_721), (char*) isc_721);
		if (tdgbl->handles_get_character_sets_req_handle1)
		   {
		   isc_722.isc_724 = isc_blob_null;
			/*X.RDB$CHARACTER_SET_NAME.NULL*/
			isc_722.isc_740 = TRUE;
			/*X.RDB$FORM_OF_USE.NULL*/
			isc_722.isc_739 = TRUE;
			/*X.RDB$NUMBER_OF_CHARACTERS.NULL*/
			isc_722.isc_738 = TRUE;
			/*X.RDB$DEFAULT_COLLATE_NAME.NULL*/
			isc_722.isc_737 = TRUE;
			/*X.RDB$CHARACTER_SET_ID.NULL*/
			isc_722.isc_735 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_722.isc_734 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_722.isc_733 = FALSE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_722.isc_732 = TRUE;
			/*X.RDB$FUNCTION_NAME.NULL*/
			isc_722.isc_731 = TRUE;
			/*X.RDB$BYTES_PER_CHARACTER.NULL*/
			isc_722.isc_729 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_charset_name:
					/*X.RDB$CHARACTER_SET_NAME.NULL*/
					isc_722.isc_740 = FALSE;
					GET_TEXT(/*X.RDB$CHARACTER_SET_NAME*/
						 isc_722.isc_727);
					BURP_verbose (msgVerbose_restore_charset, /*X.RDB$CHARACTER_SET_NAME*/
										  isc_722.isc_727);
					break;

				case att_charset_form:
					/*X.RDB$FORM_OF_USE.NULL*/
					isc_722.isc_739 = FALSE;
					GET_TEXT(/*X.RDB$FORM_OF_USE*/
						 isc_722.isc_726);
					break;

				case att_charset_numchar:
					/*X.RDB$NUMBER_OF_CHARACTERS.NULL*/
					isc_722.isc_738 = FALSE;
					/*X.RDB$NUMBER_OF_CHARACTERS*/
					isc_722.isc_728 = (USHORT) get_numeric(tdgbl);
					break;

				case att_charset_coll:
					/*X.RDB$DEFAULT_COLLATE_NAME.NULL*/
					isc_722.isc_737 = FALSE;
					GET_TEXT(/*X.RDB$DEFAULT_COLLATE_NAME*/
						 isc_722.isc_725);
					break;

				case att_charset_id:
					/*X.RDB$CHARACTER_SET_ID.NULL*/
					isc_722.isc_735 = FALSE;
					/*X.RDB$CHARACTER_SET_ID*/
					isc_722.isc_736 = (USHORT) get_numeric(tdgbl);
					break;

				case att_charset_sysflag:
					/*X.RDB$SYSTEM_FLAG.NULL*/
					isc_722.isc_733 = FALSE;
					/*X.RDB$SYSTEM_FLAG*/
					isc_722.isc_734 = (USHORT) get_numeric(tdgbl);
					break;

				case att_charset_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_722.isc_732 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_722.isc_724, false);
					break;

				case att_charset_funct:
					/*X.RDB$FUNCTION_NAME.NULL*/
					isc_722.isc_731 = FALSE;
					GET_TEXT(/*X.RDB$FUNCTION_NAME*/
						 isc_722.isc_723);
					break;

				case att_charset_bytes_char:
					/*X.RDB$BYTES_PER_CHARACTER.NULL*/
					isc_722.isc_729 = FALSE;
					/*X.RDB$BYTES_PER_CHARACTER*/
					isc_722.isc_730 = (USHORT) get_numeric(tdgbl);
					break;

				default:
					bad_attribute (scan_next_attr, attribute, msgErr_restore_charset);
					// 213 character set
					break;
				}
			}

			if (/*X.RDB$CHARACTER_SET_ID.NULL*/
			    isc_722.isc_735 && !/*X.RDB$DEFAULT_COLLATE_NAME.NULL*/
     isc_722.isc_737 &&
				!/*X.RDB$CHARACTER_SET_NAME.NULL*/
				 isc_722.isc_740)
			{
				tdgbl->defaultCollations.add(
					Firebird::Pair<Firebird::NonPooled<Firebird::MetaName, Firebird::MetaName> >(
						/*X.RDB$CHARACTER_SET_NAME*/
						isc_722.isc_727, /*X.RDB$DEFAULT_COLLATE_NAME*/
  isc_722.isc_725));
				throw AbortException();	// prevent the STORE
			}

		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_character_sets_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 164, &isc_722, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	catch (const AbortException&)
	{
	}

	return true;
}

bool get_chk_constraint(BurpGlobals* tdgbl)
{
   struct isc_716_struct {
          char  isc_717 [32];	/* RDB$TRIGGER_NAME */
          char  isc_718 [32];	/* RDB$CONSTRAINT_NAME */
          short isc_719;	/* gds__null_flag */
          short isc_720;	/* gds__null_flag */
   } isc_716;
/**************************************
 *
 *	g e t _ c h k _ c o n s t r a i n t
 *
 **************************************
 *
 * Functional description
 *	Restore data for check constraints.
 *
 **************************************/
	att_type		attribute;
	scan_attr_t		scan_next_attr;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_chk_constraint_req_handle1)
		X IN RDB$CHECK_CONSTRAINTS*/
	{
	
        if (!tdgbl->handles_get_chk_constraint_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_chk_constraint_req_handle1, (short) sizeof(isc_715), (char*) isc_715);
	if (tdgbl->handles_get_chk_constraint_req_handle1)
	   {
		/*X.RDB$CONSTRAINT_NAME.NULL*/
		isc_716.isc_720 = TRUE;
		/*X.RDB$TRIGGER_NAME.NULL*/
		isc_716.isc_719 = TRUE;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_chk_constraint_name:
				/*X.RDB$CONSTRAINT_NAME.NULL*/
				isc_716.isc_720 = FALSE;
				GET_TEXT(/*X.RDB$CONSTRAINT_NAME*/
					 isc_716.isc_718);
				break;

			case att_chk_trigger_name:
				/*X.RDB$TRIGGER_NAME.NULL*/
				isc_716.isc_719 = FALSE;
				GET_TEXT(/*X.RDB$TRIGGER_NAME*/
					 isc_716.isc_717);
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 286);
				// msg 286 check constraint
				break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_chk_constraint_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 68, &isc_716, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

bool get_collation(BurpGlobals* tdgbl)
{
   struct isc_676_struct {
          ISC_QUAD isc_677;	/* RDB$SPECIFIC_ATTRIBUTES */
          char  isc_678 [32];	/* RDB$BASE_COLLATION_NAME */
          char  isc_679 [32];	/* RDB$FUNCTION_NAME */
          ISC_QUAD isc_680;	/* RDB$DESCRIPTION */
          char  isc_681 [32];	/* RDB$COLLATION_NAME */
          short isc_682;	/* gds__null_flag */
          short isc_683;	/* gds__null_flag */
          short isc_684;	/* gds__null_flag */
          short isc_685;	/* gds__null_flag */
          short isc_686;	/* gds__null_flag */
          short isc_687;	/* RDB$SYSTEM_FLAG */
          short isc_688;	/* gds__null_flag */
          short isc_689;	/* RDB$COLLATION_ATTRIBUTES */
          short isc_690;	/* gds__null_flag */
          short isc_691;	/* RDB$CHARACTER_SET_ID */
          short isc_692;	/* gds__null_flag */
          short isc_693;	/* RDB$COLLATION_ID */
          short isc_694;	/* gds__null_flag */
   } isc_676;
   struct isc_696_struct {
          ISC_QUAD isc_697;	/* RDB$SPECIFIC_ATTRIBUTES */
          char  isc_698 [32];	/* RDB$BASE_COLLATION_NAME */
          char  isc_699 [32];	/* RDB$FUNCTION_NAME */
          ISC_QUAD isc_700;	/* RDB$DESCRIPTION */
          char  isc_701 [32];	/* RDB$COLLATION_NAME */
          short isc_702;	/* gds__null_flag */
          short isc_703;	/* gds__null_flag */
          short isc_704;	/* gds__null_flag */
          short isc_705;	/* gds__null_flag */
          short isc_706;	/* gds__null_flag */
          short isc_707;	/* RDB$SYSTEM_FLAG */
          short isc_708;	/* gds__null_flag */
          short isc_709;	/* RDB$COLLATION_ATTRIBUTES */
          short isc_710;	/* gds__null_flag */
          short isc_711;	/* RDB$CHARACTER_SET_ID */
          short isc_712;	/* gds__null_flag */
          short isc_713;	/* RDB$COLLATION_ID */
          short isc_714;	/* gds__null_flag */
   } isc_696;
/**************************************
 *
 *	g e t _ c o l l a t i o n
 *
 **************************************
 *
 * Functional description
 *	Restore data for user defined collations
 *
 **************************************/
	att_type		attribute;
	scan_attr_t		scan_next_attr;

	if (tdgbl->RESTORE_ods >= DB_VERSION_DDL11)
	{
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_collation_req_handle1)
			X IN RDB$COLLATIONS*/
		{
		
                if (!tdgbl->handles_get_collation_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_collation_req_handle1, (short) sizeof(isc_695), (char*) isc_695);
		if (tdgbl->handles_get_collation_req_handle1)
		   {
		   isc_696.isc_697 = isc_blob_null;
		   isc_696.isc_700 = isc_blob_null;
			/*X.RDB$COLLATION_NAME.NULL*/
			isc_696.isc_714 = TRUE;
			/*X.RDB$COLLATION_ID.NULL*/
			isc_696.isc_712 = TRUE;
			/*X.RDB$CHARACTER_SET_ID.NULL*/
			isc_696.isc_710 = TRUE;
			/*X.RDB$COLLATION_ATTRIBUTES.NULL*/
			isc_696.isc_708 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_696.isc_707 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_696.isc_706 = FALSE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_696.isc_705 = TRUE;
			/*X.RDB$FUNCTION_NAME.NULL*/
			isc_696.isc_704 = TRUE;
			/*X.RDB$BASE_COLLATION_NAME.NULL*/
			isc_696.isc_703 = TRUE;
			/*X.RDB$SPECIFIC_ATTRIBUTES.NULL*/
			isc_696.isc_702 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{

				case att_coll_name:
					/*X.RDB$COLLATION_NAME.NULL*/
					isc_696.isc_714 = FALSE;
					GET_TEXT(/*X.RDB$COLLATION_NAME*/
						 isc_696.isc_701);
					BURP_verbose(msgVerbose_restore_collation, /*X.RDB$COLLATION_NAME*/
										   isc_696.isc_701);
					break;

				case att_coll_id:
					/*X.RDB$COLLATION_ID.NULL*/
					isc_696.isc_712 = FALSE;
					/*X.RDB$COLLATION_ID*/
					isc_696.isc_713 = (USHORT) get_numeric(tdgbl);
					break;

				case att_coll_cs_id:
					/*X.RDB$CHARACTER_SET_ID.NULL*/
					isc_696.isc_710 = FALSE;
					/*X.RDB$CHARACTER_SET_ID*/
					isc_696.isc_711 = (USHORT) get_numeric(tdgbl);
					break;

				case att_coll_attr:
					/*X.RDB$COLLATION_ATTRIBUTES.NULL*/
					isc_696.isc_708 = FALSE;
					/*X.RDB$COLLATION_ATTRIBUTES*/
					isc_696.isc_709 = (USHORT) get_numeric(tdgbl);
					break;

				case att_coll_subtype:	// No longer used: 93-11-15 DBS
					// still present to handle V4 R&D gbak files
					get_numeric(tdgbl);
					break;

				case att_coll_sysflag:
					/*X.RDB$SYSTEM_FLAG.NULL*/
					isc_696.isc_706 = FALSE;
					/*X.RDB$SYSTEM_FLAG*/
					isc_696.isc_707 = (USHORT) get_numeric(tdgbl);
					break;

				case att_coll_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_696.isc_705 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_696.isc_700, false);
					break;

				case att_coll_funct:
					/*X.RDB$FUNCTION_NAME.NULL*/
					isc_696.isc_704 = FALSE;
					GET_TEXT(/*X.RDB$FUNCTION_NAME*/
						 isc_696.isc_699);
					break;

				case att_coll_base_collation_name:
					if (tdgbl->RESTORE_format >= 7)
					{
						/*X.RDB$BASE_COLLATION_NAME.NULL*/
						isc_696.isc_703 = FALSE;
						GET_TEXT(/*X.RDB$BASE_COLLATION_NAME*/
							 isc_696.isc_698);
					}
					else
						bad_attribute (scan_next_attr, attribute, msgErr_restore_collation);
					break;

				case att_coll_specific_attr:
					if (tdgbl->RESTORE_format >= 7)
					{
						/*X.RDB$SPECIFIC_ATTRIBUTES.NULL*/
						isc_696.isc_702 = FALSE;
						get_source_blob (tdgbl, /*X.RDB$SPECIFIC_ATTRIBUTES*/
									isc_696.isc_697, false);
					}
					else
						bad_attribute (scan_next_attr, attribute, msgErr_restore_collation);
					break;

				default:
					bad_attribute (scan_next_attr, attribute, msgErr_restore_collation);
					// Msg 215 collation
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_collation_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 138, &isc_696, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_collation_req_handle1)
			X IN RDB$COLLATIONS*/
		{
		
                if (!tdgbl->handles_get_collation_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_collation_req_handle1, (short) sizeof(isc_675), (char*) isc_675);
		if (tdgbl->handles_get_collation_req_handle1)
		   {
		   isc_676.isc_677 = isc_blob_null;
		   isc_676.isc_680 = isc_blob_null;
			/*X.RDB$COLLATION_NAME.NULL*/
			isc_676.isc_694 = TRUE;
			/*X.RDB$COLLATION_ID.NULL*/
			isc_676.isc_692 = TRUE;
			/*X.RDB$CHARACTER_SET_ID.NULL*/
			isc_676.isc_690 = TRUE;
			/*X.RDB$COLLATION_ATTRIBUTES.NULL*/
			isc_676.isc_688 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_676.isc_687 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_676.isc_686 = FALSE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_676.isc_685 = TRUE;
			/*X.RDB$FUNCTION_NAME.NULL*/
			isc_676.isc_684 = TRUE;
			/*X.RDB$BASE_COLLATION_NAME.NULL*/
			isc_676.isc_683 = TRUE;
			/*X.RDB$SPECIFIC_ATTRIBUTES.NULL*/
			isc_676.isc_682 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{

				case att_coll_name:
					/*X.RDB$COLLATION_NAME.NULL*/
					isc_676.isc_694 = FALSE;
					GET_TEXT(/*X.RDB$COLLATION_NAME*/
						 isc_676.isc_681);
					BURP_verbose(msgVerbose_restore_collation, /*X.RDB$COLLATION_NAME*/
										   isc_676.isc_681);
					break;

				case att_coll_id:
					/*X.RDB$COLLATION_ID.NULL*/
					isc_676.isc_692 = FALSE;
					/*X.RDB$COLLATION_ID*/
					isc_676.isc_693 = (USHORT) get_numeric(tdgbl);
					break;

				case att_coll_cs_id:
					/*X.RDB$CHARACTER_SET_ID.NULL*/
					isc_676.isc_690 = FALSE;
					/*X.RDB$CHARACTER_SET_ID*/
					isc_676.isc_691 = (USHORT) get_numeric(tdgbl);
					break;

				case att_coll_attr:
					/*X.RDB$COLLATION_ATTRIBUTES.NULL*/
					isc_676.isc_688 = FALSE;
					/*X.RDB$COLLATION_ATTRIBUTES*/
					isc_676.isc_689 = (USHORT) get_numeric(tdgbl);
					break;

				case att_coll_subtype:	// No longer used: 93-11-15 DBS
					// still present to handle V4 R&D gbak files
					get_numeric(tdgbl);
					break;

				case att_coll_sysflag:
					/*X.RDB$SYSTEM_FLAG.NULL*/
					isc_676.isc_686 = FALSE;
					/*X.RDB$SYSTEM_FLAG*/
					isc_676.isc_687 = (USHORT) get_numeric(tdgbl);
					break;

				case att_coll_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_676.isc_685 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_676.isc_680, false);
					break;

				case att_coll_funct:
					/*X.RDB$FUNCTION_NAME.NULL*/
					isc_676.isc_684 = FALSE;
					GET_TEXT(/*X.RDB$FUNCTION_NAME*/
						 isc_676.isc_679);
					break;

				case att_coll_base_collation_name:
					if (tdgbl->RESTORE_format >= 7)
						eat_text(tdgbl);
					else
						bad_attribute (scan_next_attr, attribute, msgErr_restore_collation);
					break;

				case att_coll_specific_attr:
					if (tdgbl->RESTORE_format >= 7)
						eat_blob(tdgbl);
					else
						bad_attribute (scan_next_attr, attribute, msgErr_restore_collation);
					break;

				default:
					bad_attribute (scan_next_attr, attribute, msgErr_restore_collation);
					// Msg 215 collation
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_collation_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 138, &isc_676, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}

	return true;
}

rec_type get_data(BurpGlobals* tdgbl, burp_rel* relation)
{
   struct isc_673_struct {
          short isc_674;	/* isc_utility */
   } isc_673;
   struct isc_671_struct {
          short isc_672;	/* RDB$INDEX_INACTIVE */
   } isc_671;
   struct isc_668_struct {
          short isc_669;	/* isc_utility */
          short isc_670;	/* RDB$INDEX_INACTIVE */
   } isc_668;
   struct isc_666_struct {
          char  isc_667 [32];	/* RDB$INDEX_NAME */
   } isc_666;
/**************************************
 *
 *	g e t _ d a t a
 *
 **************************************
 *
 * Functional description
 *	Write data records for a relation.
 *
 **************************************/
	isc_req_handle  req_handle = 0;
	/*BASED_ON RDB$INDICES.RDB$INDEX_NAME index_name;*/
	char
	   index_name[32];


	// If we're only doing meta-data, ignore data records

	if (tdgbl->gbl_sw_meta)
		return ignore_data(tdgbl, relation);

	// Start by counting the interesting fields

	RCRD_OFFSET offset = 0;
	ULONG length = 0;
	USHORT count = 0;

	burp_fld* field;
	for (field = relation->rel_fields; field; field = field->fld_next)
	{
		if (!(field->fld_flags & FLD_computed))
		{
			count++;
			length += field->fld_name_length;
		}
	}

	if (tdgbl->RESTORE_format >= 2)
		count += count;

	// Time to generate blr to store data.  Whoppee.

	UCHAR* const blr_buffer = (UCHAR*) BURP_alloc (200 + length + count * 18);
	UCHAR* blr = blr_buffer;

	add_byte(blr, blr_version4);
	add_byte(blr, blr_begin);
	add_byte(blr, blr_message);
	add_byte(blr, 0);				// Message number
	add_word(blr, count);	// Number of fields, counting eof

	// Let's reset count.
	count = 0;

	for (field = relation->rel_fields; field; field = field->fld_next)
	{
		if (field->fld_flags & FLD_computed)
			continue;

		// arrays are of various fld_types but are really blobs

		SSHORT dtype = field->fld_type;
		length = field->fld_length;
		SSHORT alignment = 4;

		if (field->fld_flags & FLD_array)
			dtype = blr_blob;

		if (dtype <= DTYPE_BLR_MAX)
		{
			USHORT l = gds_cvt_blr_dtype[dtype];
			alignment = type_alignments[l];
			if (l = type_lengths[l])
				length = l;
		}

		switch (dtype)
		{
		case blr_text:
		case blr_varying:
			if (dtype == blr_text)
				add_byte(blr, blr_text2);
			else
				add_byte(blr, blr_varying2);

			if (tdgbl->gbl_sw_fix_fss_data && field->fld_character_set_id == CS_UNICODE_FSS)
				add_word(blr, tdgbl->gbl_sw_fix_fss_data_id);
			else
				add_word(blr, field->fld_character_set_id);

			add_word(blr, field->fld_length);
			if (dtype == blr_varying)
				length += sizeof(USHORT);
			break;

		case blr_short:
		case blr_long:
		case blr_quad:
		case blr_int64:
			add_byte(blr, field->fld_type);
			add_byte(blr, field->fld_scale);
			break;

		case blr_float:
		case blr_double:
		case blr_timestamp:
		case blr_sql_time:
		case blr_sql_date:
			add_byte(blr, field->fld_type);
			break;

		case blr_blob:
			alignment = type_alignments[dtype_blob];
			length = type_lengths[dtype_blob];

			if (tdgbl->gbl_sw_fix_fss_data && !(field->fld_flags & FLD_array) &&
				field->fld_sub_type == isc_blob_text && field->fld_character_set_id == CS_UNICODE_FSS)
			{
				add_byte(blr, blr_blob2);
				add_word(blr, field->fld_sub_type);
				add_word(blr, tdgbl->gbl_sw_fix_fss_data_id);
			}
			else
			{
				add_byte(blr, blr_quad);
				add_byte(blr, 0);
			}

			break;

		default:
			BURP_error(26, true, SafeArg() << field->fld_type);
			// msg 26 datatype %ld not understood
			break;
		}
		if (alignment)
			offset = FB_ALIGN(offset, alignment);
		field->fld_offset = offset;
		field->fld_parameter = count++;
		offset += length;
	}

	// If this is format version 2, build fields for null flags

	if (tdgbl->RESTORE_format >= 2)
		for (field = relation->rel_fields; field; field = field->fld_next)
		{
			if (field->fld_flags & FLD_computed)
				continue;
			add_byte(blr, blr_short);
			add_byte(blr, 0);
			offset = FB_ALIGN(offset, sizeof(SSHORT));
			field->fld_missing_parameter = count++;
			offset += sizeof(SSHORT);
		}

	length = offset;

	// Build STORE statement

	add_byte(blr, blr_loop);
	add_byte(blr, blr_receive);
	add_byte(blr, 0);
	add_byte(blr, blr_store);
	add_byte(blr, blr_relation);
	add_string(blr, relation->rel_name);
	add_byte(blr, 0);			// context variable
	add_byte(blr, blr_begin);

	for (field = relation->rel_fields; field; field = field->fld_next)
	{
		if (field->fld_flags & FLD_computed)
			continue;
		add_byte(blr, blr_assignment);
		if (tdgbl->RESTORE_format >= 2)
		{
			add_byte(blr, blr_parameter2);
			add_byte(blr, 0);
			add_word(blr, field->fld_parameter);
			add_word(blr, field->fld_missing_parameter);
		}
		else
		{
			add_byte(blr, blr_parameter);
			add_byte(blr, 0);
			add_word(blr, field->fld_parameter);
		}
		add_byte(blr, blr_field);
		add_byte(blr, 0);
		add_string(blr, field->fld_name);
	}

	add_byte(blr, blr_end);
	add_byte(blr, blr_end);
	add_byte(blr, blr_eoc);

	// Compile request

	USHORT blr_length = blr - blr_buffer;

#ifdef DEBUG
	fb_print_blr(blr_buffer, blr_length, NULL, NULL, 0);
#endif

	FB_API_HANDLE request = 0;
	ISC_STATUS_ARRAY status_vector;

	if (isc_compile_request (status_vector, &DB, &request,
							 blr_length, reinterpret_cast<const char*>(blr_buffer)))
	{
		fb_print_blr(blr_buffer, blr_length, NULL, NULL, 0);
		if (!tdgbl->gbl_sw_incremental)
			BURP_error_redirect (status_vector, 27);
			// msg 27 isc_compile_request failed
		else
		{
			BURP_print_status (false, status_vector);
			BURP_free (blr_buffer);
			return ignore_data(tdgbl, relation);
		}
	}

	BURP_free (blr_buffer);
	SSHORT* buffer = NULL;

	BURP_verbose (124, relation->rel_name);
	// msg 124  restoring data for relation %s

	lstring data;
	data.lstr_allocated = 0;
	data.lstr_address = NULL;
	ULONG old_length = 0;

	ULONG records = 0;
	rec_type record;
	bool resync = false;

	while (true)
	{
		if (get(tdgbl) != att_data_length)
			BURP_error_redirect (NULL, 39);
			// msg 39 expected record length
		USHORT l = (USHORT) get_numeric(tdgbl);
		if (!tdgbl->gbl_sw_transportable && l != length)
		{
#ifdef sparc
			if (!old_length)
				old_length = recompute_length(tdgbl, relation);
#endif
			if (l != old_length)
			{
				BURP_error(40, true, SafeArg() << length << l);
				// msg 40 wrong length record, expected %ld encountered %ld
			}
		}
		if (!buffer) {
			buffer = (SSHORT *) BURP_alloc (MAX (length, l));
		}

		UCHAR* p;
		if (tdgbl->gbl_sw_transportable)
		{
			if (get(tdgbl) != att_xdr_length)
				BURP_error_redirect (NULL, 55);
				// msg 55 Expected XDR record length
			else
			{
				data.lstr_length = l = (USHORT) get_numeric(tdgbl);
				if (l > data.lstr_allocated)
				{
					data.lstr_allocated = l;
					if (data.lstr_address)
						BURP_free (data.lstr_address);
					data.lstr_address = BURP_alloc(data.lstr_allocated);
				}
				p = data.lstr_address;
			}
		}
		else
			p = reinterpret_cast<UCHAR*>(buffer);
		if (get(tdgbl) != att_data_data)
			BURP_error_redirect (NULL, 41);
			// msg 41 expected data attribute

		if (tdgbl->gbl_sw_compress)
			decompress (tdgbl, p, l);
		else
		{
			get_block(tdgbl, p, l);
		}

		if (old_length)
			realign (tdgbl, (UCHAR*) buffer, relation);

		if (tdgbl->gbl_sw_transportable)
			CAN_encode_decode (relation, &data, (UCHAR *)buffer, FALSE);

		records++;

		if ((records % RESTORE_VERBOSE_INTERVAL) == 0)
			BURP_verbose(107, SafeArg() << records);

		for (field = relation->rel_fields; field; field = field->fld_next)
		{
			if (!(field->fld_flags & FLD_computed))
			{
				if (field->fld_type == blr_blob || (field->fld_flags & FLD_array))
				{
					ISC_QUAD* blob_id = (ISC_QUAD*) ((SCHAR*) buffer + field->fld_offset);
					blob_id->gds_quad_high = 0;
					blob_id->gds_quad_low = 0;
				}
			}
		}

		get_record(&record, tdgbl);
		while (record == rec_blob || record == rec_array)
		{
			if (record == rec_blob)
				get_blob (tdgbl, relation->rel_fields, (UCHAR *) buffer);
			else if (record == rec_array)
				get_array (tdgbl, relation, (UCHAR *) buffer);
			get_record(&record, tdgbl);
		}

		ISC_STATUS s;

		// ASF: Preferable we should call isc_start_and_send only when records == 1, but this leaks
		// memory when there are blobs and arrays fields - CORE-3802.
		if (resync || records % 1000 == 1)
			s = isc_start_and_send(status_vector, &request, &gds_trans, 0, (USHORT) length, buffer, 0);
		else
			s = isc_send(status_vector, &request, 0, (USHORT) length, buffer, 0);

		resync = (s != 0);

		if (s)
		{
			if (status_vector[1] == isc_not_valid)
			{
				if (tdgbl->gbl_sw_incremental)
				{
					BURP_print (false, 138, relation->rel_name);
					// msg 138 validation error on field in relation %s
					BURP_print_status (false, status_vector);
				}
				else
					BURP_error_redirect (status_vector, 47);
					// msg 47 warning -- record could not be restored
			}
			else if (status_vector[1] == isc_malformed_string)
			{
				if (tdgbl->gbl_sw_incremental)
				{
					// msg 114 restore failed for record in relation %s
					BURP_print(false, 114, relation->rel_name);

					BURP_print_status(false, status_vector);
					BURP_print(false, 342);	// isc_gbak_invalid_data
				}
				else
					BURP_error_redirect(status_vector, 342);	// isc_gbak_invalid_data
			}
			else
			{
				if (tdgbl->gbl_sw_incremental)
				{
					BURP_print (false, 114, relation->rel_name);
					// msg 114 restore failed for record in relation %s
					BURP_print_status (false, status_vector);
				}
				else
					BURP_error_redirect (status_vector, 48);
					// msg 48 isc_send failed
			}

			records--;
		}
		if (record != rec_data)
			break;
	} // while (true)

	BURP_free (buffer);
	if (data.lstr_address)
		BURP_free (data.lstr_address);

	isc_release_request(status_vector, &request);
	if (tdgbl->gbl_sw_incremental)
	{
		BURP_verbose (72, relation->rel_name);
		// msg 72  committing data for relation %s
		/*COMMIT*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
		// existing ON_ERROR continues past error, beck
		/*ON_ERROR*/
		if (isc_status [1])
		   {

			// Fix for bug_no 8055:
			// don't throw away the database just because an index
			// could not be made

			// don't bring the database on-line
			tdgbl->flag_on_line = false;
			ISC_STATUS error_code;
			while (error_code = tdgbl->status_vector[1])
			{
				switch (error_code)
				{
					case isc_sort_mem_err:
					case isc_no_dup:
						strcpy(index_name, (TEXT *)tdgbl->status_vector[3]);
						BURP_print_status(false, tdgbl->status_vector);
						/*FOR (REQUEST_HANDLE req_handle)
						 IDX IN RDB$INDICES WITH IDX.RDB$INDEX_NAME EQ index_name*/
						{
                                                if (!req_handle)
                                                   isc_compile_request (NULL, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle, (short) sizeof(isc_665), (char*) isc_665);
						isc_vtov ((const char*) index_name, (char*) isc_666.isc_667, 32);
                                                isc_start_and_send (NULL, (FB_API_HANDLE*) &req_handle, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_666, (short) 0);
						while (1)
						   {
                                                   isc_receive (NULL, (FB_API_HANDLE*) &req_handle, (short) 1, (short) 4, &isc_668, (short) 0);
						   if (!isc_668.isc_669) break;
							/*MODIFY IDX USING*/
							{
								/*IDX.RDB$INDEX_INACTIVE*/
								isc_668.isc_670 = TRUE;
								BURP_print(false, 240, index_name);
								// msg 240 Index \"%s\" failed to activate because:
								if ( error_code == isc_no_dup )
								{
									BURP_print(false, 241);
									// msg 241 The unique index has duplicate values or NULLs
									BURP_print(false, 242);
									// msg 242 Delete or Update duplicate values or NULLs, and activate index with
								}
								else
								{
									BURP_print(false, 244);
									// msg 244 Not enough disk space to create the sort file for an index
									BURP_print(false, 245);
									// msg 245 Set the TMP environment variable to a directory on a filesystem that does have enough space, and activate index with
								}
								BURP_print(false, 243, index_name);
								// msg 243 ALTER INDEX \"%s\" ACTIVE
							/*END_MODIFY;*/
							isc_671.isc_672 = isc_668.isc_670;
                                                        isc_send (NULL, (FB_API_HANDLE*) &req_handle, (short) 2, (short) 2, &isc_671, (short) 0);
							}
						/*END_FOR;*/
                                                   isc_send (NULL, (FB_API_HANDLE*) &req_handle, (short) 3, (short) 2, &isc_673, (short) 0);
						   }
						}
						// commit one more time
						/*COMMIT*/
						{
						isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
						/*ON_ERROR*/
						if (isc_status [1])
						   {
							continue;
						/*END_ERROR*/
						   }
						}
						break;
					default:
						BURP_print (false, 69, relation->rel_name);
						// msg 69 commit failed on relation %s
						BURP_print_status (false, tdgbl->status_vector);
						/*ROLLBACK;*/
						{
						isc_rollback_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
						/*ON_ERROR*/
						if (isc_status [1])
						   {
							general_on_error ();
						/*END_ERROR;*/
						   }
						}
						break;
				} // end of switch
			} // end of while
		/*END_ERROR;*/
		   }
		}

		/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_9);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_10);
			SQLCODE = isc_sqlcode(isc_status);
			}
	}
	BURP_verbose (107, SafeArg() << records);
	// msg 107 %ld records restored

	return record;
}

bool get_exception(BurpGlobals* tdgbl)
{
   struct isc_656_struct {
          char  isc_657 [1024];	/* RDB$MESSAGE */
          ISC_QUAD isc_658;	/* RDB$DESCRIPTION */
          char  isc_659 [32];	/* RDB$EXCEPTION_NAME */
          short isc_660;	/* gds__null_flag */
          short isc_661;	/* RDB$SYSTEM_FLAG */
          short isc_662;	/* gds__null_flag */
          short isc_663;	/* gds__null_flag */
          short isc_664;	/* gds__null_flag */
   } isc_656;
/**************************************
 *
 *	g e t _ e x c e p t i o n
 *
 **************************************
 *
 * Functional description
 *	Reconstruct a exception.
 *
 **************************************/
	att_type	attribute;
	TEXT		temp[GDS_NAME_LEN];
	ULONG		l2 = 0;
	scan_attr_t		scan_next_attr;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_exception_req_handle1)
		X IN RDB$EXCEPTIONS*/
	{
	
        if (!tdgbl->handles_get_exception_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_exception_req_handle1, (short) sizeof(isc_655), (char*) isc_655);
	if (tdgbl->handles_get_exception_req_handle1)
	   {
	   isc_656.isc_658 = isc_blob_null;
		/*X.RDB$EXCEPTION_NAME.NULL*/
		isc_656.isc_664 = TRUE;
		/*X.RDB$DESCRIPTION.NULL*/
		isc_656.isc_663 = TRUE;
		/*X.RDB$MESSAGE.NULL*/
		isc_656.isc_662 = TRUE;
		/*X.RDB$SYSTEM_FLAG*/
		isc_656.isc_661 = 0;
		/*X.RDB$SYSTEM_FLAG.NULL*/
		isc_656.isc_660 = FALSE;

		att_type failed_attrib = att_end;
		bool msg_seen = false; // only for att_exception_msg, not att_exception_msg2
		UCHAR* msg_ptr = reinterpret_cast<UCHAR*>(/*X.RDB$MESSAGE*/
							  isc_656.isc_657);

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_exception_name:
				if (!/*X.RDB$EXCEPTION_NAME.NULL*/
				     isc_656.isc_664)
					BURP_error(311, true, SafeArg() << att_exception_name << /*X.RDB$EXCEPTION_NAME*/
												 isc_656.isc_659);
				else
				{
					const ULONG l = GET_TEXT(/*X.RDB$EXCEPTION_NAME*/
								 isc_656.isc_659);
					/*X.RDB$EXCEPTION_NAME.NULL*/
					isc_656.isc_664 = FALSE;
					MISC_terminate (/*X.RDB$EXCEPTION_NAME*/
							isc_656.isc_659, temp, l, sizeof(temp));
					BURP_verbose (199, temp);
					// msg 199 restoring exception %s
				}
				break;

			case att_exception_description:
				if (!/*X.RDB$DESCRIPTION.NULL*/
				     isc_656.isc_663)
					BURP_error(311, true, SafeArg() << att_exception_description << /*X.RDB$EXCEPTION_NAME*/
													isc_656.isc_659);
				else
				{
					msg_seen = false;
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_656.isc_658, false);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_656.isc_663 = FALSE;
				}
				break;

			case att_exception_description2:
				if (!/*X.RDB$DESCRIPTION.NULL*/
				     isc_656.isc_663)
					BURP_error(311, true, SafeArg() << att_exception_description2 << /*X.RDB$EXCEPTION_NAME*/
													 isc_656.isc_659);
				else
				{
					msg_seen = false;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_656.isc_658, false);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_656.isc_663 = FALSE;
				}
				break;

			case att_exception_msg:
				if (msg_seen)
					BURP_error(311, true, SafeArg() << att_exception_msg << /*X.RDB$EXCEPTION_NAME*/
												isc_656.isc_659);
				else if (!/*X.RDB$MESSAGE.NULL*/
					  isc_656.isc_662)
				{
					msg_seen = true;
					BURP_print(true, 312, SafeArg() << att_exception_msg << /*X.RDB$EXCEPTION_NAME*/
												isc_656.isc_659);
					eat_text(tdgbl);
				}
				else
				{
					msg_seen = true;
					l2 = GET_TEXT(/*X.RDB$MESSAGE*/
						      isc_656.isc_657);
					msg_ptr += l2;
					/*X.RDB$MESSAGE.NULL*/
					isc_656.isc_662 = FALSE;
				}
				break;

			case att_exception_msg2:
				if (msg_seen)
					BURP_error(311, true, SafeArg() << att_exception_msg2 << /*X.RDB$EXCEPTION_NAME*/
												 isc_656.isc_659);
				else if (!/*X.RDB$MESSAGE.NULL*/
					  isc_656.isc_662)
				{
					BURP_print(true, 312, SafeArg() << att_exception_msg2 << /*X.RDB$EXCEPTION_NAME*/
												 isc_656.isc_659);
					eat_text2(tdgbl);
				}
				else
				{
					GET_TEXT2(/*X.RDB$MESSAGE*/
						  isc_656.isc_657);
					/*X.RDB$MESSAGE.NULL*/
					isc_656.isc_662 = FALSE;
				}
				break;

			default:
				if (msg_seen && (tdgbl->RESTORE_format == 7 || tdgbl->RESTORE_format == 8))
				{
					 // we have a corrupt backup
					if (!failed_attrib)
					{
						failed_attrib = attribute;
						BURP_print(true, 313, SafeArg() << failed_attrib << /*X.RDB$EXCEPTION_NAME*/
												    isc_656.isc_659);
					}

					// Notice we use 1021 instead of 1023 because this is the maximum length
					// for this field in v2.0 and v2.1 and they produce the corrupt backups.
					const int FIELD_LIMIT = 1021;

					const int remaining = FIELD_LIMIT - l2;
					if (remaining < 1) // not enough space
					{
						bad_attribute(scan_next_attr, failed_attrib, 287);
						break;
					}
					*msg_ptr++ = char(attribute); // (1)
					UCHAR* rc_ptr = get_block(tdgbl, msg_ptr, MIN(remaining - 1, 255));
					if (remaining > 1 && rc_ptr == msg_ptr) // we couldn't read anything
					{
						bad_attribute(scan_next_attr, failed_attrib, 287);
						break;
					}
					l2 += rc_ptr - msg_ptr + 1; // + 1 because (1)
					msg_ptr = rc_ptr;
					*msg_ptr = 0;
					if (l2 == FIELD_LIMIT)
						msg_seen = false;
				}
				else
					bad_attribute(scan_next_attr, attribute, 287); // msg 287 exception
				break;
			}
		}
		// Versions prior to FB2.0 don't support a field longer than varchar(78).
		// Versions prior to FB2.5 use a field length of 1021, not 1023.
		if (tdgbl->RESTORE_ods < DB_VERSION_DDL11)
			/*X.RDB$MESSAGE*/
			isc_656.isc_657[78] = 0;
		else if (tdgbl->RESTORE_ods < DB_VERSION_DDL11_2)
			/*X.RDB$MESSAGE*/
			isc_656.isc_657[1021] = 0;
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_exception_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 1074, &isc_656, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}


burp_fld* get_field(BurpGlobals* tdgbl, burp_rel* relation)
{
   struct isc_621_struct {
          char  isc_622 [32];	/* RDB$FIELD_SOURCE */
          char  isc_623 [32];	/* RDB$FIELD_NAME */
          ISC_QUAD isc_624;	/* RDB$DEFAULT_VALUE */
          ISC_QUAD isc_625;	/* RDB$DEFAULT_SOURCE */
          char  isc_626 [32];	/* RDB$COMPLEX_NAME */
          ISC_QUAD isc_627;	/* RDB$DESCRIPTION */
          char  isc_628 [128];	/* RDB$EDIT_STRING */
          ISC_QUAD isc_629;	/* RDB$QUERY_HEADER */
          char  isc_630 [32];	/* RDB$QUERY_NAME */
          char  isc_631 [32];	/* RDB$SECURITY_CLASS */
          char  isc_632 [32];	/* RDB$BASE_FIELD */
          char  isc_633 [32];	/* RDB$RELATION_NAME */
          short isc_634;	/* gds__null_flag */
          short isc_635;	/* RDB$COLLATION_ID */
          short isc_636;	/* gds__null_flag */
          short isc_637;	/* RDB$NULL_FLAG */
          short isc_638;	/* gds__null_flag */
          short isc_639;	/* gds__null_flag */
          short isc_640;	/* gds__null_flag */
          short isc_641;	/* RDB$UPDATE_FLAG */
          short isc_642;	/* gds__null_flag */
          short isc_643;	/* gds__null_flag */
          short isc_644;	/* RDB$SYSTEM_FLAG */
          short isc_645;	/* gds__null_flag */
          short isc_646;	/* gds__null_flag */
          short isc_647;	/* gds__null_flag */
          short isc_648;	/* gds__null_flag */
          short isc_649;	/* gds__null_flag */
          short isc_650;	/* gds__null_flag */
          short isc_651;	/* gds__null_flag */
          short isc_652;	/* gds__null_flag */
          short isc_653;	/* RDB$VIEW_CONTEXT */
          short isc_654;	/* RDB$FIELD_POSITION */
   } isc_621;
/**************************************
 *
 *	g e t _ f i e l d
 *
 **************************************
 *
 * Functional description
 *	Reconstruct a local field.
 *
 **************************************/
	att_type		attribute;
	scan_attr_t		scan_next_attr;

	// If it is a view and there is a global transaction then use it
	bool global_tr = false;
	isc_tr_handle local_trans;
	if ((relation->rel_flags & REL_view) && tdgbl->global_trans)
	{
		local_trans = tdgbl->global_trans;
		global_tr = true;
	}
	else
		local_trans = gds_trans;

	burp_fld* field = (burp_fld*) BURP_alloc_zero (sizeof(burp_fld));

	/*STORE (TRANSACTION_HANDLE local_trans
			REQUEST_HANDLE tdgbl->handles_get_field_req_handle1)
		X IN RDB$RELATION_FIELDS*/
	{
	
        if (!tdgbl->handles_get_field_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_field_req_handle1, (short) sizeof(isc_620), (char*) isc_620);
	if (tdgbl->handles_get_field_req_handle1)
	   {
	   isc_621.isc_624 = isc_blob_null;
	   isc_621.isc_625 = isc_blob_null;
	   isc_621.isc_627 = isc_blob_null;
	   isc_621.isc_629 = isc_blob_null;
		strcpy (/*X.RDB$RELATION_NAME*/
			isc_621.isc_633, relation->rel_name);
		/*X.RDB$FIELD_POSITION*/
		isc_621.isc_654 = 0;
		/*X.RDB$VIEW_CONTEXT.NULL*/
		isc_621.isc_652 = TRUE;
		/*X.RDB$BASE_FIELD.NULL*/
		isc_621.isc_651 = TRUE;
		/*X.RDB$SECURITY_CLASS.NULL*/
		isc_621.isc_650 = TRUE;
		/*X.RDB$QUERY_NAME.NULL*/
		isc_621.isc_649 = TRUE;
		/*X.RDB$QUERY_HEADER.NULL*/
		isc_621.isc_648 = TRUE;
		/*X.RDB$EDIT_STRING.NULL*/
		isc_621.isc_647 = TRUE;
		/*X.RDB$DESCRIPTION.NULL*/
		isc_621.isc_646 = TRUE;
		/*X.RDB$FIELD_POSITION.NULL*/
		isc_621.isc_645 = TRUE;
		/*X.RDB$SYSTEM_FLAG*/
		isc_621.isc_644 = 0;
		/*X.RDB$SYSTEM_FLAG.NULL*/
		isc_621.isc_643 = FALSE;
		/*X.RDB$COMPLEX_NAME.NULL*/
		isc_621.isc_642 = TRUE;
		/*X.RDB$UPDATE_FLAG.NULL*/
		isc_621.isc_640 = TRUE;
		/*X.RDB$DEFAULT_SOURCE.NULL*/
		isc_621.isc_639 = TRUE;
		/*X.RDB$DEFAULT_VALUE.NULL*/
		isc_621.isc_638 = TRUE;
		/*X.RDB$NULL_FLAG.NULL*/
		isc_621.isc_636 = TRUE;
		/*X.RDB$COLLATION_ID.NULL*/
		isc_621.isc_634 = TRUE;

		skip_init(&scan_next_attr);
		while (get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (skip_scan(&scan_next_attr), attribute)
			{
			case att_field_name:
				field->fld_name_length = GET_TEXT(field->fld_name);
				BURP_verbose (115, field->fld_name);
				// msg 115 restoring field %s
				strcpy (/*X.RDB$FIELD_NAME*/
					isc_621.isc_623, field->fld_name);
				break;

			case att_field_source:
				GET_TEXT(/*X.RDB$FIELD_SOURCE*/
					 isc_621.isc_622);
				break;

			case att_field_security_class:
				GET_TEXT(/*X.RDB$SECURITY_CLASS*/
					 isc_621.isc_631);
				fix_security_class_name(tdgbl, /*X.RDB$SECURITY_CLASS*/
							       isc_621.isc_631, true);
				/*X.RDB$SECURITY_CLASS.NULL*/
				isc_621.isc_650 = FALSE;
				break;

			case att_field_query_name:
				GET_TEXT(/*X.RDB$QUERY_NAME*/
					 isc_621.isc_630);
				/*X.RDB$QUERY_NAME.NULL*/
				isc_621.isc_649 = FALSE;
				break;

			case att_field_query_header:
				/*X.RDB$QUERY_HEADER.NULL*/
				isc_621.isc_648 = FALSE;
				get_source_blob (tdgbl, /*X.RDB$QUERY_HEADER*/
							isc_621.isc_629, global_tr);
				break;

			case att_field_edit_string:
				GET_TEXT(/*X.RDB$EDIT_STRING*/
					 isc_621.isc_628);
				/*X.RDB$EDIT_STRING.NULL*/
				isc_621.isc_647 = FALSE;
				break;

			case att_field_position:
				/*X.RDB$FIELD_POSITION.NULL*/
				isc_621.isc_645 = FALSE;
				/*X.RDB$FIELD_POSITION*/
				isc_621.isc_654 = (USHORT) get_numeric(tdgbl);
				break;

			case att_field_number:
				field->fld_number = (USHORT) get_numeric(tdgbl);
				break;

			case att_field_type:
				field->fld_type = (USHORT) get_numeric(tdgbl);
				break;

			case att_field_length:
				field->fld_length = (USHORT) get_numeric(tdgbl);
				break;

			case att_field_scale:
				field->fld_scale = (USHORT) get_numeric(tdgbl);
				break;

			case att_field_sub_type:
				field->fld_sub_type = (USHORT) get_numeric(tdgbl);
				break;

			case att_field_system_flag:
				/*X.RDB$SYSTEM_FLAG*/
				isc_621.isc_644 = (USHORT) get_numeric(tdgbl);
				/*X.RDB$SYSTEM_FLAG.NULL*/
				isc_621.isc_643 = FALSE;
				break;

			case att_view_context:
				/*X.RDB$VIEW_CONTEXT*/
				isc_621.isc_653 = (USHORT) get_numeric(tdgbl);
				/*X.RDB$VIEW_CONTEXT.NULL*/
				isc_621.isc_652 = FALSE;
				break;

			case att_field_computed_flag:
				if (get_numeric(tdgbl))
					field->fld_flags |= FLD_computed;
				break;

			case att_base_field:
				GET_TEXT(/*X.RDB$BASE_FIELD*/
					 isc_621.isc_632);
				/*X.RDB$BASE_FIELD.NULL*/
				isc_621.isc_651 = FALSE;
				break;

			case att_field_description:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_621.isc_646 = FALSE;
				get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
						      isc_621.isc_627, global_tr);
				break;

			case att_field_description2:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_621.isc_646 = FALSE;
				get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							isc_621.isc_627, global_tr);
				break;

			case att_field_complex_name:
				GET_TEXT(/*X.RDB$COMPLEX_NAME*/
					 isc_621.isc_626);
				/*X.RDB$COMPLEX_NAME.NULL*/
				isc_621.isc_642 = FALSE;
				break;

			case att_field_dimensions:
				{
					field->fld_dimensions = (USHORT) get_numeric(tdgbl);
					field->fld_flags |= FLD_array;
					USHORT n = field->fld_dimensions;
					for (SLONG* rp = field->fld_ranges; n; rp += 2, n--)
					{
						if (get_attribute(&attribute, tdgbl) != att_field_range_low)
							bad_attribute (scan_next_attr, attribute, 58);
						// msg 58 array
						else
							*rp = get_numeric(tdgbl);
						if (get_attribute(&attribute, tdgbl) != att_field_range_high)
							bad_attribute (scan_next_attr, attribute, 58);
							// msg 58 array
						else
							*(rp + 1) = get_numeric(tdgbl);
					}
				}
				break;

			case att_field_update_flag:
				/*X.RDB$UPDATE_FLAG.NULL*/
				isc_621.isc_640 = FALSE;
				/*X.RDB$UPDATE_FLAG*/
				isc_621.isc_641 = (USHORT) get_numeric(tdgbl);
				break;

			case att_field_character_length:
				field->fld_character_length = (USHORT) get_numeric(tdgbl);
				break;

			case att_field_default_source:
				/*X.RDB$DEFAULT_SOURCE.NULL*/
				isc_621.isc_639 = FALSE;
				get_source_blob (tdgbl, /*X.RDB$DEFAULT_SOURCE*/
							isc_621.isc_625, global_tr);
				break;

			case att_field_default_value:
				/*X.RDB$DEFAULT_VALUE.NULL*/
				isc_621.isc_638 = FALSE;
				get_blr_blob (tdgbl, /*X.RDB$DEFAULT_VALUE*/
						     isc_621.isc_624, global_tr);
				break;

			case att_field_null_flag:
				if (tdgbl->gbl_sw_novalidity) {
					get_numeric(tdgbl); // skip
				}
				else {
					/*X.RDB$NULL_FLAG.NULL*/
					isc_621.isc_636 = FALSE;
					/*X.RDB$NULL_FLAG*/
					isc_621.isc_637 = (USHORT) get_numeric(tdgbl);
				}
				break;

			case att_field_character_set:
				field->fld_character_set_id = (USHORT) get_numeric(tdgbl);
				break;

			case att_field_collation_id:
				field->fld_collation_id = (USHORT) get_numeric(tdgbl);
				/*X.RDB$COLLATION_ID.NULL*/
				isc_621.isc_634 = FALSE;
				/*X.RDB$COLLATION_ID*/
				isc_621.isc_635 = field->fld_collation_id;
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 84);
				// msg 84 column
				break;
			}
		}

	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_field_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 426, &isc_621, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return field;
}

bool get_field_dimensions(BurpGlobals* tdgbl)
{
   struct isc_615_struct {
          char  isc_616 [32];	/* RDB$FIELD_NAME */
          ISC_LONG isc_617;	/* RDB$UPPER_BOUND */
          ISC_LONG isc_618;	/* RDB$LOWER_BOUND */
          short isc_619;	/* RDB$DIMENSION */
   } isc_615;
/**************************************
 *
 *	g e t _ f i e l d _ d i m e n s i o n s
 *
 **************************************
 *
 * Functional description
 *	Get array field dimensions in rdb$field_dimensions.
 *
 **************************************/
	att_type		attribute;
	scan_attr_t		scan_next_attr;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_field_dimensions_req_handle1)
		X IN RDB$FIELD_DIMENSIONS*/
	{
	
        if (!tdgbl->handles_get_field_dimensions_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_field_dimensions_req_handle1, (short) sizeof(isc_614), (char*) isc_614);
	if (tdgbl->handles_get_field_dimensions_req_handle1)
	   {

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_field_name:
				GET_TEXT(/*X.RDB$FIELD_NAME*/
					 isc_615.isc_616);
				break;

			case att_field_dimensions:
				/*X.RDB$DIMENSION*/
				isc_615.isc_619 = (USHORT) get_numeric(tdgbl);
				break;

			case att_field_range_low:
				/*X.RDB$LOWER_BOUND*/
				isc_615.isc_618 = get_numeric(tdgbl);
				break;

			case att_field_range_high:
				/*X.RDB$UPPER_BOUND*/
				isc_615.isc_617 = get_numeric(tdgbl);
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 288);
				// msg 288 array dimensions
				break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_field_dimensions_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 42, &isc_615, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

bool get_files(BurpGlobals* tdgbl)
{
   struct isc_607_struct {
          char  isc_608 [256];	/* RDB$FILE_NAME */
          ISC_LONG isc_609;	/* RDB$FILE_LENGTH */
          ISC_LONG isc_610;	/* RDB$FILE_START */
          short isc_611;	/* RDB$SHADOW_NUMBER */
          short isc_612;	/* RDB$FILE_SEQUENCE */
          short isc_613;	/* RDB$FILE_FLAGS */
   } isc_607;
/**************************************
 *
 *	g e t _ f i l e s
 *
 **************************************
 *
 * Functional description
 *	Get any files that were stored; let
 *	somebody else worry about what to do with them.
 *
 **************************************/
	att_type		attribute;
	scan_attr_t		scan_next_attr;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_files_req_handle1)
		X IN RDB$FILES*/
	{
	
        if (!tdgbl->handles_get_files_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_files_req_handle1, (short) sizeof(isc_606), (char*) isc_606);
	if (tdgbl->handles_get_files_req_handle1)
	   {
		/*X.RDB$FILE_FLAGS*/
		isc_607.isc_613 = 0;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_file_filename:
				GET_TEXT(/*X.RDB$FILE_NAME*/
					 isc_607.isc_608);
				BURP_verbose (116, /*X.RDB$FILE_NAME*/
						   isc_607.isc_608);
				// msg 116 restoring file %s
				break;

			case att_file_sequence:
				/*X.RDB$FILE_SEQUENCE*/
				isc_607.isc_612 = (USHORT) get_numeric(tdgbl);
				break;

			case att_file_start:
				/*X.RDB$FILE_START*/
				isc_607.isc_610 = get_numeric(tdgbl);
				break;

			case att_file_length:
				/*X.RDB$FILE_LENGTH*/
				isc_607.isc_609 = get_numeric(tdgbl);
				break;

			case att_file_flags:
				/*X.RDB$FILE_FLAGS*/
				isc_607.isc_613 |= get_numeric(tdgbl);
				break;

			case att_shadow_number:
				/*X.RDB$SHADOW_NUMBER*/
				isc_607.isc_611 = (USHORT) get_numeric(tdgbl);
				if (tdgbl->gbl_sw_kill && /*X.RDB$SHADOW_NUMBER*/
							  isc_607.isc_611)
					/*X.RDB$FILE_FLAGS*/
					isc_607.isc_613 |= FILE_inactive;
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 85);
				// msg 85 file
				break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_files_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 270, &isc_607, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

bool get_filter(BurpGlobals* tdgbl)
{
   struct isc_596_struct {
          char  isc_597 [32];	/* RDB$ENTRYPOINT */
          char  isc_598 [256];	/* RDB$MODULE_NAME */
          char  isc_599 [32];	/* RDB$FUNCTION_NAME */
          ISC_QUAD isc_600;	/* RDB$DESCRIPTION */
          short isc_601;	/* RDB$OUTPUT_SUB_TYPE */
          short isc_602;	/* RDB$INPUT_SUB_TYPE */
          short isc_603;	/* gds__null_flag */
          short isc_604;	/* RDB$SYSTEM_FLAG */
          short isc_605;	/* gds__null_flag */
   } isc_596;
/**************************************
 *
 *	g e t _ f i l t e r
 *
 **************************************
 *
 * Functional description
 *	Get a type definition in rdb$filters.
 *
 **************************************/
	att_type		attribute;
	scan_attr_t		scan_next_attr;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_filter_req_handle1)
		X IN RDB$FILTERS*/
	{
	
        if (!tdgbl->handles_get_filter_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_filter_req_handle1, (short) sizeof(isc_595), (char*) isc_595);
	if (tdgbl->handles_get_filter_req_handle1)
	   {
	   isc_596.isc_600 = isc_blob_null;
		/*X.RDB$DESCRIPTION.NULL*/
		isc_596.isc_605 = TRUE;
		/*X.RDB$SYSTEM_FLAG*/
		isc_596.isc_604 = 0;
		/*X.RDB$SYSTEM_FLAG.NULL*/
		isc_596.isc_603 = FALSE;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_filter_name:
				GET_TEXT(/*X.RDB$FUNCTION_NAME*/
					 isc_596.isc_599);
				BURP_verbose (117, /*X.RDB$FUNCTION_NAME*/
						   isc_596.isc_599);
				// msg 117 restoring filter %s
				break;

			case att_filter_description:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_596.isc_605 = FALSE;
				get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
						      isc_596.isc_600, false);
				break;

			case att_filter_description2:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_596.isc_605 = FALSE;
				get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							isc_596.isc_600, false);
				break;

			case att_filter_module_name:
				GET_TEXT(/*X.RDB$MODULE_NAME*/
					 isc_596.isc_598);
				break;

			case att_filter_entrypoint:
				GET_TEXT(/*X.RDB$ENTRYPOINT*/
					 isc_596.isc_597);
				break;

			case att_filter_input_sub_type:
				/*X.RDB$INPUT_SUB_TYPE*/
				isc_596.isc_602 = (USHORT) get_numeric(tdgbl);
				break;

			case att_filter_output_sub_type:
				/*X.RDB$OUTPUT_SUB_TYPE*/
				isc_596.isc_601 = (USHORT) get_numeric(tdgbl);
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 87);
				// msg 87  filter
				break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_filter_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 338, &isc_596, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

bool get_function(BurpGlobals* tdgbl)
{
   struct isc_584_struct {
          char  isc_585 [32];	/* RDB$QUERY_NAME */
          char  isc_586 [32];	/* RDB$ENTRYPOINT */
          char  isc_587 [256];	/* RDB$MODULE_NAME */
          char  isc_588 [32];	/* RDB$FUNCTION_NAME */
          ISC_QUAD isc_589;	/* RDB$DESCRIPTION */
          short isc_590;	/* RDB$FUNCTION_TYPE */
          short isc_591;	/* RDB$RETURN_ARGUMENT */
          short isc_592;	/* gds__null_flag */
          short isc_593;	/* gds__null_flag */
          short isc_594;	/* RDB$SYSTEM_FLAG */
   } isc_584;
/**************************************
 *
 *	g e t _ f u n c t i o n
 *
 **************************************
 *
 * Functional description
 *	Reconstruct a function.
 *
 **************************************/
	att_type	attribute;
	GDS_NAME	function_name;
	TEXT		temp[GDS_NAME_LEN];
	SSHORT		l;
	scan_attr_t	scan_next_attr;

	bool existFlag = false;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_function_req_handle1)
		X IN RDB$FUNCTIONS*/
	{
	
        if (!tdgbl->handles_get_function_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_function_req_handle1, (short) sizeof(isc_583), (char*) isc_583);
	if (tdgbl->handles_get_function_req_handle1)
	   {
	   isc_584.isc_589 = isc_blob_null;
		/*X.RDB$SYSTEM_FLAG*/
		isc_584.isc_594 = 0;
		/*X.RDB$SYSTEM_FLAG.NULL*/
		isc_584.isc_593 = FALSE;
		/*X.RDB$DESCRIPTION.NULL*/
		isc_584.isc_592 = TRUE;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_function_name:
				l = GET_TEXT(/*X.RDB$FUNCTION_NAME*/
					     isc_584.isc_588);
				MISC_terminate (/*X.RDB$FUNCTION_NAME*/
						isc_584.isc_588, temp, l, sizeof(temp));
				BURP_verbose (118, temp);
				// msg 118 restoring function %s
				break;

			case att_function_description:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_584.isc_592 = FALSE;
				get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
						      isc_584.isc_589, false);
				break;

			case att_function_description2:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_584.isc_592 = FALSE;
				get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							isc_584.isc_589, false);
				break;

			case att_function_module_name:
				GET_TEXT(/*X.RDB$MODULE_NAME*/
					 isc_584.isc_587);
				break;

			case att_function_entrypoint:
				GET_TEXT(/*X.RDB$ENTRYPOINT*/
					 isc_584.isc_586);
				break;

			case att_function_return_arg:
				/*X.RDB$RETURN_ARGUMENT*/
				isc_584.isc_591 = (USHORT) get_numeric(tdgbl);
				break;

			case att_function_query_name:
				GET_TEXT(/*X.RDB$QUERY_NAME*/
					 isc_584.isc_585);
				break;

			case att_function_type:
				/*X.RDB$FUNCTION_TYPE*/
				isc_584.isc_590 = (USHORT) get_numeric(tdgbl);
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 89);
				// msg 89 function
				break;
			}
		}
	strcpy (function_name, /*X.RDB$FUNCTION_NAME*/
			       isc_584.isc_588);
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_function_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 370, &isc_584, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		if (gds_status[1] != isc_no_dup)
		{
			general_on_error ();
		}
		else
		{
			existFlag = true;
		}
	/*END_ERROR;*/
	   }
	}

	// at the end of args for a function is the rec_function_end marker
	while (get(tdgbl) == rec_function_arg)
		get_function_arg(tdgbl, existFlag);

	return true;
}

void get_function_arg(BurpGlobals* tdgbl, bool skip_arguments)
{
   struct isc_558_struct {
          char  isc_559 [32];	/* RDB$FUNCTION_NAME */
          short isc_560;	/* RDB$FIELD_LENGTH */
          short isc_561;	/* RDB$FIELD_SCALE */
          short isc_562;	/* RDB$FIELD_TYPE */
          short isc_563;	/* RDB$MECHANISM */
          short isc_564;	/* RDB$ARGUMENT_POSITION */
          short isc_565;	/* gds__null_flag */
          short isc_566;	/* RDB$CHARACTER_SET_ID */
          short isc_567;	/* gds__null_flag */
          short isc_568;	/* RDB$FIELD_SUB_TYPE */
   } isc_558;
   struct isc_570_struct {
          char  isc_571 [32];	/* RDB$FUNCTION_NAME */
          short isc_572;	/* RDB$FIELD_LENGTH */
          short isc_573;	/* RDB$FIELD_SCALE */
          short isc_574;	/* RDB$FIELD_TYPE */
          short isc_575;	/* RDB$MECHANISM */
          short isc_576;	/* RDB$ARGUMENT_POSITION */
          short isc_577;	/* gds__null_flag */
          short isc_578;	/* RDB$FIELD_PRECISION */
          short isc_579;	/* gds__null_flag */
          short isc_580;	/* RDB$CHARACTER_SET_ID */
          short isc_581;	/* gds__null_flag */
          short isc_582;	/* RDB$FIELD_SUB_TYPE */
   } isc_570;
/**************************************
 *
 *	g e t _ f u n c t i o n _ a r g
 *
 **************************************
 *
 * Functional description
 *	Reconstruct function argument.
 *
 **************************************/
	att_type	attribute;
	SSHORT		l;
	TEXT		temp[GDS_NAME_LEN];
	scan_attr_t		scan_next_attr;

	if (skip_arguments)
	{
		char buf[MAX_SQL_IDENTIFIER_SIZE];
		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_functionarg_name:
				GET_TEXT(buf);
				break;

			case att_functionarg_position:
				get_numeric(tdgbl);
				break;

			case att_functionarg_mechanism:
				get_numeric(tdgbl);
				break;

			case att_functionarg_field_type:
				get_numeric(tdgbl);
				break;

			case att_functionarg_field_scale:
				get_numeric(tdgbl);
				break;

			case att_functionarg_field_length:
				get_numeric(tdgbl);
				break;

			case att_functionarg_field_sub_type:
				get_numeric(tdgbl);
				break;

			case att_functionarg_character_set:
				get_numeric(tdgbl);
				break;

			case att_functionarg_field_precision:
				get_numeric(tdgbl);
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 90);
				// msg 90 function argument
				break;
			}
		}
		return;
	}

	if (tdgbl->RESTORE_ods >= DB_VERSION_DDL10)
	{
		// with RDB$FIELD_PRECISION
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_function_arg_req_handle1)
			X IN RDB$FUNCTION_ARGUMENTS*/
		{
		
                if (!tdgbl->handles_get_function_arg_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_function_arg_req_handle1, (short) sizeof(isc_569), (char*) isc_569);
		if (tdgbl->handles_get_function_arg_req_handle1)
		   {
			/*X.RDB$FIELD_SUB_TYPE.NULL*/
			isc_570.isc_581 = TRUE;
			/*X.RDB$CHARACTER_SET_ID.NULL*/
			isc_570.isc_579 = TRUE;
			/*X.RDB$FIELD_PRECISION.NULL*/
			isc_570.isc_577  = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_functionarg_name:
					l = GET_TEXT(/*X.RDB$FUNCTION_NAME*/
						     isc_570.isc_571);
					MISC_terminate (/*X.RDB$FUNCTION_NAME*/
							isc_570.isc_571, temp, l, sizeof(temp));
					BURP_verbose (119, temp);
					// msg 119 restoring argument for function %s
					break;

				case att_functionarg_position:
					/*X.RDB$ARGUMENT_POSITION*/
					isc_570.isc_576 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_mechanism:
					/*X.RDB$MECHANISM*/
					isc_570.isc_575 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_field_type:
					/*X.RDB$FIELD_TYPE*/
					isc_570.isc_574 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_field_scale:
					/*X.RDB$FIELD_SCALE*/
					isc_570.isc_573 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_field_length:
					/*X.RDB$FIELD_LENGTH*/
					isc_570.isc_572 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_field_sub_type:
					/*X.RDB$FIELD_SUB_TYPE.NULL*/
					isc_570.isc_581 = FALSE;
					/*X.RDB$FIELD_SUB_TYPE*/
					isc_570.isc_582 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_character_set:
					/*X.RDB$CHARACTER_SET_ID.NULL*/
					isc_570.isc_579 = FALSE;
					/*X.RDB$CHARACTER_SET_ID*/
					isc_570.isc_580 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_field_precision:
					if (tdgbl->RESTORE_format >= 6)
					{
						/*X.RDB$FIELD_PRECISION.NULL*/
						isc_570.isc_577 = FALSE;
						/*X.RDB$FIELD_PRECISION*/
						isc_570.isc_578 = (USHORT) get_numeric(tdgbl);
					}
					else
						bad_attribute (scan_next_attr, attribute, 90);
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 90);
					// msg 90 function argument
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_function_arg_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 54, &isc_570, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		// without RDB$FIELD_PRECISION
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_function_arg_req_handle1)
			X IN RDB$FUNCTION_ARGUMENTS*/
		{
		
                if (!tdgbl->handles_get_function_arg_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_function_arg_req_handle1, (short) sizeof(isc_557), (char*) isc_557);
		if (tdgbl->handles_get_function_arg_req_handle1)
		   {
			/*X.RDB$FIELD_SUB_TYPE.NULL*/
			isc_558.isc_567 = TRUE;
			/*X.RDB$CHARACTER_SET_ID.NULL*/
			isc_558.isc_565 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_functionarg_name:
					l = GET_TEXT(/*X.RDB$FUNCTION_NAME*/
						     isc_558.isc_559);
					MISC_terminate (/*X.RDB$FUNCTION_NAME*/
							isc_558.isc_559, temp, l, sizeof(temp));
					BURP_verbose (119, temp);
					// msg 119 restoring argument for function %s
					break;

				case att_functionarg_position:
					/*X.RDB$ARGUMENT_POSITION*/
					isc_558.isc_564 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_mechanism:
					/*X.RDB$MECHANISM*/
					isc_558.isc_563 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_field_type:
					/*X.RDB$FIELD_TYPE*/
					isc_558.isc_562 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_field_scale:
					/*X.RDB$FIELD_SCALE*/
					isc_558.isc_561 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_field_length:
					/*X.RDB$FIELD_LENGTH*/
					isc_558.isc_560 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_field_sub_type:
					/*X.RDB$FIELD_SUB_TYPE.NULL*/
					isc_558.isc_567 = FALSE;
					/*X.RDB$FIELD_SUB_TYPE*/
					isc_558.isc_568 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_character_set:
					/*X.RDB$CHARACTER_SET_ID.NULL*/
					isc_558.isc_565 = FALSE;
					/*X.RDB$CHARACTER_SET_ID*/
					isc_558.isc_566 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_field_precision:
					if (tdgbl->RESTORE_format >= 6)
						get_numeric(tdgbl);
					else
						bad_attribute (scan_next_attr, attribute, 90);

				default:
					bad_attribute (scan_next_attr, attribute, 90);
					// msg 90 function argument
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_function_arg_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 50, &isc_558, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
}

bool get_generator(BurpGlobals* tdgbl)
{
/**************************************
 *
 *	g e t _ g e n e r a t o r
 *
 **************************************
 *
 * Functional description
 *	Pick up a gen-id.  Like most things, there is ughly history.
 *	In the modern world, gen_id are free floating records.  In the
 *	bad old days they were attributes of relations.  Handle both
 *	nicely.
 *
 **************************************/
	SINT64		value = 0;
	/*BASED_ON RDB$GENERATORS.RDB$GENERATOR_NAME name;*/
	char
	   name[32];

	name[0] = 0; // just in case.
	att_type	attribute;
	scan_attr_t		scan_next_attr;

	skip_init(&scan_next_attr);

	ISC_QUAD gen_desc = {0, 0};
	bool got_desc = false;

	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
	{
		switch (attribute)
		{
		case att_gen_generator:
			GET_TEXT(name);
			break;

		case att_gen_value:
			// IB v5 or earlier, gen_id value is an SLONG
			value = (SINT64) get_numeric(tdgbl);
			break;

		case att_gen_value_int64:
			// IB v6 or later, gen_id value is an SINT64
			value = get_int64(tdgbl);
			break;

		case att_gen_description:
			if (tdgbl->RESTORE_format >= 7)
			{
				get_source_blob (tdgbl, gen_desc, false);
				got_desc = gen_desc.gds_quad_high || gen_desc.gds_quad_low;
			}
			else
				bad_attribute(scan_next_attr, attribute, 289);
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 289);
			// msg 289 generator
			break;
		}
	}

	if (tdgbl->gbl_sw_meta)
	{
		value = 0;
	}

	store_blr_gen_id(tdgbl, name, value, got_desc ? &gen_desc : NULL);

	return true;
}

bool get_global_field(BurpGlobals* tdgbl)
{
   struct isc_450_struct {
          char  isc_451 [32];	/* RDB$FIELD_NAME */
          ISC_QUAD isc_452;	/* RDB$DEFAULT_SOURCE */
          ISC_QUAD isc_453;	/* RDB$MISSING_SOURCE */
          ISC_QUAD isc_454;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_455;	/* RDB$VALIDATION_SOURCE */
          ISC_QUAD isc_456;	/* RDB$VALIDATION_BLR */
          ISC_QUAD isc_457;	/* RDB$DEFAULT_VALUE */
          ISC_QUAD isc_458;	/* RDB$MISSING_VALUE */
          ISC_QUAD isc_459;	/* RDB$QUERY_HEADER */
          char  isc_460 [128];	/* RDB$EDIT_STRING */
          char  isc_461 [32];	/* RDB$QUERY_NAME */
          ISC_QUAD isc_462;	/* RDB$COMPUTED_SOURCE */
          ISC_QUAD isc_463;	/* RDB$COMPUTED_BLR */
          short isc_464;	/* gds__null_flag */
          short isc_465;	/* RDB$FIELD_LENGTH */
          short isc_466;	/* RDB$FIELD_TYPE */
          short isc_467;	/* gds__null_flag */
          short isc_468;	/* gds__null_flag */
          short isc_469;	/* gds__null_flag */
          short isc_470;	/* gds__null_flag */
          short isc_471;	/* gds__null_flag */
          short isc_472;	/* gds__null_flag */
          short isc_473;	/* RDB$CHARACTER_LENGTH */
          short isc_474;	/* gds__null_flag */
          short isc_475;	/* gds__null_flag */
          short isc_476;	/* RDB$EXTERNAL_SCALE */
          short isc_477;	/* gds__null_flag */
          short isc_478;	/* RDB$EXTERNAL_TYPE */
          short isc_479;	/* gds__null_flag */
          short isc_480;	/* RDB$EXTERNAL_LENGTH */
          short isc_481;	/* gds__null_flag */
          short isc_482;	/* RDB$DIMENSIONS */
          short isc_483;	/* gds__null_flag */
          short isc_484;	/* gds__null_flag */
          short isc_485;	/* RDB$NULL_FLAG */
          short isc_486;	/* gds__null_flag */
          short isc_487;	/* RDB$SYSTEM_FLAG */
          short isc_488;	/* gds__null_flag */
          short isc_489;	/* gds__null_flag */
          short isc_490;	/* gds__null_flag */
          short isc_491;	/* gds__null_flag */
          short isc_492;	/* gds__null_flag */
          short isc_493;	/* gds__null_flag */
          short isc_494;	/* gds__null_flag */
          short isc_495;	/* gds__null_flag */
          short isc_496;	/* gds__null_flag */
          short isc_497;	/* RDB$FIELD_SUB_TYPE */
          short isc_498;	/* RDB$COLLATION_ID */
          short isc_499;	/* RDB$CHARACTER_SET_ID */
          short isc_500;	/* RDB$SEGMENT_LENGTH */
          short isc_501;	/* RDB$FIELD_SCALE */
   } isc_450;
   struct isc_503_struct {
          char  isc_504 [32];	/* RDB$FIELD_NAME */
          ISC_QUAD isc_505;	/* RDB$DEFAULT_SOURCE */
          ISC_QUAD isc_506;	/* RDB$MISSING_SOURCE */
          ISC_QUAD isc_507;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_508;	/* RDB$VALIDATION_SOURCE */
          ISC_QUAD isc_509;	/* RDB$VALIDATION_BLR */
          ISC_QUAD isc_510;	/* RDB$DEFAULT_VALUE */
          ISC_QUAD isc_511;	/* RDB$MISSING_VALUE */
          ISC_QUAD isc_512;	/* RDB$QUERY_HEADER */
          char  isc_513 [128];	/* RDB$EDIT_STRING */
          char  isc_514 [32];	/* RDB$QUERY_NAME */
          ISC_QUAD isc_515;	/* RDB$COMPUTED_SOURCE */
          ISC_QUAD isc_516;	/* RDB$COMPUTED_BLR */
          short isc_517;	/* gds__null_flag */
          short isc_518;	/* RDB$FIELD_LENGTH */
          short isc_519;	/* RDB$FIELD_TYPE */
          short isc_520;	/* gds__null_flag */
          short isc_521;	/* RDB$FIELD_PRECISION */
          short isc_522;	/* gds__null_flag */
          short isc_523;	/* gds__null_flag */
          short isc_524;	/* gds__null_flag */
          short isc_525;	/* gds__null_flag */
          short isc_526;	/* gds__null_flag */
          short isc_527;	/* gds__null_flag */
          short isc_528;	/* RDB$CHARACTER_LENGTH */
          short isc_529;	/* gds__null_flag */
          short isc_530;	/* gds__null_flag */
          short isc_531;	/* RDB$EXTERNAL_SCALE */
          short isc_532;	/* gds__null_flag */
          short isc_533;	/* RDB$EXTERNAL_TYPE */
          short isc_534;	/* gds__null_flag */
          short isc_535;	/* RDB$EXTERNAL_LENGTH */
          short isc_536;	/* gds__null_flag */
          short isc_537;	/* RDB$DIMENSIONS */
          short isc_538;	/* gds__null_flag */
          short isc_539;	/* gds__null_flag */
          short isc_540;	/* RDB$NULL_FLAG */
          short isc_541;	/* gds__null_flag */
          short isc_542;	/* RDB$SYSTEM_FLAG */
          short isc_543;	/* gds__null_flag */
          short isc_544;	/* gds__null_flag */
          short isc_545;	/* gds__null_flag */
          short isc_546;	/* gds__null_flag */
          short isc_547;	/* gds__null_flag */
          short isc_548;	/* gds__null_flag */
          short isc_549;	/* gds__null_flag */
          short isc_550;	/* gds__null_flag */
          short isc_551;	/* gds__null_flag */
          short isc_552;	/* RDB$FIELD_SUB_TYPE */
          short isc_553;	/* RDB$COLLATION_ID */
          short isc_554;	/* RDB$CHARACTER_SET_ID */
          short isc_555;	/* RDB$SEGMENT_LENGTH */
          short isc_556;	/* RDB$FIELD_SCALE */
   } isc_503;
/**************************************
 *
 *	g e t _ g l o b a l _ f i e l d
 *
 **************************************
 *
 * Functional description
 *	Reconstruct a global field.
 *
 **************************************/
	att_type	attribute;
	TEXT		temp[GDS_NAME_LEN];
	SSHORT		l;
	scan_attr_t		scan_next_attr;

	gfld* gfield = NULL;

	if (tdgbl->RESTORE_ods >= DB_VERSION_DDL10)
	{
		// with rdb$field_precision
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_global_field_req_handle1)
			X IN RDB$FIELDS*/
		{
		
                if (!tdgbl->handles_get_global_field_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_global_field_req_handle1, (short) sizeof(isc_502), (char*) isc_502);
		if (tdgbl->handles_get_global_field_req_handle1)
		   {
		   isc_503.isc_505 = isc_blob_null;
		   isc_503.isc_506 = isc_blob_null;
		   isc_503.isc_507 = isc_blob_null;
		   isc_503.isc_508 = isc_blob_null;
		   isc_503.isc_509 = isc_blob_null;
		   isc_503.isc_510 = isc_blob_null;
		   isc_503.isc_511 = isc_blob_null;
		   isc_503.isc_512 = isc_blob_null;
		   isc_503.isc_515 = isc_blob_null;
		   isc_503.isc_516 = isc_blob_null;

			/*X.RDB$FIELD_SCALE*/
			isc_503.isc_556 = /*X.RDB$SEGMENT_LENGTH*/
   isc_503.isc_555 = 0;
			/*X.RDB$CHARACTER_SET_ID*/
			isc_503.isc_554 = /*X.RDB$COLLATION_ID*/
   isc_503.isc_553 = 0;
			/*X.RDB$FIELD_SUB_TYPE*/
			isc_503.isc_552 = 0;
			/*X.RDB$COMPUTED_BLR.NULL*/
			isc_503.isc_551 = TRUE;
			/*X.RDB$COMPUTED_SOURCE.NULL*/
			isc_503.isc_550 = TRUE;
			/*X.RDB$QUERY_NAME.NULL*/
			isc_503.isc_549 = TRUE;
			/*X.RDB$EDIT_STRING.NULL*/
			isc_503.isc_548 = TRUE;
			/*X.RDB$QUERY_HEADER.NULL*/
			isc_503.isc_547 = TRUE;
			/*X.RDB$MISSING_VALUE.NULL*/
			isc_503.isc_546 = TRUE;
			/*X.RDB$DEFAULT_VALUE.NULL*/
			isc_503.isc_545 = TRUE;
			/*X.RDB$VALIDATION_BLR.NULL*/
			isc_503.isc_544 = TRUE;
			/*X.RDB$VALIDATION_SOURCE.NULL*/
			isc_503.isc_543 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_503.isc_542 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_503.isc_541 = FALSE;
			/*X.RDB$NULL_FLAG.NULL*/
			isc_503.isc_539 = TRUE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_503.isc_538 = TRUE;
			/*X.RDB$DIMENSIONS.NULL*/
			isc_503.isc_536 = TRUE;
			/*X.RDB$EXTERNAL_LENGTH.NULL*/
			isc_503.isc_534 = TRUE;
			/*X.RDB$EXTERNAL_TYPE.NULL*/
			isc_503.isc_532 = TRUE;
			/*X.RDB$EXTERNAL_SCALE.NULL*/
			isc_503.isc_530 = TRUE;
			/*X.RDB$SEGMENT_LENGTH.NULL*/
			isc_503.isc_529 = TRUE;
			/*X.RDB$CHARACTER_LENGTH.NULL*/
			isc_503.isc_527 = TRUE;
			/*X.RDB$MISSING_SOURCE.NULL*/
			isc_503.isc_526 = TRUE;
			/*X.RDB$DEFAULT_SOURCE.NULL*/
			isc_503.isc_525 = TRUE;
			/*X.RDB$FIELD_SUB_TYPE.NULL*/
			isc_503.isc_524 = TRUE;
			/*X.RDB$CHARACTER_SET_ID.NULL*/
			isc_503.isc_523 = TRUE;
			/*X.RDB$COLLATION_ID.NULL*/
			isc_503.isc_522 = TRUE;
			/*X.RDB$FIELD_PRECISION.NULL*/
			isc_503.isc_520 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_field_name:
					l = GET_TEXT(/*X.RDB$FIELD_NAME*/
						     isc_503.isc_504);
					MISC_terminate (/*X.RDB$FIELD_NAME*/
							isc_503.isc_504, temp, l, sizeof(temp));
					BURP_verbose (121, temp);
					// msg 121  restoring global field %s
					break;

				case att_field_query_name:
					GET_TEXT(/*X.RDB$QUERY_NAME*/
						 isc_503.isc_514);
					/*X.RDB$QUERY_NAME.NULL*/
					isc_503.isc_549 = FALSE;
					break;

				case att_field_edit_string:
					GET_TEXT(/*X.RDB$EDIT_STRING*/
						 isc_503.isc_513);
					/*X.RDB$EDIT_STRING.NULL*/
					isc_503.isc_548 = FALSE;
					break;

				case att_field_query_header:
					/*X.RDB$QUERY_HEADER.NULL*/
					isc_503.isc_547 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$QUERY_HEADER*/
								isc_503.isc_512, false);
					break;

				case att_field_type:
					/*X.RDB$FIELD_TYPE*/
					isc_503.isc_519 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_length:
					/*X.RDB$FIELD_LENGTH*/
					isc_503.isc_518 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_scale:
					/*X.RDB$FIELD_SCALE*/
					isc_503.isc_556 = (USHORT) get_numeric(tdgbl);
					/*X.RDB$FIELD_SCALE.NULL*/
					isc_503.isc_517 = FALSE;
					break;

				case att_field_sub_type:
					/*X.RDB$FIELD_SUB_TYPE*/
					isc_503.isc_552 = (USHORT) get_numeric(tdgbl);
					/*X.RDB$FIELD_SUB_TYPE.NULL*/
					isc_503.isc_524 = FALSE;
					break;

				case att_field_segment_length:
					/*X.RDB$SEGMENT_LENGTH*/
					isc_503.isc_555 = (USHORT) get_numeric(tdgbl);
					if (/*X.RDB$SEGMENT_LENGTH*/
					    isc_503.isc_555)
						/*X.RDB$SEGMENT_LENGTH.NULL*/
						isc_503.isc_529 = FALSE;
					break;

				case att_field_computed_blr:
					// if we are going against a V4.0 database,
					// restore the global fields in 2 phases.

					if (tdgbl->global_trans)
					{
						if (!gfield)
							gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

						get_blr_blob (tdgbl, gfield->gfld_computed_blr, true);
						gfield->gfld_flags |= GFLD_computed_blr;
					}
					else
					{
						/*X.RDB$COMPUTED_BLR.NULL*/
						isc_503.isc_551 = FALSE;
						get_blr_blob (tdgbl, /*X.RDB$COMPUTED_BLR*/
								     isc_503.isc_516, false);
					}
					break;

				case att_field_computed_source:
					// if we are going against a V4.0 database,
					// restore the global fields in 2 phases.

					if (tdgbl->global_trans)
					{
						if (!gfield)
							gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

						get_misc_blob (tdgbl, gfield->gfld_computed_source, true);
						gfield->gfld_flags |= GFLD_computed_source;
					}
					else
					{
						/*X.RDB$COMPUTED_SOURCE.NULL*/
						isc_503.isc_550 = FALSE;
						get_misc_blob (tdgbl, /*X.RDB$COMPUTED_SOURCE*/
								      isc_503.isc_515, false);
					}
					break;

				case att_field_computed_source2:
					// if we are going against a V4.0 database,
					// restore the global fields in 2 phases.

					if (tdgbl->global_trans)
					{
						if (!gfield)
							gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

						get_source_blob (tdgbl, gfield->gfld_computed_source2, true);
						gfield->gfld_flags |= GFLD_computed_source2;
					}
					else
					{
						/*X.RDB$COMPUTED_SOURCE.NULL*/
						isc_503.isc_550 = FALSE;
						get_source_blob (tdgbl, /*X.RDB$COMPUTED_SOURCE*/
									isc_503.isc_515, false);
					}
					break;

				case att_field_validation_blr:
					if (tdgbl->gbl_sw_novalidity)
						eat_blob(tdgbl);
					else
					{
						// if we are going against a V4.0 database,
						// restore the global fields in 2 phases.

						if (tdgbl->global_trans)
						{
							if (!gfield)
								gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

							get_blr_blob (tdgbl, gfield->gfld_vb, true);
							gfield->gfld_flags |= GFLD_validation_blr;
						}
						else
						{
							/*X.RDB$VALIDATION_BLR.NULL*/
							isc_503.isc_544 = FALSE;
							get_blr_blob (tdgbl, /*X.RDB$VALIDATION_BLR*/
									     isc_503.isc_509, false);
						}
					}
					break;

				case att_field_validation_source:
					if (tdgbl->gbl_sw_novalidity)
						eat_blob(tdgbl);
					else
					{
						// if we are going against a V4.0 database,
						// restore the global fields in 2 phases.

						if (tdgbl->global_trans)
						{
							if (!gfield)
								gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

							get_misc_blob (tdgbl, gfield->gfld_vs, true);
							gfield->gfld_flags |= GFLD_validation_source;
						}
						else
						{
							/*X.RDB$VALIDATION_SOURCE.NULL*/
							isc_503.isc_543 = FALSE;
							get_misc_blob (tdgbl, /*X.RDB$VALIDATION_SOURCE*/
									      isc_503.isc_508, false);
						}
					}
					break;

				case att_field_validation_source2:
					if (tdgbl->gbl_sw_novalidity)
						eat_blob(tdgbl);
					else
					{
						// if we are going against a V4.0 database,
						// restore the global fields in 2 phases.

						if (tdgbl->global_trans)
						{
							if (!gfield)
								gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

							get_source_blob (tdgbl, gfield->gfld_vs2, true);
							gfield->gfld_flags |= GFLD_validation_source2;
						}
						else
						{
							/*X.RDB$VALIDATION_SOURCE.NULL*/
							isc_503.isc_543 = FALSE;
							get_source_blob (tdgbl, /*X.RDB$VALIDATION_SOURCE*/
										isc_503.isc_508, false);
						}
					}
					break;

				case att_field_missing_value:
					/*X.RDB$MISSING_VALUE.NULL*/
					isc_503.isc_546 = FALSE;
					get_blr_blob (tdgbl, /*X.RDB$MISSING_VALUE*/
							     isc_503.isc_511, false);
					break;

				case att_field_default_value:
					/*X.RDB$DEFAULT_VALUE.NULL*/
					isc_503.isc_545 = FALSE;
					get_blr_blob (tdgbl, /*X.RDB$DEFAULT_VALUE*/
							     isc_503.isc_510, false);
					break;

				case att_field_system_flag:
					/*X.RDB$SYSTEM_FLAG*/
					isc_503.isc_542 = (USHORT) get_numeric(tdgbl);
					/*X.RDB$SYSTEM_FLAG.NULL*/
					isc_503.isc_541 = FALSE;
					break;

				case att_field_null_flag:
					if (tdgbl->gbl_sw_novalidity) {
						get_numeric(tdgbl); // skip
					}
					else {
						/*X.RDB$NULL_FLAG*/
						isc_503.isc_540 = (USHORT) get_numeric(tdgbl);
						/*X.RDB$NULL_FLAG.NULL*/
						isc_503.isc_539 = FALSE;
					}
					break;

				case att_field_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_503.isc_538 = FALSE;
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_503.isc_507, false);
					break;

				case att_field_description2:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_503.isc_538 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_503.isc_507, false);
					break;

				case att_field_external_length:
					/*X.RDB$EXTERNAL_LENGTH.NULL*/
					isc_503.isc_534 = FALSE;
					/*X.RDB$EXTERNAL_LENGTH*/
					isc_503.isc_535 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_external_scale:
					/*X.RDB$EXTERNAL_SCALE.NULL*/
					isc_503.isc_530 = FALSE;
					/*X.RDB$EXTERNAL_SCALE*/
					isc_503.isc_531 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_external_type:
					/*X.RDB$EXTERNAL_TYPE.NULL*/
					isc_503.isc_532 = FALSE;
					/*X.RDB$EXTERNAL_TYPE*/
					isc_503.isc_533 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_dimensions:
					/*X.RDB$DIMENSIONS.NULL*/
					isc_503.isc_536 = FALSE;
					/*X.RDB$DIMENSIONS*/
					isc_503.isc_537 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_character_length:
					/*X.RDB$CHARACTER_LENGTH.NULL*/
					isc_503.isc_527 = FALSE;
					/*X.RDB$CHARACTER_LENGTH*/
					isc_503.isc_528 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_default_source:
					/*X.RDB$DEFAULT_SOURCE.NULL*/
					isc_503.isc_525 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DEFAULT_SOURCE*/
								isc_503.isc_505, false);
					break;

				case att_field_missing_source:
					/*X.RDB$MISSING_SOURCE.NULL*/
					isc_503.isc_526 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$MISSING_SOURCE*/
								isc_503.isc_506, false);
					break;

				case att_field_character_set:
					/*X.RDB$CHARACTER_SET_ID.NULL*/
					isc_503.isc_523 = FALSE;
					/*X.RDB$CHARACTER_SET_ID*/
					isc_503.isc_554 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_collation_id:
					/*X.RDB$COLLATION_ID.NULL*/
					isc_503.isc_522 = FALSE;
					/*X.RDB$COLLATION_ID*/
					isc_503.isc_553 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_precision:
					if (tdgbl->RESTORE_format >= 6)
					{
						/*X.RDB$FIELD_PRECISION.NULL*/
						isc_503.isc_520 = FALSE;
						/*X.RDB$FIELD_PRECISION*/
						isc_503.isc_521 = (USHORT) get_numeric(tdgbl);
					}
					else
						bad_attribute (scan_next_attr, attribute, 92);
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 92);
					// msg 92  domain
					break;
				}
			}

			if (/*X.RDB$FIELD_TYPE*/
			    isc_503.isc_519 <= DTYPE_BLR_MAX)
			{
				l = gds_cvt_blr_dtype[/*X.RDB$FIELD_TYPE*/
						      isc_503.isc_519];
				if (l = type_lengths[l])
					/*X.RDB$FIELD_LENGTH*/
					isc_503.isc_518 = l;
			}

			if (gfield)
				strcpy (gfield->gfld_name, /*X.RDB$FIELD_NAME*/
							   isc_503.isc_504);

			if (tdgbl->gbl_sw_fix_fss_data && tdgbl->gbl_sw_fix_fss_data_id == 0 &&
				!/*X.RDB$CHARACTER_SET_ID.NULL*/
				 isc_503.isc_523 && /*X.RDB$CHARACTER_SET_ID*/
    isc_503.isc_554 == CS_UNICODE_FSS &&
				((!/*X.RDB$CHARACTER_LENGTH.NULL*/
				   isc_503.isc_527 &&
					(/*X.RDB$FIELD_TYPE*/
					 isc_503.isc_519 == blr_text || /*X.RDB$FIELD_TYPE*/
		isc_503.isc_519 == blr_varying)) ||
				 /*X.RDB$FIELD_TYPE*/
				 isc_503.isc_519 == blr_blob))
			{
				if (/*X.RDB$FIELD_TYPE*/
				    isc_503.isc_519 != blr_blob)
					/*X.RDB$CHARACTER_LENGTH*/
					isc_503.isc_528 = /*X.RDB$FIELD_LENGTH*/
   isc_503.isc_518;

				/*X.RDB$CHARACTER_SET_ID*/
				isc_503.isc_554 = CS_NONE;
				/*X.RDB$COLLATION_ID*/
				isc_503.isc_553 = 0;
			}

		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_global_field_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 352, &isc_503, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

	}
	else // RESTORE_ods < DB_VERSION_DDL10
	{
		// without rdb$field_precision

		/*STORE (REQUEST_HANDLE tdgbl->handles_get_global_field_req_handle1)
			X IN RDB$FIELDS*/
		{
		
                if (!tdgbl->handles_get_global_field_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_global_field_req_handle1, (short) sizeof(isc_449), (char*) isc_449);
		if (tdgbl->handles_get_global_field_req_handle1)
		   {
		   isc_450.isc_452 = isc_blob_null;
		   isc_450.isc_453 = isc_blob_null;
		   isc_450.isc_454 = isc_blob_null;
		   isc_450.isc_455 = isc_blob_null;
		   isc_450.isc_456 = isc_blob_null;
		   isc_450.isc_457 = isc_blob_null;
		   isc_450.isc_458 = isc_blob_null;
		   isc_450.isc_459 = isc_blob_null;
		   isc_450.isc_462 = isc_blob_null;
		   isc_450.isc_463 = isc_blob_null;

			/*X.RDB$FIELD_SCALE*/
			isc_450.isc_501 = /*X.RDB$SEGMENT_LENGTH*/
   isc_450.isc_500 = 0;
			/*X.RDB$CHARACTER_SET_ID*/
			isc_450.isc_499 = /*X.RDB$COLLATION_ID*/
   isc_450.isc_498 = 0;
			/*X.RDB$FIELD_SUB_TYPE*/
			isc_450.isc_497 = 0;
			/*X.RDB$COMPUTED_BLR.NULL*/
			isc_450.isc_496 = TRUE;
			/*X.RDB$COMPUTED_SOURCE.NULL*/
			isc_450.isc_495 = TRUE;
			/*X.RDB$QUERY_NAME.NULL*/
			isc_450.isc_494 = TRUE;
			/*X.RDB$EDIT_STRING.NULL*/
			isc_450.isc_493 = TRUE;
			/*X.RDB$QUERY_HEADER.NULL*/
			isc_450.isc_492 = TRUE;
			/*X.RDB$MISSING_VALUE.NULL*/
			isc_450.isc_491 = TRUE;
			/*X.RDB$DEFAULT_VALUE.NULL*/
			isc_450.isc_490 = TRUE;
			/*X.RDB$VALIDATION_BLR.NULL*/
			isc_450.isc_489 = TRUE;
			/*X.RDB$VALIDATION_SOURCE.NULL*/
			isc_450.isc_488 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_450.isc_487 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_450.isc_486 = FALSE;
			/*X.RDB$NULL_FLAG.NULL*/
			isc_450.isc_484 = TRUE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_450.isc_483 = TRUE;
			/*X.RDB$DIMENSIONS.NULL*/
			isc_450.isc_481 = TRUE;
			/*X.RDB$EXTERNAL_LENGTH.NULL*/
			isc_450.isc_479 = TRUE;
			/*X.RDB$EXTERNAL_TYPE.NULL*/
			isc_450.isc_477 = TRUE;
			/*X.RDB$EXTERNAL_SCALE.NULL*/
			isc_450.isc_475 = TRUE;
			/*X.RDB$SEGMENT_LENGTH.NULL*/
			isc_450.isc_474 = TRUE;
			/*X.RDB$CHARACTER_LENGTH.NULL*/
			isc_450.isc_472 = TRUE;
			/*X.RDB$MISSING_SOURCE.NULL*/
			isc_450.isc_471 = TRUE;
			/*X.RDB$DEFAULT_SOURCE.NULL*/
			isc_450.isc_470 = TRUE;
			/*X.RDB$FIELD_SUB_TYPE.NULL*/
			isc_450.isc_469 = TRUE;
			/*X.RDB$CHARACTER_SET_ID.NULL*/
			isc_450.isc_468 = TRUE;
			/*X.RDB$COLLATION_ID.NULL*/
			isc_450.isc_467 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_field_name:
					l = GET_TEXT(/*X.RDB$FIELD_NAME*/
						     isc_450.isc_451);
					MISC_terminate (/*X.RDB$FIELD_NAME*/
							isc_450.isc_451, temp, l, sizeof(temp));
					BURP_verbose (121, temp);
					// msg 121  restoring global field %s
					break;

				case att_field_query_name:
					GET_TEXT(/*X.RDB$QUERY_NAME*/
						 isc_450.isc_461);
					/*X.RDB$QUERY_NAME.NULL*/
					isc_450.isc_494 = FALSE;
					break;

				case att_field_edit_string:
					GET_TEXT(/*X.RDB$EDIT_STRING*/
						 isc_450.isc_460);
					/*X.RDB$EDIT_STRING.NULL*/
					isc_450.isc_493 = FALSE;
					break;

				case att_field_query_header:
					/*X.RDB$QUERY_HEADER.NULL*/
					isc_450.isc_492 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$QUERY_HEADER*/
								isc_450.isc_459, false);
					break;

				case att_field_type:
					/*X.RDB$FIELD_TYPE*/
					isc_450.isc_466 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_length:
					/*X.RDB$FIELD_LENGTH*/
					isc_450.isc_465 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_scale:
					/*X.RDB$FIELD_SCALE*/
					isc_450.isc_501 = (USHORT) get_numeric(tdgbl);
					/*X.RDB$FIELD_SCALE.NULL*/
					isc_450.isc_464 = FALSE;
					break;

				case att_field_sub_type:
					/*X.RDB$FIELD_SUB_TYPE*/
					isc_450.isc_497 = (USHORT) get_numeric(tdgbl);
					/*X.RDB$FIELD_SUB_TYPE.NULL*/
					isc_450.isc_469 = FALSE;
					break;

				case att_field_segment_length:
					/*X.RDB$SEGMENT_LENGTH*/
					isc_450.isc_500 = (USHORT) get_numeric(tdgbl);
					if (/*X.RDB$SEGMENT_LENGTH*/
					    isc_450.isc_500)
						/*X.RDB$SEGMENT_LENGTH.NULL*/
						isc_450.isc_474 = FALSE;
					break;

				case att_field_computed_blr:
					// if we are going against a V4.0 database,
					// restore the global fields in 2 phases.

					if (tdgbl->global_trans)
					{
						if (!gfield)
							gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

						get_blr_blob (tdgbl, gfield->gfld_computed_blr, true);
						gfield->gfld_flags |= GFLD_computed_blr;
					}
					else
					{
						/*X.RDB$COMPUTED_BLR.NULL*/
						isc_450.isc_496 = FALSE;
						get_blr_blob (tdgbl, /*X.RDB$COMPUTED_BLR*/
								     isc_450.isc_463, false);
					}
					break;

				case att_field_computed_source:
					// if we are going against a V4.0 database,
					// restore the global fields in 2 phases.

					if (tdgbl->global_trans)
					{
						if (!gfield)
							gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

						get_misc_blob (tdgbl, gfield->gfld_computed_source, true);
						gfield->gfld_flags |= GFLD_computed_source;
					}
					else
					{
						/*X.RDB$COMPUTED_SOURCE.NULL*/
						isc_450.isc_495 = FALSE;
						get_misc_blob (tdgbl, /*X.RDB$COMPUTED_SOURCE*/
								      isc_450.isc_462, false);
					}
					break;

				case att_field_computed_source2:
					// if we are going against a V4.0 database,
					// restore the global fields in 2 phases.

					if (tdgbl->global_trans)
					{
						if (!gfield)
							gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

						get_source_blob (tdgbl, gfield->gfld_computed_source2, true);
						gfield->gfld_flags |= GFLD_computed_source2;
					}
					else
					{
						/*X.RDB$COMPUTED_SOURCE.NULL*/
						isc_450.isc_495 = FALSE;
						get_source_blob (tdgbl, /*X.RDB$COMPUTED_SOURCE*/
									isc_450.isc_462, false);
					}
					break;

				case att_field_validation_blr:
					if (tdgbl->gbl_sw_novalidity)
						eat_blob(tdgbl);
					else
					{
						// if we are going against a V4.0 database,
						// restore the global fields in 2 phases.

						if (tdgbl->global_trans)
						{
							if (!gfield)
								gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

							get_blr_blob (tdgbl, gfield->gfld_vb, true);
							gfield->gfld_flags |= GFLD_validation_blr;
						}
						else
						{
							/*X.RDB$VALIDATION_BLR.NULL*/
							isc_450.isc_489 = FALSE;
							get_blr_blob (tdgbl, /*X.RDB$VALIDATION_BLR*/
									     isc_450.isc_456, false);
						}
					}
					break;

				case att_field_validation_source:
					if (tdgbl->gbl_sw_novalidity)
						eat_blob(tdgbl);
					else
					{
						// if we are going against a V4.0 database,
						// restore the global fields in 2 phases.

						if (tdgbl->global_trans)
						{
							if (!gfield)
								gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

							get_misc_blob (tdgbl, gfield->gfld_vs, true);
							gfield->gfld_flags |= GFLD_validation_source;
						}
						else
						{
							/*X.RDB$VALIDATION_SOURCE.NULL*/
							isc_450.isc_488 = FALSE;
							get_misc_blob (tdgbl, /*X.RDB$VALIDATION_SOURCE*/
									      isc_450.isc_455, false);
						}
					}
					break;

				case att_field_validation_source2:
					if (tdgbl->gbl_sw_novalidity)
						eat_blob(tdgbl);
					else
					{
						// if we are going against a V4.0 database,
						// restore the global fields in 2 phases.

						if (tdgbl->global_trans)
						{
							if (!gfield)
								gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

							get_source_blob (tdgbl, gfield->gfld_vs2, true);
							gfield->gfld_flags |= GFLD_validation_source2;
						}
						else
						{
							/*X.RDB$VALIDATION_SOURCE.NULL*/
							isc_450.isc_488 = FALSE;
							get_source_blob (tdgbl, /*X.RDB$VALIDATION_SOURCE*/
										isc_450.isc_455, false);
						}
					}
					break;

				case att_field_missing_value:
					/*X.RDB$MISSING_VALUE.NULL*/
					isc_450.isc_491 = FALSE;
					get_blr_blob (tdgbl, /*X.RDB$MISSING_VALUE*/
							     isc_450.isc_458, false);
					break;

				case att_field_default_value:
					/*X.RDB$DEFAULT_VALUE.NULL*/
					isc_450.isc_490 = FALSE;
					get_blr_blob (tdgbl, /*X.RDB$DEFAULT_VALUE*/
							     isc_450.isc_457, false);
					break;

				case att_field_system_flag:
					/*X.RDB$SYSTEM_FLAG*/
					isc_450.isc_487 = (USHORT) get_numeric(tdgbl);
					/*X.RDB$SYSTEM_FLAG.NULL*/
					isc_450.isc_486 = FALSE;
					break;

				case att_field_null_flag:
					if (tdgbl->gbl_sw_novalidity) {
						get_numeric(tdgbl); // skip
					}
					else {
						/*X.RDB$NULL_FLAG*/
						isc_450.isc_485 = (USHORT) get_numeric(tdgbl);
						/*X.RDB$NULL_FLAG.NULL*/
						isc_450.isc_484 = FALSE;
					}
					break;

				case att_field_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_450.isc_483 = FALSE;
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_450.isc_454, false);
					break;

				case att_field_description2:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_450.isc_483 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_450.isc_454, false);
					break;

				case att_field_external_length:
					/*X.RDB$EXTERNAL_LENGTH.NULL*/
					isc_450.isc_479 = FALSE;
					/*X.RDB$EXTERNAL_LENGTH*/
					isc_450.isc_480 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_external_scale:
					/*X.RDB$EXTERNAL_SCALE.NULL*/
					isc_450.isc_475 = FALSE;
					/*X.RDB$EXTERNAL_SCALE*/
					isc_450.isc_476 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_external_type:
					/*X.RDB$EXTERNAL_TYPE.NULL*/
					isc_450.isc_477 = FALSE;
					/*X.RDB$EXTERNAL_TYPE*/
					isc_450.isc_478 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_dimensions:
					/*X.RDB$DIMENSIONS.NULL*/
					isc_450.isc_481 = FALSE;
					/*X.RDB$DIMENSIONS*/
					isc_450.isc_482 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_character_length:
					/*X.RDB$CHARACTER_LENGTH.NULL*/
					isc_450.isc_472 = FALSE;
					/*X.RDB$CHARACTER_LENGTH*/
					isc_450.isc_473 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_default_source:
					/*X.RDB$DEFAULT_SOURCE.NULL*/
					isc_450.isc_470 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DEFAULT_SOURCE*/
								isc_450.isc_452, false);
					break;

				case att_field_missing_source:
					/*X.RDB$MISSING_SOURCE.NULL*/
					isc_450.isc_471 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$MISSING_SOURCE*/
								isc_450.isc_453, false);
					break;

				case att_field_character_set:
					/*X.RDB$CHARACTER_SET_ID.NULL*/
					isc_450.isc_468 = FALSE;
					/*X.RDB$CHARACTER_SET_ID*/
					isc_450.isc_499 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_collation_id:
					/*X.RDB$COLLATION_ID.NULL*/
					isc_450.isc_467 = FALSE;
					/*X.RDB$COLLATION_ID*/
					isc_450.isc_498 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_precision:
					if (tdgbl->RESTORE_format >= 6)
						get_numeric(tdgbl);
					else
						bad_attribute (scan_next_attr, attribute, 92);
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 92);
					// msg 92  domain
					break;
				}
			}

			if (/*X.RDB$FIELD_TYPE*/
			    isc_450.isc_466 <= DTYPE_BLR_MAX)
			{
				l = gds_cvt_blr_dtype[/*X.RDB$FIELD_TYPE*/
						      isc_450.isc_466];
				if (l = type_lengths[l])
					/*X.RDB$FIELD_LENGTH*/
					isc_450.isc_465 = l;
			}

			if (gfield)
				strcpy (gfield->gfld_name, /*X.RDB$FIELD_NAME*/
							   isc_450.isc_451);

			if (tdgbl->gbl_sw_fix_fss_data && tdgbl->gbl_sw_fix_fss_data_id == 0 &&
				!/*X.RDB$CHARACTER_SET_ID.NULL*/
				 isc_450.isc_468 && /*X.RDB$CHARACTER_SET_ID*/
    isc_450.isc_499 == CS_UNICODE_FSS &&
				((!/*X.RDB$CHARACTER_LENGTH.NULL*/
				   isc_450.isc_472 &&
					(/*X.RDB$FIELD_TYPE*/
					 isc_450.isc_466 == blr_text || /*X.RDB$FIELD_TYPE*/
		isc_450.isc_466 == blr_varying)) ||
				 /*X.RDB$FIELD_TYPE*/
				 isc_450.isc_466 == blr_blob))
			{
				if (/*X.RDB$FIELD_TYPE*/
				    isc_450.isc_466 != blr_blob)
					/*X.RDB$CHARACTER_LENGTH*/
					isc_450.isc_473 = /*X.RDB$FIELD_LENGTH*/
   isc_450.isc_465;

				/*X.RDB$CHARACTER_SET_ID*/
				isc_450.isc_499 = CS_NONE;
				/*X.RDB$COLLATION_ID*/
				isc_450.isc_498 = 0;
			}

		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_global_field_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 348, &isc_450, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

	}

	if (gfield)
	{
		gfield->gfld_next = tdgbl->gbl_global_fields;
		tdgbl->gbl_global_fields = gfield;
	}

	return true;
}

bool get_index(BurpGlobals* tdgbl, const burp_rel* relation)
{
   struct isc_417_struct {
          short isc_418;	/* isc_utility */
   } isc_417;
   struct isc_415_struct {
          short isc_416;	/* isc_utility */
   } isc_415;
   struct isc_413_struct {
          short isc_414;	/* isc_utility */
   } isc_413;
   struct isc_411_struct {
          char  isc_412 [32];	/* RDB$INDEX_NAME */
   } isc_411;
   struct isc_423_struct {
          short isc_424;	/* isc_utility */
   } isc_423;
   struct isc_420_struct {
          char  isc_421 [32];	/* RDB$RELATION_NAME */
          char  isc_422 [32];	/* RDB$INDEX_NAME */
   } isc_420;
   struct isc_426_struct {
          char  isc_427 [32];	/* RDB$INDEX_NAME */
          char  isc_428 [32];	/* RDB$FIELD_NAME */
          short isc_429;	/* RDB$FIELD_POSITION */
   } isc_426;
   struct isc_431_struct {
          char  isc_432 [32];	/* RDB$INDEX_NAME */
          ISC_QUAD isc_433;	/* RDB$EXPRESSION_BLR */
          ISC_QUAD isc_434;	/* RDB$EXPRESSION_SOURCE */
          char  isc_435 [32];	/* RDB$FOREIGN_KEY */
          ISC_QUAD isc_436;	/* RDB$DESCRIPTION */
          char  isc_437 [32];	/* RDB$RELATION_NAME */
          short isc_438;	/* RDB$SEGMENT_COUNT */
          short isc_439;	/* gds__null_flag */
          short isc_440;	/* RDB$SYSTEM_FLAG */
          short isc_441;	/* gds__null_flag */
          short isc_442;	/* gds__null_flag */
          short isc_443;	/* gds__null_flag */
          short isc_444;	/* gds__null_flag */
          short isc_445;	/* gds__null_flag */
          short isc_446;	/* RDB$INDEX_TYPE */
          short isc_447;	/* RDB$INDEX_INACTIVE */
          short isc_448;	/* RDB$UNIQUE_FLAG */
   } isc_431;
/**************************************
 *
 *	g e t _ i n d e x
 *
 **************************************
 *
 * Functional description
 *	Build an index.  At the end stop
 *	and check that all fields are defined.
 *	If any fields are missing, delete the
 *	index.
 *
 **************************************/
	/*BASED_ON RDB$INDICES.RDB$INDEX_NAME index_name;*/
	char
	   index_name[32];

	att_type	attribute;
	bool		foreign_index = false, expr_index = false;
	scan_attr_t		scan_next_attr;

	SSHORT count = 0, segments = 0;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_index_req_handle1)
		X IN RDB$INDICES*/
	{
	
        if (!tdgbl->handles_get_index_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle1, (short) sizeof(isc_430), (char*) isc_430);
	if (tdgbl->handles_get_index_req_handle1)
	   {
	   isc_431.isc_433 = isc_blob_null;
	   isc_431.isc_434 = isc_blob_null;
	   isc_431.isc_436 = isc_blob_null;
		strcpy (/*X.RDB$RELATION_NAME*/
			isc_431.isc_437, relation->rel_name);
		/*X.RDB$UNIQUE_FLAG*/
		isc_431.isc_448 = 0;
		if (!tdgbl->gbl_sw_deactivate_indexes)
			/*X.RDB$INDEX_INACTIVE*/
			isc_431.isc_447 = FALSE;
		else
			/*X.RDB$INDEX_INACTIVE*/
			isc_431.isc_447 = TRUE;
		/*X.RDB$INDEX_TYPE.NULL*/
		isc_431.isc_445 = TRUE;
		/*X.RDB$DESCRIPTION.NULL*/
		isc_431.isc_444 = TRUE;
		/*X.RDB$FOREIGN_KEY.NULL*/
		isc_431.isc_443 = TRUE;
		/*X.RDB$EXPRESSION_SOURCE.NULL*/
		isc_431.isc_442 = TRUE;
		/*X.RDB$EXPRESSION_BLR.NULL*/
		isc_431.isc_441 = TRUE;
		/*X.RDB$SYSTEM_FLAG*/
		isc_431.isc_440 = 0;
		/*X.RDB$SYSTEM_FLAG.NULL*/
		isc_431.isc_439 = FALSE;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_index_name:
				GET_TEXT(/*X.RDB$INDEX_NAME*/
					 isc_431.isc_432);
				strcpy (index_name, /*X.RDB$INDEX_NAME*/
						    isc_431.isc_432);
				BURP_verbose (122, /*X.RDB$INDEX_NAME*/
						   isc_431.isc_432);
				break;

			case att_segment_count:
				/*X.RDB$SEGMENT_COUNT*/
				isc_431.isc_438 = segments = (USHORT) get_numeric(tdgbl);
				break;

			case att_index_unique_flag:
				/*X.RDB$UNIQUE_FLAG*/
				isc_431.isc_448 = (USHORT) get_numeric(tdgbl);
				break;

			case att_index_inactive:
				/*X.RDB$INDEX_INACTIVE*/
				isc_431.isc_447 = (USHORT) get_numeric(tdgbl);
				// Defer foreign key index activation
				// Modified by Toni Martir, all index deferred when verbose
				if (tdgbl->gbl_sw_verbose)
				{
					if (!/*X.RDB$INDEX_INACTIVE*/
					     isc_431.isc_447)
						/*X.RDB$INDEX_INACTIVE*/
						isc_431.isc_447 = DEFERRED_ACTIVE;
				}
				else
				{
					if (!/*X.RDB$INDEX_INACTIVE*/
					     isc_431.isc_447 && (foreign_index || expr_index))
						/*X.RDB$INDEX_INACTIVE*/
						isc_431.isc_447 = DEFERRED_ACTIVE;
				}
				if (tdgbl->gbl_sw_deactivate_indexes)
					/*X.RDB$INDEX_INACTIVE*/
					isc_431.isc_447 = TRUE;
				break;

			case att_index_type:
				/*X.RDB$INDEX_TYPE.NULL*/
				isc_431.isc_445 = FALSE;
				/*X.RDB$INDEX_TYPE*/
				isc_431.isc_446 = (USHORT) get_numeric(tdgbl);
				break;

			case att_index_field_name:
				/*STORE (REQUEST_HANDLE tdgbl->handles_get_index_req_handle2)
					Y IN RDB$INDEX_SEGMENTS*/
				{
				
                                if (!tdgbl->handles_get_index_req_handle2)
                                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle2, (short) sizeof(isc_425), (char*) isc_425);
				if (tdgbl->handles_get_index_req_handle2)
				   {
					GET_TEXT(/*Y.RDB$FIELD_NAME*/
						 isc_426.isc_428);
					strcpy (/*Y.RDB$INDEX_NAME*/
						isc_426.isc_427, /*X.RDB$INDEX_NAME*/
  isc_431.isc_432);
					/*Y.RDB$FIELD_POSITION*/
					isc_426.isc_429 = count++;
				/*END_STORE;*/
				   
                                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle2, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 66, &isc_426, (short) 0);
				   };
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
				break;

			case att_index_description:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_431.isc_444 = FALSE;
				get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
						      isc_431.isc_436, false);
				break;

			case att_index_description2:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_431.isc_444 = FALSE;
				get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							isc_431.isc_436, false);
				break;

			case att_index_expression_source:
				/*X.RDB$EXPRESSION_SOURCE.NULL*/
				isc_431.isc_442 = FALSE;
				get_source_blob (tdgbl, /*X.RDB$EXPRESSION_SOURCE*/
							isc_431.isc_434, false);
				break;

			case att_index_expression_blr:
				expr_index = true;
				// Defer expression index activation
				if (!/*X.RDB$INDEX_INACTIVE*/
				     isc_431.isc_447)
					/*X.RDB$INDEX_INACTIVE*/
					isc_431.isc_447 = DEFERRED_ACTIVE;
				if (tdgbl->gbl_sw_deactivate_indexes)
					/*X.RDB$INDEX_INACTIVE*/
					isc_431.isc_447 = TRUE;
				/*X.RDB$EXPRESSION_BLR.NULL*/
				isc_431.isc_441 = FALSE;
				get_blr_blob (tdgbl, /*X.RDB$EXPRESSION_BLR*/
						     isc_431.isc_433, false);
				break;

			case att_index_foreign_key:
				foreign_index = true;
				// Defer foreign key index activation
				if (!/*X.RDB$INDEX_INACTIVE*/
				     isc_431.isc_447)
					/*X.RDB$INDEX_INACTIVE*/
					isc_431.isc_447 = DEFERRED_ACTIVE;
				if (tdgbl->gbl_sw_deactivate_indexes)
					/*X.RDB$INDEX_INACTIVE*/
					isc_431.isc_447 = TRUE;
				/*X.RDB$FOREIGN_KEY.NULL*/
				isc_431.isc_443 = FALSE;
				GET_TEXT(/*X.RDB$FOREIGN_KEY*/
					 isc_431.isc_435);
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 93);
				// msg 93 index
				break;
			}
		}

		count = 0;
		/*FOR (REQUEST_HANDLE tdgbl->handles_get_index_req_handle3)
			RFR IN RDB$RELATION_FIELDS CROSS I_S IN RDB$INDEX_SEGMENTS
			OVER RDB$FIELD_NAME WITH I_S.RDB$INDEX_NAME = index_name AND
			RFR.RDB$RELATION_NAME = relation->rel_name*/
		{
                if (!tdgbl->handles_get_index_req_handle3)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle3, (short) sizeof(isc_419), (char*) isc_419);
		isc_vtov ((const char*) relation->rel_name, (char*) isc_420.isc_421, 32);
		isc_vtov ((const char*) index_name, (char*) isc_420.isc_422, 32);
		if (tdgbl->handles_get_index_req_handle3)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle3, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 64, &isc_420, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle3, (short) 1, (short) 2, &isc_423, (short) 0);
		   if (!isc_423.isc_424 || isc_status [1]) break;
			count++;
		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

		if (count != segments)
		{
			/*FOR (REQUEST_HANDLE tdgbl->handles_get_index_req_handle4)
				I_S IN RDB$INDEX_SEGMENTS WITH I_S.RDB$INDEX_NAME = index_name*/
			{
                        if (!tdgbl->handles_get_index_req_handle4)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle4, (short) sizeof(isc_410), (char*) isc_410);
			isc_vtov ((const char*) index_name, (char*) isc_411.isc_412, 32);
			if (tdgbl->handles_get_index_req_handle4)
			   {
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle4, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_411, (short) 0);
			   }
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle4, (short) 1, (short) 2, &isc_413, (short) 0);
			   if (!isc_413.isc_414 || isc_status [1]) break;
				/*ERASE I_S;*/
				{
                                isc_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle4, (short) 2, (short) 2, &isc_415, (short) 0);
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
			/*END_FOR;*/
                           isc_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle4, (short) 3, (short) 2, &isc_417, (short) 0);
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
			return false;
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 142, &isc_431, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

void get_misc_blob(BurpGlobals* tdgbl,
				   ISC_QUAD&	blob_id,
				   bool			glb_trans)
{
/**************************************
 *
 *	g e t _ m i s c _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Read blob attributes and copy data from input file to nice,
 *	shiney, new blob.
 *
 **************************************/
	ISC_STATUS_ARRAY	status_vector;

	const size_t length = get_numeric(tdgbl);

	// Create new blob

	isc_tr_handle	local_trans;
	if (glb_trans && tdgbl->global_trans)
		local_trans = tdgbl->global_trans;
	else
		local_trans = gds_trans;

	UserBlob blob(status_vector);
	if (!blob.create(DB, local_trans, blob_id))
	{
		BURP_error_redirect (status_vector, 37);
		// msg 37 isc_create_blob failed
	}

	// Allocate blob buffer if static buffer is too short
	BlobBuffer static_buffer;
	UCHAR* const buffer = static_buffer.getBuffer(length);

	if (length)
	{
		get_block(tdgbl, buffer, length);
	}

	if (!blob.putData(length, buffer))
	{
		BURP_error_redirect (status_vector, 38);
		// msg 38 isc_put_segment failed
	}

	if (!blob.close())
		BURP_error_redirect (status_vector, 23);
		// msg 23 isc_close_blob failed
}

SLONG get_numeric(BurpGlobals* tdgbl)
{
/**************************************
 *
 *	g e t _ n u m e r i c
 *
 **************************************
 *
 * Functional description
 *	Get a numeric value from the input stream.
 *
 **************************************/
	SLONG	value[2];

	// get_text needs additional space for the terminator,
	// because it treats everything as strings.
	fb_assert(sizeof(value) > sizeof(SLONG));

	const SSHORT length = get_text(tdgbl, (TEXT*) value, sizeof(value));

	return isc_vax_integer ((SCHAR *) value, length);
}

SINT64 get_int64(BurpGlobals* tdgbl)
{
/**************************************
 *
 *	g e t _ i n t 6 4
 *
 **************************************
 *
 * Functional description
 *	Get a possibly-64-bit numeric value from the input stream.
 *
 **************************************/
	SLONG	value[4];

	// get_text needs additional space for the terminator,
	// because it treats everything as strings.
	fb_assert (sizeof(value) > sizeof(SINT64));

	const SSHORT length = get_text(tdgbl, (TEXT*) value, sizeof(value));

	return isc_portable_integer ((UCHAR *) value, length);
}

bool get_procedure(BurpGlobals* tdgbl)
{
   struct isc_371_struct {
          ISC_QUAD isc_372;	/* RDB$PROCEDURE_BLR */
          char  isc_373 [32];	/* RDB$PROCEDURE_NAME */
          char  isc_374 [32];	/* RDB$OWNER_NAME */
          char  isc_375 [32];	/* RDB$SECURITY_CLASS */
          ISC_QUAD isc_376;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_377;	/* RDB$PROCEDURE_SOURCE */
          short isc_378;	/* RDB$PROCEDURE_OUTPUTS */
          short isc_379;	/* gds__null_flag */
          short isc_380;	/* RDB$PROCEDURE_INPUTS */
          short isc_381;	/* gds__null_flag */
          short isc_382;	/* RDB$SYSTEM_FLAG */
          short isc_383;	/* gds__null_flag */
          short isc_384;	/* gds__null_flag */
          short isc_385;	/* gds__null_flag */
          short isc_386;	/* gds__null_flag */
   } isc_371;
   struct isc_388_struct {
          ISC_QUAD isc_389;	/* RDB$PROCEDURE_BLR */
          char  isc_390 [32];	/* RDB$PROCEDURE_NAME */
          ISC_QUAD isc_391;	/* RDB$DEBUG_INFO */
          char  isc_392 [32];	/* RDB$OWNER_NAME */
          char  isc_393 [32];	/* RDB$SECURITY_CLASS */
          ISC_QUAD isc_394;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_395;	/* RDB$PROCEDURE_SOURCE */
          short isc_396;	/* RDB$PROCEDURE_OUTPUTS */
          short isc_397;	/* gds__null_flag */
          short isc_398;	/* RDB$PROCEDURE_INPUTS */
          short isc_399;	/* gds__null_flag */
          short isc_400;	/* gds__null_flag */
          short isc_401;	/* RDB$VALID_BLR */
          short isc_402;	/* gds__null_flag */
          short isc_403;	/* RDB$SYSTEM_FLAG */
          short isc_404;	/* gds__null_flag */
          short isc_405;	/* RDB$PROCEDURE_TYPE */
          short isc_406;	/* gds__null_flag */
          short isc_407;	/* gds__null_flag */
          short isc_408;	/* gds__null_flag */
          short isc_409;	/* gds__null_flag */
   } isc_388;
/**************************************
 *
 *	g e t _ p r o c e d u r e
 *
 **************************************
 *
 * Functional description
 *	Reconstruct a stored procedure.
 *	Use the global_trans so we don't have to commit
 *	until after the indices are activated.  This
 *	will allow us to use a PLAN in a SP.
 *
 **************************************/
	att_type	attribute;
	GDS_NAME	procedure_name = "";
	TEXT		temp[GDS_NAME_LEN];
	SSHORT		l;
	scan_attr_t		scan_next_attr;

	isc_tr_handle local_trans = tdgbl->global_trans ? tdgbl->global_trans : gds_trans;

	burp_prc* procedure = (burp_prc*) BURP_alloc_zero (sizeof(burp_prc));
	procedure->prc_next = tdgbl->procedures;
	tdgbl->procedures = procedure;

	if (tdgbl->RESTORE_ods >= DB_VERSION_DDL11_1)
	{
		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_procedure_req_handle1)
			X IN RDB$PROCEDURES*/
		{
		
                if (!tdgbl->handles_get_procedure_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_procedure_req_handle1, (short) sizeof(isc_387), (char*) isc_387);
		if (tdgbl->handles_get_procedure_req_handle1)
		   {
		   isc_388.isc_389 = isc_blob_null;
		   isc_388.isc_391 = isc_blob_null;
		   isc_388.isc_394 = isc_blob_null;
		   isc_388.isc_395 = isc_blob_null;
			/*X.RDB$PROCEDURE_SOURCE.NULL*/
			isc_388.isc_409 = TRUE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_388.isc_408 = TRUE;
			/*X.RDB$SECURITY_CLASS.NULL*/
			isc_388.isc_407 = TRUE;
			/*X.RDB$OWNER_NAME.NULL*/
			isc_388.isc_406 = TRUE;
			/*X.RDB$PROCEDURE_TYPE.NULL*/
			isc_388.isc_404 = FALSE;
			/*X.RDB$PROCEDURE_TYPE*/
			isc_388.isc_405 = 0;
			/*X.RDB$SYSTEM_FLAG*/
			isc_388.isc_403 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_388.isc_402 = FALSE;
			/*X.RDB$VALID_BLR.NULL*/
			isc_388.isc_400 = TRUE;
			/*X.RDB$DEBUG_INFO.NULL*/
			isc_388.isc_399 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_procedure_name:
					l = GET_TEXT(/*X.RDB$PROCEDURE_NAME*/
						     isc_388.isc_390);
					//procedure->prc_name_length = l;
					strcpy (procedure->prc_name, /*X.RDB$PROCEDURE_NAME*/
								     isc_388.isc_390);
					MISC_terminate (/*X.RDB$PROCEDURE_NAME*/
							isc_388.isc_390, temp, l, sizeof(temp));
					BURP_verbose (195, temp);
					// msg 195 restoring stored procedure %s
					break;

				case att_procedure_description:
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_388.isc_394, true);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_388.isc_408 = FALSE;
					break;

				case att_procedure_description2:
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_388.isc_394, true);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_388.isc_408 = FALSE;
					break;

				case att_procedure_source:
					get_misc_blob (tdgbl, /*X.RDB$PROCEDURE_SOURCE*/
							      isc_388.isc_395, true);
					/*X.RDB$PROCEDURE_SOURCE.NULL*/
					isc_388.isc_409 = FALSE;
					break;

				case att_procedure_source2:
					get_source_blob (tdgbl, /*X.RDB$PROCEDURE_SOURCE*/
								isc_388.isc_395, true);
					/*X.RDB$PROCEDURE_SOURCE.NULL*/
					isc_388.isc_409 = FALSE;
					break;

				case att_procedure_blr:
					get_blr_blob (tdgbl, /*X.RDB$PROCEDURE_BLR*/
							     isc_388.isc_389, true);
					break;

				case att_procedure_security_class:
					GET_TEXT(/*X.RDB$SECURITY_CLASS*/
						 isc_388.isc_393);
					fix_security_class_name(tdgbl, /*X.RDB$SECURITY_CLASS*/
								       isc_388.isc_393, false);
					/*X.RDB$SECURITY_CLASS.NULL*/
					isc_388.isc_407 = FALSE;
					break;

				case att_procedure_owner_name:
					GET_TEXT(procedure->prc_owner);
					break;

				case att_procedure_inputs:
					/*X.RDB$PROCEDURE_INPUTS*/
					isc_388.isc_398 = (USHORT) get_numeric(tdgbl);
					if (/*X.RDB$PROCEDURE_INPUTS*/
					    isc_388.isc_398 == 0)
						/*X.RDB$PROCEDURE_INPUTS.NULL*/
						isc_388.isc_397 = TRUE;
					else
						/*X.RDB$PROCEDURE_INPUTS.NULL*/
						isc_388.isc_397 = FALSE;
					break;

				case att_procedure_outputs:
					/*X.RDB$PROCEDURE_OUTPUTS*/
					isc_388.isc_396 = (USHORT) get_numeric(tdgbl);
					break;

				case att_procedure_type:
					if (tdgbl->RESTORE_format >= 8)
						/*X.RDB$PROCEDURE_TYPE*/
						isc_388.isc_405 = (USHORT) get_numeric(tdgbl);
					else
						bad_attribute (scan_next_attr, attribute, 290);
					break;

				case att_procedure_valid_blr:
					if (tdgbl->RESTORE_format >= 8)
					{
						/*X.RDB$VALID_BLR.NULL*/
						isc_388.isc_400 = FALSE;
						/*X.RDB$VALID_BLR*/
						isc_388.isc_401 = (USHORT) get_numeric(tdgbl);
					}
					else
						bad_attribute (scan_next_attr, attribute, 290);
					break;

				case att_procedure_debug_info:
					if (tdgbl->RESTORE_format >= 8)
					{
						/*X.RDB$DEBUG_INFO.NULL*/
						isc_388.isc_399 = FALSE;
						get_misc_blob (tdgbl, /*X.RDB$DEBUG_INFO*/
								      isc_388.isc_391, true);
					}
					else
						bad_attribute (scan_next_attr, attribute, 290);
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 290);
					// msg 290 procedure
					break;
				}
			}
			strcpy (procedure_name, /*X.RDB$PROCEDURE_NAME*/
						isc_388.isc_390);
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_procedure_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 156, &isc_388, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_procedure_req_handle1)
			X IN RDB$PROCEDURES*/
		{
		
                if (!tdgbl->handles_get_procedure_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_procedure_req_handle1, (short) sizeof(isc_370), (char*) isc_370);
		if (tdgbl->handles_get_procedure_req_handle1)
		   {
		   isc_371.isc_372 = isc_blob_null;
		   isc_371.isc_376 = isc_blob_null;
		   isc_371.isc_377 = isc_blob_null;
			/*X.RDB$PROCEDURE_SOURCE.NULL*/
			isc_371.isc_386 = TRUE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_371.isc_385 = TRUE;
			/*X.RDB$SECURITY_CLASS.NULL*/
			isc_371.isc_384 = TRUE;
			/*X.RDB$OWNER_NAME.NULL*/
			isc_371.isc_383 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_371.isc_382 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_371.isc_381 = FALSE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_procedure_name:
					l = GET_TEXT(/*X.RDB$PROCEDURE_NAME*/
						     isc_371.isc_373);
					//procedure->prc_name_length = l;
					strcpy (procedure->prc_name, /*X.RDB$PROCEDURE_NAME*/
								     isc_371.isc_373);
					MISC_terminate (/*X.RDB$PROCEDURE_NAME*/
							isc_371.isc_373, temp, l, sizeof(temp));
					BURP_verbose (195, temp);
					// msg 195 restoring stored procedure %s
					break;

				case att_procedure_description:
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_371.isc_376, true);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_371.isc_385 = FALSE;
					break;

				case att_procedure_description2:
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_371.isc_376, true);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_371.isc_385 = FALSE;
					break;

				case att_procedure_source:
					get_misc_blob (tdgbl, /*X.RDB$PROCEDURE_SOURCE*/
							      isc_371.isc_377, true);
					/*X.RDB$PROCEDURE_SOURCE.NULL*/
					isc_371.isc_386 = FALSE;
					break;

				case att_procedure_source2:
					get_source_blob (tdgbl, /*X.RDB$PROCEDURE_SOURCE*/
								isc_371.isc_377, true);
					/*X.RDB$PROCEDURE_SOURCE.NULL*/
					isc_371.isc_386 = FALSE;
					break;

				case att_procedure_blr:
					get_blr_blob (tdgbl, /*X.RDB$PROCEDURE_BLR*/
							     isc_371.isc_372, true);
					break;

				case att_procedure_security_class:
					GET_TEXT(/*X.RDB$SECURITY_CLASS*/
						 isc_371.isc_375);
					fix_security_class_name(tdgbl, /*X.RDB$SECURITY_CLASS*/
								       isc_371.isc_375, false);
					/*X.RDB$SECURITY_CLASS.NULL*/
					isc_371.isc_384 = FALSE;
					break;

				case att_procedure_owner_name:
					GET_TEXT(procedure->prc_owner);
					break;

				case att_procedure_inputs:
					/*X.RDB$PROCEDURE_INPUTS*/
					isc_371.isc_380 = (USHORT) get_numeric(tdgbl);
					if (/*X.RDB$PROCEDURE_INPUTS*/
					    isc_371.isc_380 == 0)
						/*X.RDB$PROCEDURE_INPUTS.NULL*/
						isc_371.isc_379 = TRUE;
					else
						/*X.RDB$PROCEDURE_INPUTS.NULL*/
						isc_371.isc_379 = FALSE;
					break;

				case att_procedure_outputs:
					/*X.RDB$PROCEDURE_OUTPUTS*/
					isc_371.isc_378 = (USHORT) get_numeric(tdgbl);
					break;

				case att_procedure_type:
					if (tdgbl->RESTORE_format >= 8)
						get_numeric(tdgbl);
					else
						bad_attribute (scan_next_attr, attribute, 290);
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 290);
					// msg 290 procedure
					break;
				}
			}
			strcpy (procedure_name, /*X.RDB$PROCEDURE_NAME*/
						isc_371.isc_373);
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_procedure_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 138, &isc_371, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}

	// at the end of prms for a procedure is the rec_procedure_end marker

	while (get(tdgbl) == rec_procedure_prm)
		get_procedure_prm (tdgbl, procedure_name);

	return true;
}

bool get_procedure_prm (BurpGlobals* tdgbl, GDS_NAME procptr)
{
   struct isc_335_struct {
          char  isc_336 [32];	/* RDB$FIELD_SOURCE */
          char  isc_337 [32];	/* RDB$PARAMETER_NAME */
          char  isc_338 [32];	/* RDB$PROCEDURE_NAME */
          ISC_QUAD isc_339;	/* RDB$DESCRIPTION */
          short isc_340;	/* RDB$PARAMETER_NUMBER */
          short isc_341;	/* RDB$PARAMETER_TYPE */
          short isc_342;	/* gds__null_flag */
          short isc_343;	/* RDB$SYSTEM_FLAG */
          short isc_344;	/* gds__null_flag */
   } isc_335;
   struct isc_346_struct {
          char  isc_347 [32];	/* RDB$FIELD_SOURCE */
          char  isc_348 [32];	/* RDB$PARAMETER_NAME */
          char  isc_349 [32];	/* RDB$RELATION_NAME */
          char  isc_350 [32];	/* RDB$FIELD_NAME */
          ISC_QUAD isc_351;	/* RDB$DEFAULT_SOURCE */
          ISC_QUAD isc_352;	/* RDB$DEFAULT_VALUE */
          ISC_QUAD isc_353;	/* RDB$DESCRIPTION */
          char  isc_354 [32];	/* RDB$PROCEDURE_NAME */
          short isc_355;	/* RDB$PARAMETER_NUMBER */
          short isc_356;	/* RDB$PARAMETER_TYPE */
          short isc_357;	/* gds__null_flag */
          short isc_358;	/* gds__null_flag */
          short isc_359;	/* gds__null_flag */
          short isc_360;	/* RDB$PARAMETER_MECHANISM */
          short isc_361;	/* gds__null_flag */
          short isc_362;	/* RDB$NULL_FLAG */
          short isc_363;	/* gds__null_flag */
          short isc_364;	/* RDB$SYSTEM_FLAG */
          short isc_365;	/* gds__null_flag */
          short isc_366;	/* RDB$COLLATION_ID */
          short isc_367;	/* gds__null_flag */
          short isc_368;	/* gds__null_flag */
          short isc_369;	/* gds__null_flag */
   } isc_346;
/**************************************
 *
 *	g e t _ p r o c e d u r e _ p r m
 *
 **************************************
 *
 * Functional description
 *	Reconstruct stored procedure parameter.
 *	Use the global_trans so we don't have to commit
 *	until after the indices are activated.  This
 *	will allow us to use a PLAN in a SP.
 *
 **************************************/
	att_type	attribute;
	SSHORT		l;
	TEXT		temp[GDS_NAME_LEN];
	scan_attr_t		scan_next_attr;

	isc_tr_handle local_trans = tdgbl->global_trans ? tdgbl->global_trans : gds_trans;

	if (tdgbl->RESTORE_ods >= DB_VERSION_DDL11_1)
	{
		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_procedure_prm_req_handle1)
			X IN RDB$PROCEDURE_PARAMETERS*/
		{
		
                if (!tdgbl->handles_get_procedure_prm_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_procedure_prm_req_handle1, (short) sizeof(isc_345), (char*) isc_345);
		if (tdgbl->handles_get_procedure_prm_req_handle1)
		   {
		   isc_346.isc_351 = isc_blob_null;
		   isc_346.isc_352 = isc_blob_null;
		   isc_346.isc_353 = isc_blob_null;

			strcpy(/*X.RDB$PROCEDURE_NAME*/
			       isc_346.isc_354, procptr);

			/*X.RDB$DESCRIPTION.NULL*/
			isc_346.isc_369 = TRUE;
			/*X.RDB$DEFAULT_VALUE.NULL*/
			isc_346.isc_368 = TRUE;
			/*X.RDB$DEFAULT_SOURCE.NULL*/
			isc_346.isc_367 = TRUE;
			/*X.RDB$COLLATION_ID.NULL*/
			isc_346.isc_365 = TRUE;

			/*X.RDB$SYSTEM_FLAG*/
			isc_346.isc_364 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_346.isc_363 = FALSE;

			/*X.RDB$NULL_FLAG*/
			isc_346.isc_362 = FALSE;
			/*X.RDB$NULL_FLAG.NULL*/
			isc_346.isc_361 = FALSE;

			/*X.RDB$PARAMETER_MECHANISM*/
			isc_346.isc_360 = prm_mech_normal;
			/*X.RDB$PARAMETER_MECHANISM.NULL*/
			isc_346.isc_359 = FALSE;

			// DB_VERSION_DDL11_2
			/*X.RDB$FIELD_NAME.NULL*/
			isc_346.isc_358 = TRUE;
			/*X.RDB$RELATION_NAME.NULL*/
			isc_346.isc_357 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_procedureprm_name:
					l = GET_TEXT(/*X.RDB$PARAMETER_NAME*/
						     isc_346.isc_348);
					MISC_terminate (/*X.RDB$PARAMETER_NAME*/
							isc_346.isc_348, temp, l, sizeof(temp));
					BURP_verbose (196, temp);
					// msg 196 restoring parameter %s for stored procedure
					break;

				case att_procedureprm_type:
					/*X.RDB$PARAMETER_TYPE*/
					isc_346.isc_356= (USHORT) get_numeric(tdgbl);
					break;

				case att_procedureprm_number:
					/*X.RDB$PARAMETER_NUMBER*/
					isc_346.isc_355= (USHORT) get_numeric(tdgbl);
					break;

				case att_procedureprm_field_source:
					GET_TEXT(/*X.RDB$FIELD_SOURCE*/
						 isc_346.isc_347);
					break;

				case att_procedureprm_description:
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_346.isc_353, true);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_346.isc_369 = FALSE;
					break;

				case att_procedureprm_description2:
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_346.isc_353, true);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_346.isc_369 = FALSE;
					break;

				case att_procedureprm_default_value:
					if (tdgbl->RESTORE_format >= 8)
					{
						/*X.RDB$DEFAULT_VALUE.NULL*/
						isc_346.isc_368 = FALSE;
						get_blr_blob (tdgbl, /*X.RDB$DEFAULT_VALUE*/
								     isc_346.isc_352, true);
					}
					else
						bad_attribute (scan_next_attr, attribute, 291);
					break;

				case att_procedureprm_default_source:
					if (tdgbl->RESTORE_format >= 8)
					{
						/*X.RDB$DEFAULT_SOURCE.NULL*/
						isc_346.isc_367 = FALSE;
						get_source_blob (tdgbl, /*X.RDB$DEFAULT_SOURCE*/
									isc_346.isc_351, true);
					}
					else
						bad_attribute (scan_next_attr, attribute, 291);
					break;

				case att_procedureprm_collation_id:
					if (tdgbl->RESTORE_format >= 8)
					{
						/*X.RDB$COLLATION_ID.NULL*/
						isc_346.isc_365 = FALSE;
						/*X.RDB$COLLATION_ID*/
						isc_346.isc_366 = (USHORT) get_numeric(tdgbl);
					}
					else
						bad_attribute (scan_next_attr, attribute, 291);
					break;

				case att_procedureprm_null_flag:
					if (tdgbl->RESTORE_format >= 8)
						/*X.RDB$NULL_FLAG*/
						isc_346.isc_362 = (USHORT) get_numeric(tdgbl);
					else
						bad_attribute (scan_next_attr, attribute, 291);
					break;

				case att_procedureprm_mechanism:
					if (tdgbl->RESTORE_format >= 8)
						/*X.RDB$PARAMETER_MECHANISM*/
						isc_346.isc_360 = (USHORT) get_numeric(tdgbl);
					else
						bad_attribute (scan_next_attr, attribute, 291);
					break;

				// DB_VERSION_DDL11_2
				case att_procedureprm_field_name:
					/*X.RDB$FIELD_NAME.NULL*/
					isc_346.isc_358 = FALSE;
					GET_TEXT(/*X.RDB$FIELD_NAME*/
						 isc_346.isc_350);
					break;

				// DB_VERSION_DDL11_2
				case att_procedureprm_relation_name:
					/*X.RDB$RELATION_NAME.NULL*/
					isc_346.isc_357 = FALSE;
					GET_TEXT(/*X.RDB$RELATION_NAME*/
						 isc_346.isc_349);
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 291);
					// msg 291 procedure parameter
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_procedure_prm_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 214, &isc_346, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_procedure_prm_req_handle1)
			X IN RDB$PROCEDURE_PARAMETERS*/
		{
		
                if (!tdgbl->handles_get_procedure_prm_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_procedure_prm_req_handle1, (short) sizeof(isc_334), (char*) isc_334);
		if (tdgbl->handles_get_procedure_prm_req_handle1)
		   {
		   isc_335.isc_339 = isc_blob_null;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_335.isc_344 = TRUE;
			strcpy (/*X.RDB$PROCEDURE_NAME*/
				isc_335.isc_338, procptr);
			/*X.RDB$SYSTEM_FLAG*/
			isc_335.isc_343 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_335.isc_342 = FALSE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_procedureprm_name:
					l = GET_TEXT(/*X.RDB$PARAMETER_NAME*/
						     isc_335.isc_337);
					MISC_terminate (/*X.RDB$PARAMETER_NAME*/
							isc_335.isc_337, temp, l, sizeof(temp));
					BURP_verbose (196, temp);
					// msg 196 restoring parameter %s for stored procedure
					break;

				case att_procedureprm_type:
					/*X.RDB$PARAMETER_TYPE*/
					isc_335.isc_341= (USHORT) get_numeric(tdgbl);
					break;

				case att_procedureprm_number:
					/*X.RDB$PARAMETER_NUMBER*/
					isc_335.isc_340= (USHORT) get_numeric(tdgbl);
					break;

				case att_procedureprm_field_source:
					GET_TEXT(/*X.RDB$FIELD_SOURCE*/
						 isc_335.isc_336);
					break;

				case att_procedureprm_description:
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_335.isc_339, true);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_335.isc_344 = FALSE;
					break;

				case att_procedureprm_description2:
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_335.isc_339, true);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_335.isc_344 = FALSE;
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 291);
					// msg 291 procedure parameter
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_procedure_prm_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 114, &isc_335, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}

	return true;
}

bool get_ref_constraint(BurpGlobals* tdgbl)
{
   struct isc_323_struct {
          char  isc_324 [8];	/* RDB$MATCH_OPTION */
          char  isc_325 [32];	/* RDB$CONST_NAME_UQ */
          char  isc_326 [32];	/* RDB$CONSTRAINT_NAME */
          char  isc_327 [12];	/* RDB$DELETE_RULE */
          char  isc_328 [12];	/* RDB$UPDATE_RULE */
          short isc_329;	/* gds__null_flag */
          short isc_330;	/* gds__null_flag */
          short isc_331;	/* gds__null_flag */
          short isc_332;	/* gds__null_flag */
          short isc_333;	/* gds__null_flag */
   } isc_323;
/**************************************
 *
 *	g e t _ r e f _ c o n s t r a i n t
 *
 **************************************
 *
 * Functional description
 *	Restore data for referential constraints.
 *
 **************************************/
	att_type        attribute;
	scan_attr_t		scan_next_attr;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_ref_constraint_req_handle1)
		X IN RDB$REF_CONSTRAINTS*/
	{
	
        if (!tdgbl->handles_get_ref_constraint_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_ref_constraint_req_handle1, (short) sizeof(isc_322), (char*) isc_322);
	if (tdgbl->handles_get_ref_constraint_req_handle1)
	   {
		/*X.RDB$CONSTRAINT_NAME.NULL*/
		isc_323.isc_333 = TRUE;
		/*X.RDB$CONST_NAME_UQ.NULL*/
		isc_323.isc_332 = TRUE;
		/*X.RDB$MATCH_OPTION.NULL*/
		isc_323.isc_331 = TRUE;
		/*X.RDB$UPDATE_RULE.NULL*/
		isc_323.isc_330 = TRUE;
		/*X.RDB$DELETE_RULE.NULL*/
		isc_323.isc_329 = TRUE;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
				case att_ref_constraint_name:
					/*X.RDB$CONSTRAINT_NAME.NULL*/
					isc_323.isc_333 = FALSE;
					GET_TEXT(/*X.RDB$CONSTRAINT_NAME*/
						 isc_323.isc_326);
					break;

				case att_ref_unique_const_name:
					/*X.RDB$CONST_NAME_UQ.NULL*/
					isc_323.isc_332 = FALSE;
					GET_TEXT(/*X.RDB$CONST_NAME_UQ*/
						 isc_323.isc_325);
					break;

				case att_ref_match_option:
					/*X.RDB$MATCH_OPTION.NULL*/
					isc_323.isc_331 = FALSE;
					GET_TEXT(/*X.RDB$MATCH_OPTION*/
						 isc_323.isc_324);
					break;

				case att_ref_update_rule:
					/*X.RDB$UPDATE_RULE.NULL*/
					isc_323.isc_330 = FALSE;
					GET_TEXT(/*X.RDB$UPDATE_RULE*/
						 isc_323.isc_328);
					break;

				case att_ref_delete_rule:
					/*X.RDB$DELETE_RULE.NULL*/
					isc_323.isc_329 = FALSE;
					GET_TEXT(/*X.RDB$DELETE_RULE*/
						 isc_323.isc_327);
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 292);
					// msg 292 referential constraint
					break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_ref_constraint_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 106, &isc_323, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

bool get_relation(BurpGlobals* tdgbl)
{
   struct isc_279_struct {
          char  isc_280 [32];	/* RDB$RELATION_NAME */
          char  isc_281 [256];	/* RDB$EXTERNAL_FILE */
          ISC_QUAD isc_282;	/* RDB$EXTERNAL_DESCRIPTION */
          ISC_QUAD isc_283;	/* RDB$RUNTIME */
          ISC_QUAD isc_284;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_285;	/* RDB$VIEW_SOURCE */
          ISC_QUAD isc_286;	/* RDB$VIEW_BLR */
          char  isc_287 [32];	/* RDB$SECURITY_CLASS */
          short isc_288;	/* gds__null_flag */
          short isc_289;	/* gds__null_flag */
          short isc_290;	/* gds__null_flag */
          short isc_291;	/* gds__null_flag */
          short isc_292;	/* gds__null_flag */
          short isc_293;	/* gds__null_flag */
          short isc_294;	/* gds__null_flag */
          short isc_295;	/* gds__null_flag */
          short isc_296;	/* RDB$FLAGS */
          short isc_297;	/* gds__null_flag */
          short isc_298;	/* RDB$SYSTEM_FLAG */
   } isc_279;
   struct isc_300_struct {
          char  isc_301 [32];	/* RDB$RELATION_NAME */
          char  isc_302 [256];	/* RDB$EXTERNAL_FILE */
          ISC_QUAD isc_303;	/* RDB$EXTERNAL_DESCRIPTION */
          ISC_QUAD isc_304;	/* RDB$RUNTIME */
          ISC_QUAD isc_305;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_306;	/* RDB$VIEW_SOURCE */
          ISC_QUAD isc_307;	/* RDB$VIEW_BLR */
          char  isc_308 [32];	/* RDB$SECURITY_CLASS */
          short isc_309;	/* gds__null_flag */
          short isc_310;	/* RDB$RELATION_TYPE */
          short isc_311;	/* gds__null_flag */
          short isc_312;	/* gds__null_flag */
          short isc_313;	/* gds__null_flag */
          short isc_314;	/* gds__null_flag */
          short isc_315;	/* gds__null_flag */
          short isc_316;	/* gds__null_flag */
          short isc_317;	/* gds__null_flag */
          short isc_318;	/* gds__null_flag */
          short isc_319;	/* RDB$FLAGS */
          short isc_320;	/* gds__null_flag */
          short isc_321;	/* RDB$SYSTEM_FLAG */
   } isc_300;
/**************************************
 *
 *	g e t _ r e l a t i o n
 *
 **************************************
 *
 * Functional description
 *	Write relation meta-data and data.
 *	Use the default transaction for RELATIONS,
 *	and use the global_trans for VIEWS.  This
 *	enables us to have views of SP and views
 *	with plans.  Assume it is a view if it has
 *	RDB$VIEW_BLR, also assume RDB$VIEW_BLR is
 *	the first blob in the backup file.
 *
 *
 **************************************/
	TEXT		temp[GDS_NAME_LEN];
	SSHORT		l;

	SLONG		rel_flags = 0, sys_flag = fb_sysflag_user, type = rel_persistent;
	bool		rel_flags_null = true;
	ISC_QUAD	view_blr = isc_blob_null, view_src = isc_blob_null,
				rel_desc = isc_blob_null, ext_desc = isc_blob_null;
	bool		view_blr_null = true, view_src_null = true, rel_desc_null = true,
				ext_desc_null = true;

	/*BASED_ON RDB$RELATIONS.RDB$SECURITY_CLASS sec_class;*/
	char
	   sec_class[32];

	sec_class[0] = '\0';
	bool		sec_class_null = true;

	/*BASED_ON RDB$RELATIONS.RDB$EXTERNAL_FILE ext_file_name;*/
	char
	   ext_file_name[256];

	ext_file_name[0] = '\0';
	bool		ext_file_name_null = true;

	// Before starting to restore relations, commit everything that was restored
	// prior to this point. This ensures that no pending error can later affect
	// other metadata being restored.

	if (!tdgbl->relations)
	{
		BURP_verbose (68);
		// msg 68 committing meta data
		/*COMMIT*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

		/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_11);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_12);
			SQLCODE = isc_sqlcode(isc_status);
			}
	}

	// Pick up relation attributes

	burp_rel* relation = (burp_rel*) BURP_alloc_zero (sizeof(burp_rel));
	relation->rel_next = tdgbl->relations;
	tdgbl->relations = relation;

	/*
	STORE (REQUEST_HANDLE tdgbl->handles_get_relation_req_handle1)
		X IN RDB$RELATIONS
		X.RDB$SYSTEM_FLAG = 0;
		X.RDB$SYSTEM_FLAG.NULL = FALSE;
		X.RDB$FLAGS.NULL = TRUE;
		X.RDB$SECURITY_CLASS.NULL = TRUE;
		X.RDB$VIEW_BLR.NULL = TRUE;
		X.RDB$VIEW_SOURCE.NULL = TRUE;
		X.RDB$DESCRIPTION.NULL = TRUE;
		X.RDB$RUNTIME.NULL = TRUE;
		X.RDB$EXTERNAL_DESCRIPTION.NULL = TRUE;
	*/

	att_type attribute;
	scan_attr_t scan_next_attr;
	skip_init(&scan_next_attr);

	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
	{
		switch (attribute)
		{
		case att_relation_name:
			l = GET_TEXT(relation->rel_name);
			relation->rel_name_length = l;
			MISC_terminate (relation->rel_name, temp, l, sizeof(temp));
			BURP_verbose (167, temp);
			// msg 167 restoring relation %s
			break;

		case att_relation_security_class:
			sec_class_null = false;
			GET_TEXT(sec_class);
			fix_security_class_name(tdgbl, sec_class, false);
			break;

		case att_relation_view_blr:
			view_blr_null = false;
			get_blr_blob(tdgbl, view_blr, true);
			relation->rel_flags |= REL_view;
			break;

		case att_relation_view_source:
			view_src_null = false;
			get_misc_blob (tdgbl, view_src, !view_blr_null);
			break;

		case att_relation_view_source2:
			view_src_null = false;
			get_source_blob(tdgbl, view_src, !view_blr_null);
			break;

		case att_relation_description:
			rel_desc_null = false;
			get_misc_blob(tdgbl, rel_desc, !view_blr_null);
			break;

		case att_relation_description2:
			rel_desc_null = false;
			get_source_blob(tdgbl, rel_desc, !view_blr_null);
			break;

		case att_relation_flags:
			rel_flags_null = false;
			rel_flags = get_numeric(tdgbl);
			break;

		case att_relation_system_flag:
			sys_flag = get_numeric(tdgbl);
			break;

		case att_relation_ext_description:
			ext_desc_null = false;
			get_misc_blob(tdgbl, ext_desc, !view_blr_null);
			break;

		case att_relation_ext_description2:
			ext_desc_null = false;
			get_source_blob(tdgbl, ext_desc, !view_blr_null);
			break;

		case att_relation_owner_name:
			GET_TEXT(relation->rel_owner);
			break;

		case att_relation_ext_file_name:
			ext_file_name_null = false;
			GET_TEXT(ext_file_name);
			break;

		case att_relation_type:
			if (tdgbl->RESTORE_format >= 8)
				type = get_numeric(tdgbl);
			else
				bad_attribute(scan_next_attr, attribute, 111);
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 111);
			// msg 111 table
			break;
		}
	}

	// If this is a view and there is a global transaction then use it
	isc_tr_handle local_trans;
	if (view_blr_null || !tdgbl->global_trans)
		local_trans = gds_trans;
	else
		local_trans = tdgbl->global_trans;

	if (tdgbl->RESTORE_ods >= DB_VERSION_DDL11_1)
	{
		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_relation_req_handle1)
			X IN RDB$RELATIONS*/
		{
		
                if (!tdgbl->handles_get_relation_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_relation_req_handle1, (short) sizeof(isc_299), (char*) isc_299);
		if (tdgbl->handles_get_relation_req_handle1)
		   {
		   isc_300.isc_303 = isc_blob_null;
		   isc_300.isc_304 = isc_blob_null;
		   isc_300.isc_305 = isc_blob_null;
		   isc_300.isc_306 = isc_blob_null;
		   isc_300.isc_307 = isc_blob_null;

			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_300.isc_320 = FALSE;
			/*X.RDB$FLAGS.NULL*/
			isc_300.isc_318 = rel_flags_null;
			/*X.RDB$SECURITY_CLASS.NULL*/
			isc_300.isc_317 = sec_class_null;
			/*X.RDB$VIEW_BLR.NULL*/
			isc_300.isc_316 = view_blr_null;
			/*X.RDB$VIEW_SOURCE.NULL*/
			isc_300.isc_315 = view_src_null;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_300.isc_314 = rel_desc_null;
			/*X.RDB$RUNTIME.NULL*/
			isc_300.isc_313 = TRUE;
			/*X.RDB$EXTERNAL_DESCRIPTION.NULL*/
			isc_300.isc_312 = ext_desc_null;
			/*X.RDB$EXTERNAL_FILE.NULL*/
			isc_300.isc_311 = ext_file_name_null;
			/*X.RDB$RELATION_TYPE.NULL*/
			isc_300.isc_309 = FALSE;

			/*X.RDB$SYSTEM_FLAG*/
			isc_300.isc_321 = (USHORT) sys_flag;
			/*X.RDB$FLAGS*/
			isc_300.isc_319 = (USHORT) rel_flags;
			/*X.RDB$VIEW_BLR*/
			isc_300.isc_307 = view_blr;
			/*X.RDB$VIEW_SOURCE*/
			isc_300.isc_306 = view_src;
			/*X.RDB$DESCRIPTION*/
			isc_300.isc_305 = rel_desc;
			/*X.RDB$EXTERNAL_DESCRIPTION*/
			isc_300.isc_303 = ext_desc;

			strcpy(/*X.RDB$SECURITY_CLASS*/
			       isc_300.isc_308, sec_class);
			strcpy(/*X.RDB$RELATION_NAME*/
			       isc_300.isc_301, relation->rel_name);
			strcpy(/*X.RDB$EXTERNAL_FILE*/
			       isc_300.isc_302, ext_file_name);

			/*X.RDB$RELATION_TYPE*/
			isc_300.isc_310 = (USHORT) type;

		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_relation_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 386, &isc_300, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_relation_req_handle1)
			X IN RDB$RELATIONS*/
		{
		
                if (!tdgbl->handles_get_relation_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_relation_req_handle1, (short) sizeof(isc_278), (char*) isc_278);
		if (tdgbl->handles_get_relation_req_handle1)
		   {
		   isc_279.isc_282 = isc_blob_null;
		   isc_279.isc_283 = isc_blob_null;
		   isc_279.isc_284 = isc_blob_null;
		   isc_279.isc_285 = isc_blob_null;
		   isc_279.isc_286 = isc_blob_null;

			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_279.isc_297 = FALSE;
			/*X.RDB$FLAGS.NULL*/
			isc_279.isc_295 = rel_flags_null;
			/*X.RDB$SECURITY_CLASS.NULL*/
			isc_279.isc_294 = sec_class_null;
			/*X.RDB$VIEW_BLR.NULL*/
			isc_279.isc_293 = view_blr_null;
			/*X.RDB$VIEW_SOURCE.NULL*/
			isc_279.isc_292 = view_src_null;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_279.isc_291 = rel_desc_null;
			/*X.RDB$RUNTIME.NULL*/
			isc_279.isc_290 = TRUE;
			/*X.RDB$EXTERNAL_DESCRIPTION.NULL*/
			isc_279.isc_289 = ext_desc_null;
			/*X.RDB$EXTERNAL_FILE.NULL*/
			isc_279.isc_288 = ext_file_name_null;

			/*X.RDB$SYSTEM_FLAG*/
			isc_279.isc_298 = (USHORT) sys_flag;
			/*X.RDB$FLAGS*/
			isc_279.isc_296 = (USHORT) rel_flags;
			/*X.RDB$VIEW_BLR*/
			isc_279.isc_286 = view_blr;
			/*X.RDB$VIEW_SOURCE*/
			isc_279.isc_285 = view_src;
			/*X.RDB$DESCRIPTION*/
			isc_279.isc_284 = rel_desc;
			/*X.RDB$EXTERNAL_DESCRIPTION*/
			isc_279.isc_282 = ext_desc;

			strcpy(/*X.RDB$SECURITY_CLASS*/
			       isc_279.isc_287, sec_class);
			strcpy(/*X.RDB$RELATION_NAME*/
			       isc_279.isc_280, relation->rel_name);
			strcpy(/*X.RDB$EXTERNAL_FILE*/
			       isc_279.isc_281, ext_file_name);

		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_relation_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 382, &isc_279, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}

	// Eat up misc. records
	burp_fld* field = NULL;
	burp_fld** ptr = &relation->rel_fields;

	rec_type record;
	while (get_record(&record, tdgbl) != rec_data)
	{
		switch (record)
		{
		case rec_relation_end:
			if (tdgbl->gbl_sw_incremental)
			{
				BURP_verbose (170, relation->rel_name);
				// msg 170: committing metadata for relation %s
				/*COMMIT*/
				{
				isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
				// existing ON_ERROR continues past error, beck
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					BURP_print (false, 171, relation->rel_name);
					// msg 171: error committing metadata for relation %s
					BURP_print_status (false, tdgbl->status_vector);
					/*ROLLBACK;*/
					{
					isc_rollback_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
					/*ON_ERROR*/
					if (isc_status [1])
					   {
						general_on_error ();
					/*END_ERROR;*/
					   }
					}
				/*END_ERROR;*/
				   }
				}
				/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
				{
				isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_13);
				SQLCODE = isc_sqlcode(isc_status);
				}
				if (gds_status[1])
					/*EXEC SQL SET TRANSACTION;*/
					{
					isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_14);
					SQLCODE = isc_sqlcode(isc_status);
					}
			}
			return true;

		case rec_field:
			*ptr = field = get_field (tdgbl, relation);
			if (!field)
				return false;
			ptr = &field->fld_next;
			break;

		case rec_view:
			get_view(tdgbl, relation);
			break;

		default:
			BURP_error(43, true, SafeArg() << record);
			// msg 43 don't recognize record type %ld
			break;
		}
	}

	// If we fall thru, there are data records to be gotten
	// we can get here only when restoring ancient gbak'ed files where rec_data
	// was once embedded into rec_relation ... otherwise, meta commit happens
	// when we see the first rec_relation_data

	BURP_verbose (68);
	// msg 68 committing meta data

	/*COMMIT;*/
	{
	isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
	{
	isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_15);
	SQLCODE = isc_sqlcode(isc_status);
	}
	if (gds_status[1])
		/*EXEC SQL SET TRANSACTION;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_16);
		SQLCODE = isc_sqlcode(isc_status);
		}

	get_data(tdgbl, relation);

	return true;
}

bool get_rel_constraint(BurpGlobals* tdgbl)
{
   struct isc_265_struct {
          char  isc_266 [32];	/* RDB$INDEX_NAME */
          char  isc_267 [32];	/* RDB$RELATION_NAME */
          char  isc_268 [32];	/* RDB$CONSTRAINT_NAME */
          char  isc_269 [4];	/* RDB$INITIALLY_DEFERRED */
          char  isc_270 [4];	/* RDB$DEFERRABLE */
          char  isc_271 [12];	/* RDB$CONSTRAINT_TYPE */
          short isc_272;	/* gds__null_flag */
          short isc_273;	/* gds__null_flag */
          short isc_274;	/* gds__null_flag */
          short isc_275;	/* gds__null_flag */
          short isc_276;	/* gds__null_flag */
          short isc_277;	/* gds__null_flag */
   } isc_265;
/**************************************
 *
 *	g e t _ r e l _ c o n s t r a i n t
 *
 **************************************
 *
 * Functional description
 *	Restore data for relation constraints.
 *
 **************************************/
	att_type		attribute;
	scan_attr_t		scan_next_attr;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_rel_constraint_req_handle1)
		X IN RDB$RELATION_CONSTRAINTS*/
	{
	
        if (!tdgbl->handles_get_rel_constraint_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_rel_constraint_req_handle1, (short) sizeof(isc_264), (char*) isc_264);
	if (tdgbl->handles_get_rel_constraint_req_handle1)
	   {
		/*X.RDB$CONSTRAINT_NAME.NULL*/
		isc_265.isc_277 = TRUE;
		/*X.RDB$CONSTRAINT_TYPE.NULL*/
		isc_265.isc_276 = TRUE;
		/*X.RDB$RELATION_NAME.NULL*/
		isc_265.isc_275 = TRUE;
		/*X.RDB$DEFERRABLE.NULL*/
		isc_265.isc_274 = TRUE;
		/*X.RDB$INITIALLY_DEFERRED.NULL*/
		isc_265.isc_273 = TRUE;
		/*X.RDB$INDEX_NAME.NULL*/
		isc_265.isc_272 = TRUE;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
				case att_rel_constraint_name:
					/*X.RDB$CONSTRAINT_NAME.NULL*/
					isc_265.isc_277 = FALSE;
					GET_TEXT(/*X.RDB$CONSTRAINT_NAME*/
						 isc_265.isc_268);
					break;

				case att_rel_constraint_type:
					/*X.RDB$CONSTRAINT_TYPE.NULL*/
					isc_265.isc_276 = FALSE;
					GET_TEXT(/*X.RDB$CONSTRAINT_TYPE*/
						 isc_265.isc_271);
					break;

				case att_rel_constraint_rel_name:
					/*X.RDB$RELATION_NAME.NULL*/
					isc_265.isc_275 = FALSE;
					GET_TEXT(/*X.RDB$RELATION_NAME*/
						 isc_265.isc_267);
					break;

				case att_rel_constraint_defer:
					/*X.RDB$DEFERRABLE.NULL*/
					isc_265.isc_274 = FALSE;
					GET_TEXT(/*X.RDB$DEFERRABLE*/
						 isc_265.isc_270);
					break;

				case att_rel_constraint_init:
					/*X.RDB$INITIALLY_DEFERRED.NULL*/
					isc_265.isc_273 = FALSE;
					GET_TEXT(/*X.RDB$INITIALLY_DEFERRED*/
						 isc_265.isc_269);
					break;

				case att_rel_constraint_index:
					/*X.RDB$INDEX_NAME.NULL*/
					isc_265.isc_272 = FALSE;
					GET_TEXT(/*X.RDB$INDEX_NAME*/
						 isc_265.isc_266);
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 208);
					// msg 208 table constraint
					break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_rel_constraint_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 128, &isc_265, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

bool get_relation_data(BurpGlobals* tdgbl)
{
/**************************************
 *
 *	g e t _ r e l a t i o n _ d a t a
 *
 **************************************
 *
 * Functional description
 *	Restore data for a relation.  This is called when the data is
 *	standing free from the relation definition.  We first need to
 *	find the relation named.  If we can't find it, give up.
 *
 **************************************/
	/*BASED_ON RDB$RELATIONS.RDB$RELATION_NAME name;*/
	char
	   name[32];

	att_type	attribute;
	scan_attr_t		scan_next_attr;

	burp_rel* relation = NULL;

	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
	{
		switch (attribute)
		{
		case att_relation_name:
			GET_TEXT(name);
			relation = find_relation (tdgbl, name);
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 111);
			// msg 111 table
			break;
		}
	}

	if (!relation)
		BURP_error_redirect (NULL, 49);
	// msg 49 no relation name for data

	// Eat up misc. records
	rec_type record;
	get_record(&record, tdgbl);

	SLONG gen_id;

	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), true)
	{
		switch (record)
		{
		case rec_relation_end:
			return true;

		case rec_data:
			record = get_data(tdgbl, relation);
			// get_data does a GET_RECORD
			break;

		case rec_gen_id:
			gen_id = get_numeric(tdgbl);
			store_blr_gen_id (tdgbl, name, gen_id, NULL);
			get_record(&record, tdgbl);
			break;

		case rec_index:
			get_index (tdgbl, relation);
			get_record(&record, tdgbl);
			break;

		case rec_trigger:  // old style trigger
			get_trigger_old (tdgbl, relation);
			get_record(&record, tdgbl);
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 111);
			// msg 111 relation
			get_record(&record, tdgbl);
			break;
		}
	}

	return true;
}

bool get_sql_roles(BurpGlobals* tdgbl)
{
   struct isc_249_struct {
          char  isc_250 [32];	/* RDB$OWNER_NAME */
          char  isc_251 [32];	/* RDB$ROLE_NAME */
          short isc_252;	/* gds__null_flag */
          short isc_253;	/* gds__null_flag */
   } isc_249;
   struct isc_255_struct {
          ISC_QUAD isc_256;	/* RDB$DESCRIPTION */
          char  isc_257 [32];	/* RDB$OWNER_NAME */
          char  isc_258 [32];	/* RDB$ROLE_NAME */
          short isc_259;	/* gds__null_flag */
          short isc_260;	/* RDB$SYSTEM_FLAG */
          short isc_261;	/* gds__null_flag */
          short isc_262;	/* gds__null_flag */
          short isc_263;	/* gds__null_flag */
   } isc_255;
/**************************************
 *
 *	g e t _ s q l _ r o l e s
 *
 **************************************
 *
 * Functional description
 *	Restore data for SQL roles
 *
 **************************************/
	att_type		attribute;
	scan_attr_t		scan_next_attr;
	TEXT			temp[GDS_NAME_LEN];
	SSHORT			l;

	if (tdgbl->RESTORE_ods >= DB_VERSION_DDL11)
	{
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_sql_roles_req_handle1)
			X IN RDB$ROLES*/
		{
		
                if (!tdgbl->handles_get_sql_roles_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_sql_roles_req_handle1, (short) sizeof(isc_254), (char*) isc_254);
		if (tdgbl->handles_get_sql_roles_req_handle1)
		   {
		   isc_255.isc_256 = isc_blob_null;

			/*X.RDB$ROLE_NAME.NULL*/
			isc_255.isc_263 = TRUE;
			/*X.RDB$OWNER_NAME.NULL*/
			isc_255.isc_262 = TRUE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_255.isc_261 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_255.isc_260 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_255.isc_259 = FALSE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_role_name:
					/*X.RDB$ROLE_NAME.NULL*/
					isc_255.isc_263 = FALSE;
					l = GET_TEXT(/*X.RDB$ROLE_NAME*/
						     isc_255.isc_258);
					MISC_terminate (/*X.RDB$ROLE_NAME*/
							isc_255.isc_258, temp, l, sizeof(temp));
					// msg 251, restoring SQL role: %s
					BURP_verbose (251, temp);
					break;

				case att_role_owner_name:
					/*X.RDB$OWNER_NAME.NULL*/
					isc_255.isc_262 = FALSE;
					GET_TEXT(/*X.RDB$OWNER_NAME*/
						 isc_255.isc_257);
					break;

				case att_role_description:
					if (tdgbl->RESTORE_format >= 7)
					{
						get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
									isc_255.isc_256, false);
						/*X.RDB$DESCRIPTION.NULL*/
						isc_255.isc_261 = FALSE;
					}
					else
						bad_attribute (scan_next_attr, attribute, 250);
				    break;

				default:
					// msg 250 SQL role
					bad_attribute (scan_next_attr, attribute, 250);
					break;
				}
			}
		/*END_STORE*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_sql_roles_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 82, &isc_255, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else if (tdgbl->RESTORE_ods >= DB_VERSION_DDL9)
	{
		// This is the first IB version (v5, ods9) where roles appeared.
		// They remained unchanged for IB6 / FB1 and FB1.5 (ods10).
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_sql_roles_req_handle1)
			X IN RDB$ROLES*/
		{
		
                if (!tdgbl->handles_get_sql_roles_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_sql_roles_req_handle1, (short) sizeof(isc_248), (char*) isc_248);
		if (tdgbl->handles_get_sql_roles_req_handle1)
		   {

			/*X.RDB$ROLE_NAME.NULL*/
			isc_249.isc_253 = TRUE;
			/*X.RDB$OWNER_NAME.NULL*/
			isc_249.isc_252 = TRUE;
			// Here we didn't have RBD$SYSTEM_FLAG field.

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_role_name:
					/*X.RDB$ROLE_NAME.NULL*/
					isc_249.isc_253 = FALSE;
					l = GET_TEXT(/*X.RDB$ROLE_NAME*/
						     isc_249.isc_251);
					MISC_terminate (/*X.RDB$ROLE_NAME*/
							isc_249.isc_251, temp, l, sizeof(temp));
					// msg 251, restoring SQL role: %s
					BURP_verbose (251, temp);
					break;

				case att_role_owner_name:
					/*X.RDB$OWNER_NAME.NULL*/
					isc_249.isc_252 = FALSE;
					GET_TEXT(/*X.RDB$OWNER_NAME*/
						 isc_249.isc_250);
					break;

				case att_role_description:
					if (tdgbl->RESTORE_format >= 7)
						eat_blob(tdgbl);
					else
						bad_attribute (scan_next_attr, attribute, 250);
					break;

				default:
					// msg 250 SQL role
					bad_attribute (scan_next_attr, attribute, 250);
					break;
				}
			}
		/*END_STORE*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_sql_roles_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 68, &isc_249, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		// We say we support IB4, then we should skip roles.
		skip_init(&scan_next_attr);

		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_role_name:
			case att_role_owner_name:
				eat_text(tdgbl);
				break;

			case att_role_description:
				if (tdgbl->RESTORE_format >= 7)
					eat_blob(tdgbl);
				else
					bad_attribute (scan_next_attr, attribute, 250);
				break;

			default:
				// msg 250 SQL role
				bad_attribute (scan_next_attr, attribute, 250);
				break;
			}
		}
	}

	return true;
}

bool get_mapping(BurpGlobals* tdgbl)
{
/**************************************
 *
 *	g e t _ m a p p i n g
 *
 **************************************
 *
 * Functional description
 *	Restore mapping to users and roles
 *	Restricted version - only single
 *	mapping is accepted
 *
 **************************************/
	att_type		attribute;
	scan_attr_t		scan_next_attr;
	TEXT			temp[GDS_NAME_LEN];
	SSHORT			l;
	Firebird::string role, os;

	if (tdgbl->RESTORE_ods >= DB_VERSION_DDL11_1)
	{
		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
/*			case att_map_role:
				l = GET_TEXT(temp);
				role.assign(temp, l);
				break;

			case att_map_os:
				l = GET_TEXT(temp);
				os.assign(temp, l);
				break;
 */
			case att_auto_map_role:
				l = GET_TEXT(temp);
				role.assign(temp, l);
				break;

			default:
				// msg 299 name mapping
				bad_attribute (scan_next_attr, attribute, 299);
				break;
			}
		}

		if (tdgbl->RESTORE_ods < DB_VERSION_DDL11_2)
		{
			return true;	// silently skip attributes on old server
		}

		if (role != ADMIN_ROLE)
		{
			BURP_error(300, false);
			return true;
		}

		if (tdgbl->firstMap)
		{
			tdgbl->firstMap = false;
			BURP_verbose(301);
			// msg 301, restoring names mapping
		}
		BURP_verbose(298, ADMIN_ROLE);
		// msg 298, restoring map @1
		Firebird::string sql;
		sql.printf("%s ('%s', %d) %s",
			"UPDATE OR INSERT INTO RDB$ROLES(RDB$ROLE_NAME, RDB$SYSTEM_FLAG) VALUES",
			ADMIN_ROLE, ROLE_FLAG_MAY_TRUST | ROLE_FLAG_DBO,
			"MATCHING (RDB$ROLE_NAME)");
		isc_dsql_execute_immediate(tdgbl->status_vector, &tdgbl->db_handle, &tdgbl->tr_handle,
								   sql.length(), sql.c_str(), 1, NULL);
		if (tdgbl->status_vector[1])
		{
			general_on_error ();
		}
	}
	return true;
}

bool is_ascii_name (const TEXT *name, const SSHORT len)
{
/**************************************
 *
 *	i s _ a s c i i _ n a m e
 *
 **************************************
 *
 * Functional description
 *	Check if the input text is valid ASCII uppercased name
 *
 **************************************/
	SSHORT i = 0;

	while (i < len &&
			( (name[i] >= 'A' && name[i] <= 'Z') ||
			(name[i] >= '0' && name[i] <= '9') ||
			  name[i] == '_' || name[i] == '$' ) )
	{
		++i;
	}
	return (i == len);
}

bool get_security_class(BurpGlobals* tdgbl)
{
   struct isc_243_struct {
          ISC_QUAD isc_244;	/* RDB$ACL */
          char  isc_245 [32];	/* RDB$SECURITY_CLASS */
          ISC_QUAD isc_246;	/* RDB$DESCRIPTION */
          short isc_247;	/* gds__null_flag */
   } isc_243;
/**************************************
 *
 *	g e t _ s e c u r i t y _ c l a s s
 *
 **************************************
 *
 * Functional description
 *	Restore a security class record including access control list.
 *
 **************************************/
	att_type	attribute;
	TEXT		temp[GDS_NAME_LEN];
	SSHORT		l = 0;
	scan_attr_t		scan_next_attr;
	bool		is_valid_sec_class = false;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_security_class_req_handle1)
		X IN RDB$SECURITY_CLASSES*/
	{
	
        if (!tdgbl->handles_get_security_class_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_security_class_req_handle1, (short) sizeof(isc_242), (char*) isc_242);
	if (tdgbl->handles_get_security_class_req_handle1)
	   {
	   isc_243.isc_244 = isc_blob_null;
	   isc_243.isc_246 = isc_blob_null;

		/*X.RDB$DESCRIPTION.NULL*/
		isc_243.isc_247 = TRUE;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_class_security_class:
				l = GET_TEXT(/*X.RDB$SECURITY_CLASS*/
					     isc_243.isc_245);

				// Bug fix for bug_no 7299: There was a V3 bug that inserted
				// garbage security class entry when doing GBAK. In order to
				// restore the V3 gbak file with this bad security entry to
				// V4 database. We should check if the security class is a
				// valid ASCII name. If not, skip this entry by setting
				// 'is_valid_sec_class' to false.

				is_valid_sec_class = is_ascii_name(/*X.RDB$SECURITY_CLASS*/
								   isc_243.isc_245, l);
				if (!is_valid_sec_class)
				{
					MISC_terminate (/*X.RDB$SECURITY_CLASS*/
							isc_243.isc_245, temp, l, sizeof(temp));
					BURP_print (false, 234, temp);
					// msg 234   Skipped bad security class entry: %s
					break;
				}

				MISC_terminate (/*X.RDB$SECURITY_CLASS*/
						isc_243.isc_245, temp, l, sizeof(temp));
				BURP_verbose (125, temp);
				// msg 125   restoring security class %s
				break;

			case att_class_acl:
				get_misc_blob (tdgbl, /*X.RDB$ACL*/
						      isc_243.isc_244, false);
				break;

			case att_class_description:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_243.isc_247 = FALSE;
				get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
						      isc_243.isc_246, false);
				break;

			case att_class_description2:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_243.isc_247 = FALSE;
				get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							isc_243.isc_246, false);
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 131);
				// msg 131 security class
				break;
			}
		}
		// If the security class is not valid ASCII name, don't store it to the
		// database. Simply return from here and the entry is discarded.
		if (!is_valid_sec_class)
		{
			return true;
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_security_class_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 50, &isc_243, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

void get_source_blob(BurpGlobals*	tdgbl,
					 ISC_QUAD&		blob_id,
					 bool			glb_trans)
{
/**************************************
 *
 *	g e t _ s o u r c e _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Read source blob and query header attributes and copy data from
 *	input file to nice, shiney, new blob.
 *
 **************************************/
	ISC_STATUS_ARRAY	status_vector;

	SLONG length = get_numeric(tdgbl);

	// Create new blob

	UserBlob blob(status_vector);
	isc_tr_handle	local_trans;
	if (glb_trans && tdgbl->global_trans)
		local_trans = tdgbl->global_trans;
	else
		local_trans = gds_trans;

	bool ok;

	if (tdgbl->gbl_sw_fix_fss_metadata)
	{
		UCHAR bpb[15];
		UCHAR* p = bpb;

		*p++ = isc_bpb_version1;

		*p++ = isc_bpb_source_type;
		*p++ = 2;
		put_short(p, isc_blob_text);
		p += 2;
		*p++ = isc_bpb_source_interp;
		*p++ = 1;
		*p++ = tdgbl->gbl_sw_fix_fss_metadata_id;

		*p++ = isc_bpb_target_type;
		*p++ = 2;
		put_short(p, isc_blob_text);
		p += 2;
		*p++ = isc_bpb_target_interp;
		*p++ = 1;
		*p++ = CS_UNICODE_FSS;

		ok = blob.create(DB, local_trans, blob_id, p - bpb, bpb);
	}
	else
		ok = blob.create(DB, local_trans, blob_id);

	if (!ok)
	{
		BURP_error_redirect (status_vector, 37);
		// msg 37 isc_create_blob failed
	}

	// Allocate blob buffer if static buffer is too short
	BlobBuffer static_buffer;
	UCHAR* const buffer = static_buffer.getBuffer(length);

	while (length > 0)
	{
		UCHAR* p = buffer;
		while (*p++ = get(tdgbl))
			length--;
		--p;
		--length; // -- or ++ ??? p is decremented, will have to test.
		const USHORT seg_len = p - buffer;

		if (!blob.putSegment(seg_len, buffer))
		{
			BURP_error_redirect (status_vector, 38);
			// msg 38 isc_put_segment failed
		}
	}

	if (!blob.close())
		BURP_error_redirect (status_vector, 23);
		// msg 23 isc_close_blob failed
}

USHORT get_text(BurpGlobals* 	tdgbl,
				TEXT*			text,
				ULONG			length)
{
/**************************************
 *
 *	g e t _ t e x t
 *
 **************************************
 *
 * Functional description
 *	Move a text attribute to a string and fill.
 *
 **************************************/
	const ULONG l = get(tdgbl);

	if (length <= l)
		BURP_error_redirect (NULL, 46);
		// msg 46 string truncated

	if (l)
		text = (TEXT*) get_block(tdgbl, (UCHAR*) text, l);

	*text = 0;

	return (USHORT) l;
}

USHORT get_text2(BurpGlobals* tdgbl, TEXT* text, ULONG length)
{
/**************************************
 *
 *	g e t _ t e x t 2
 *
 **************************************
 *
 * Functional description
 *	Move a text attribute to a string and fill, using USHORT as length indicator.
 *
 **************************************/
	UCHAR lenstr[sizeof(USHORT)] = "";
	get_block(tdgbl, lenstr, sizeof(lenstr));
	const USHORT len = (USHORT) gds__vax_integer(lenstr, sizeof(lenstr));

	if (length <= len)
	{
		BURP_error_redirect (NULL, 46);
		// msg 46 string truncated
	}

	if (len)
		text = (TEXT*) get_block(tdgbl, (UCHAR*) text, len);

	*text = 0;

	return len;
}

bool get_trigger_old (BurpGlobals*	tdgbl,
					  burp_rel*		relation)
{
   struct isc_229_struct {
          char  isc_230 [32];	/* RDB$RELATION_NAME */
          char  isc_231 [32];	/* RDB$TRIGGER_NAME */
          ISC_QUAD isc_232;	/* RDB$TRIGGER_SOURCE */
          ISC_QUAD isc_233;	/* RDB$TRIGGER_BLR */
          ISC_QUAD isc_234;	/* RDB$DESCRIPTION */
          short isc_235;	/* RDB$TRIGGER_SEQUENCE */
          short isc_236;	/* RDB$TRIGGER_TYPE */
          short isc_237;	/* gds__null_flag */
          short isc_238;	/* RDB$SYSTEM_FLAG */
          short isc_239;	/* gds__null_flag */
          short isc_240;	/* gds__null_flag */
          short isc_241;	/* gds__null_flag */
   } isc_229;
/**************************************
 *
 *	g e t _ t r i g g e r _ o l d
 *
 **************************************
 *
 * Functional description
 *	Get a trigger definition for a relation.
 *
 **************************************/
	enum trig_t	type;
	att_type	attribute;
	TEXT		name[GDS_NAME_LEN];
	scan_attr_t		scan_next_attr;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_trigger_old_req_handle1)
		X IN RDB$TRIGGERS*/
	{
	
        if (!tdgbl->handles_get_trigger_old_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_old_req_handle1, (short) sizeof(isc_228), (char*) isc_228);
	if (tdgbl->handles_get_trigger_old_req_handle1)
	   {
	   isc_229.isc_232 = isc_blob_null;
	   isc_229.isc_233 = isc_blob_null;
	   isc_229.isc_234 = isc_blob_null;

		/*X.RDB$DESCRIPTION.NULL*/
		isc_229.isc_241 = TRUE;
		/*X.RDB$TRIGGER_BLR.NULL*/
		isc_229.isc_240 = TRUE;
		/*X.RDB$TRIGGER_SOURCE.NULL*/
		isc_229.isc_239 = TRUE;
		/*X.RDB$SYSTEM_FLAG*/
		isc_229.isc_238 = 0;
		/*X.RDB$SYSTEM_FLAG.NULL*/
		isc_229.isc_237 = FALSE;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_trig_type:
				type = (enum trig_t) get_numeric(tdgbl);
				break;

			case att_trig_blr:
				/*X.RDB$TRIGGER_BLR.NULL*/
				isc_229.isc_240 = FALSE;
				get_blr_blob (tdgbl, /*X.RDB$TRIGGER_BLR*/
						     isc_229.isc_233, false);
				break;

			case att_trig_source:
				/*X.RDB$TRIGGER_SOURCE.NULL*/
				isc_229.isc_239 = FALSE;
				get_misc_blob (tdgbl, /*X.RDB$TRIGGER_SOURCE*/
						      isc_229.isc_232, false);
				break;

			case att_trig_source2:
				/*X.RDB$TRIGGER_SOURCE.NULL*/
				isc_229.isc_239 = FALSE;
				get_source_blob (tdgbl, /*X.RDB$TRIGGER_SOURCE*/
							isc_229.isc_232, false);
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 134);
				// msg 134 trigger
				break;
			}
		}

		// fill in rest of attributes unique to new trigger format

		TEXT* p = /*X.RDB$TRIGGER_NAME*/
			  isc_229.isc_231;
		const TEXT* const end = p + 31;
		const TEXT* q = relation->rel_name;
		while (*q) {
			*p++ = *q++;
		}

		switch (type)
		{
		case trig_pre_store:
			/*X.RDB$TRIGGER_TYPE*/
			isc_229.isc_236 = TRIG_TYPE_PRE_STORE;
			q = "$STORE";
			break;
		case trig_pre_modify:
			/*X.RDB$TRIGGER_TYPE*/
			isc_229.isc_236 = TRIG_TYPE_PRE_MODIFY;
			q = "$MODIFY";
			break;
		case trig_post_erase:
			/*X.RDB$TRIGGER_TYPE*/
			isc_229.isc_236 = TRIG_TYPE_POST_ERASE;
			q = "$ERASE";
			break;
		default:
			bad_attribute (scan_next_attr, attribute, 136);
			// msg 136 trigger type
			return 0;
		}

		while (*q && p < end) {
			*p++ = *q++;
		}
		*p = 0;
		BURP_verbose (126, /*X.RDB$TRIGGER_NAME*/
				   isc_229.isc_231);
		// msg 126 restoring trigger %s
		strncpy (/*X.RDB$RELATION_NAME*/
			 isc_229.isc_230, relation->rel_name, GDS_NAME_LEN);
		strcpy (name, /*X.RDB$TRIGGER_NAME*/
			      isc_229.isc_231);
		/*X.RDB$TRIGGER_SEQUENCE*/
		isc_229.isc_235 = TRIGGER_SEQUENCE_DEFAULT;

	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_old_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 102, &isc_229, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	if (tdgbl->gbl_sw_incremental)
	{
		/*COMMIT*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
		// existing ON_ERROR continues past error, beck
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			BURP_print (false, 94, name);
			// msg 94 trigger %s is invalid
			BURP_print_status (false, tdgbl->status_vector);
			/*ROLLBACK;*/
			{
			isc_rollback_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
		/*END_ERROR;*/
		   }
		}
		/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_17);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_18);
			SQLCODE = isc_sqlcode(isc_status);
			}
	}

	return true;
}

bool get_trigger(BurpGlobals* tdgbl)
{
   struct isc_189_struct {
          char  isc_190 [32];	/* RDB$TRIGGER_NAME */
          ISC_QUAD isc_191;	/* RDB$TRIGGER_SOURCE */
          ISC_QUAD isc_192;	/* RDB$TRIGGER_BLR */
          ISC_QUAD isc_193;	/* RDB$DESCRIPTION */
          char  isc_194 [32];	/* RDB$RELATION_NAME */
          short isc_195;	/* RDB$TRIGGER_INACTIVE */
          short isc_196;	/* RDB$TRIGGER_SEQUENCE */
          short isc_197;	/* RDB$TRIGGER_TYPE */
          short isc_198;	/* gds__null_flag */
          short isc_199;	/* RDB$FLAGS */
          short isc_200;	/* gds__null_flag */
          short isc_201;	/* RDB$SYSTEM_FLAG */
          short isc_202;	/* gds__null_flag */
          short isc_203;	/* gds__null_flag */
          short isc_204;	/* gds__null_flag */
          short isc_205;	/* gds__null_flag */
   } isc_189;
   struct isc_207_struct {
          char  isc_208 [32];	/* RDB$TRIGGER_NAME */
          ISC_QUAD isc_209;	/* RDB$DEBUG_INFO */
          ISC_QUAD isc_210;	/* RDB$TRIGGER_SOURCE */
          ISC_QUAD isc_211;	/* RDB$TRIGGER_BLR */
          ISC_QUAD isc_212;	/* RDB$DESCRIPTION */
          char  isc_213 [32];	/* RDB$RELATION_NAME */
          short isc_214;	/* RDB$TRIGGER_INACTIVE */
          short isc_215;	/* RDB$TRIGGER_SEQUENCE */
          short isc_216;	/* RDB$TRIGGER_TYPE */
          short isc_217;	/* gds__null_flag */
          short isc_218;	/* gds__null_flag */
          short isc_219;	/* RDB$VALID_BLR */
          short isc_220;	/* gds__null_flag */
          short isc_221;	/* RDB$FLAGS */
          short isc_222;	/* gds__null_flag */
          short isc_223;	/* RDB$SYSTEM_FLAG */
          short isc_224;	/* gds__null_flag */
          short isc_225;	/* gds__null_flag */
          short isc_226;	/* gds__null_flag */
          short isc_227;	/* gds__null_flag */
   } isc_207;
/**************************************
 *
 *	g e t _ t r i g g e r
 *
 **************************************
 *
 * Functional description
 *	Get a trigger definition in rdb$triggers.
 *
 **************************************/
	att_type	attribute;
	/*BASED_ON RDB$TRIGGERS.RDB$TRIGGER_NAME name;*/
	char
	   name[32];

	scan_attr_t		scan_next_attr;

	isc_tr_handle local_trans = tdgbl->global_trans ? tdgbl->global_trans : gds_trans;

	if (tdgbl->RESTORE_ods >= DB_VERSION_DDL11_1)
	{
		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_trigger_req_handle1)
			X IN RDB$TRIGGERS*/
		{
		
                if (!tdgbl->handles_get_trigger_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_req_handle1, (short) sizeof(isc_206), (char*) isc_206);
		if (tdgbl->handles_get_trigger_req_handle1)
		   {
		   isc_207.isc_209 = isc_blob_null;
		   isc_207.isc_210 = isc_blob_null;
		   isc_207.isc_211 = isc_blob_null;
		   isc_207.isc_212 = isc_blob_null;

			/*X.RDB$RELATION_NAME.NULL*/
			isc_207.isc_227 = TRUE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_207.isc_226 = TRUE;
			/*X.RDB$TRIGGER_BLR.NULL*/
			isc_207.isc_225 = TRUE;
			/*X.RDB$TRIGGER_SOURCE.NULL*/
			isc_207.isc_224 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_207.isc_223 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_207.isc_222 = FALSE;
			/*X.RDB$FLAGS.NULL*/
			isc_207.isc_220 = TRUE;
			/*X.RDB$VALID_BLR.NULL*/
			isc_207.isc_218 = TRUE;
			/*X.RDB$DEBUG_INFO.NULL*/
			isc_207.isc_217 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_trig_type:
					/*X.RDB$TRIGGER_TYPE*/
					isc_207.isc_216 = (USHORT) get_numeric(tdgbl);
					break;

				case att_trig_flags:
					/*X.RDB$FLAGS*/
					isc_207.isc_221 = (USHORT) get_numeric(tdgbl);
					/*X.RDB$FLAGS.NULL*/
					isc_207.isc_220 = FALSE;
					break;

				case att_trig_blr:
					/*X.RDB$TRIGGER_BLR.NULL*/
					isc_207.isc_225 = FALSE;
					get_blr_blob (tdgbl, /*X.RDB$TRIGGER_BLR*/
							     isc_207.isc_211, true);
					break;

				case att_trig_source:
					/*X.RDB$TRIGGER_SOURCE.NULL*/
					isc_207.isc_224 = FALSE;
					get_misc_blob (tdgbl, /*X.RDB$TRIGGER_SOURCE*/
							      isc_207.isc_210, true);
					break;

				case att_trig_source2:
					/*X.RDB$TRIGGER_SOURCE.NULL*/
					isc_207.isc_224 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$TRIGGER_SOURCE*/
								isc_207.isc_210, true);
					break;

				case att_trig_name:
					GET_TEXT(/*X.RDB$TRIGGER_NAME*/
						 isc_207.isc_208);
					strcpy (name, /*X.RDB$TRIGGER_NAME*/
						      isc_207.isc_208);
					BURP_verbose (126, /*X.RDB$TRIGGER_NAME*/
							   isc_207.isc_208);
					// msg 126 restoring trigger %s
					break;

				case att_trig_relation_name:
					/*X.RDB$RELATION_NAME.NULL*/
					isc_207.isc_227 = FALSE;
					GET_TEXT(/*X.RDB$RELATION_NAME*/
						 isc_207.isc_213);
					break;

				case att_trig_sequence:
					/*X.RDB$TRIGGER_SEQUENCE*/
					isc_207.isc_215 = (USHORT) get_numeric(tdgbl);
					break;

				case att_trig_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_207.isc_226 = FALSE;
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_207.isc_212, true);
					break;

				case att_trig_description2:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_207.isc_226 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_207.isc_212, true);
					break;

				case att_trig_system_flag:
					/*X.RDB$SYSTEM_FLAG*/
					isc_207.isc_223 = (USHORT) get_numeric(tdgbl);
					/*X.RDB$SYSTEM_FLAG.NULL*/
					isc_207.isc_222 = FALSE;
					break;

				case att_trig_inactive:
					/*X.RDB$TRIGGER_INACTIVE*/
					isc_207.isc_214 = (USHORT) get_numeric(tdgbl);
					break;

				case att_trig_valid_blr:
					if (tdgbl->RESTORE_format >= 8)
					{
						/*X.RDB$VALID_BLR.NULL*/
						isc_207.isc_218 = FALSE;
						/*X.RDB$VALID_BLR*/
						isc_207.isc_219 = (USHORT) get_numeric(tdgbl);
					}
					else
						bad_attribute (scan_next_attr, attribute, 134);
					break;

				case att_trig_debug_info:
					if (tdgbl->RESTORE_format >= 8)
					{
						/*X.RDB$DEBUG_INFO.NULL*/
						isc_207.isc_217 = FALSE;
						get_misc_blob (tdgbl, /*X.RDB$DEBUG_INFO*/
								      isc_207.isc_209, true);
					}
					else
						bad_attribute (scan_next_attr, attribute, 134);
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 134);
					// msg 134 trigger
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 124, &isc_207, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_trigger_req_handle1)
			X IN RDB$TRIGGERS*/
		{
		
                if (!tdgbl->handles_get_trigger_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_req_handle1, (short) sizeof(isc_188), (char*) isc_188);
		if (tdgbl->handles_get_trigger_req_handle1)
		   {
		   isc_189.isc_191 = isc_blob_null;
		   isc_189.isc_192 = isc_blob_null;
		   isc_189.isc_193 = isc_blob_null;

			/*X.RDB$RELATION_NAME.NULL*/
			isc_189.isc_205 = TRUE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_189.isc_204 = TRUE;
			/*X.RDB$TRIGGER_BLR.NULL*/
			isc_189.isc_203 = TRUE;
			/*X.RDB$TRIGGER_SOURCE.NULL*/
			isc_189.isc_202 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_189.isc_201 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_189.isc_200 = FALSE;
			/*X.RDB$FLAGS.NULL*/
			isc_189.isc_198 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_trig_type:
					/*X.RDB$TRIGGER_TYPE*/
					isc_189.isc_197 = (USHORT) get_numeric(tdgbl);
					break;

				case att_trig_flags:
					/*X.RDB$FLAGS*/
					isc_189.isc_199 = (USHORT) get_numeric(tdgbl);
					/*X.RDB$FLAGS.NULL*/
					isc_189.isc_198 = FALSE;
					break;

				case att_trig_blr:
					/*X.RDB$TRIGGER_BLR.NULL*/
					isc_189.isc_203 = FALSE;
					get_blr_blob (tdgbl, /*X.RDB$TRIGGER_BLR*/
							     isc_189.isc_192, true);
					break;

				case att_trig_source:
					/*X.RDB$TRIGGER_SOURCE.NULL*/
					isc_189.isc_202 = FALSE;
					get_misc_blob (tdgbl, /*X.RDB$TRIGGER_SOURCE*/
							      isc_189.isc_191, true);
					break;

				case att_trig_source2:
					/*X.RDB$TRIGGER_SOURCE.NULL*/
					isc_189.isc_202 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$TRIGGER_SOURCE*/
								isc_189.isc_191, true);
					break;

				case att_trig_name:
					GET_TEXT(/*X.RDB$TRIGGER_NAME*/
						 isc_189.isc_190);
					strcpy (name, /*X.RDB$TRIGGER_NAME*/
						      isc_189.isc_190);
					BURP_verbose (126, /*X.RDB$TRIGGER_NAME*/
							   isc_189.isc_190);
					// msg 126 restoring trigger %s
					break;

				case att_trig_relation_name:
					/*X.RDB$RELATION_NAME.NULL*/
					isc_189.isc_205 = FALSE;
					GET_TEXT(/*X.RDB$RELATION_NAME*/
						 isc_189.isc_194);
					break;

				case att_trig_sequence:
					/*X.RDB$TRIGGER_SEQUENCE*/
					isc_189.isc_196 = (USHORT) get_numeric(tdgbl);
					break;

				case att_trig_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_189.isc_204 = FALSE;
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_189.isc_193, true);
					break;

				case att_trig_description2:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_189.isc_204 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_189.isc_193, true);
					break;

				case att_trig_system_flag:
					/*X.RDB$SYSTEM_FLAG*/
					isc_189.isc_201 = (USHORT) get_numeric(tdgbl);
					/*X.RDB$SYSTEM_FLAG.NULL*/
					isc_189.isc_200 = FALSE;
					break;

				case att_trig_inactive:
					/*X.RDB$TRIGGER_INACTIVE*/
					isc_189.isc_195 = (USHORT) get_numeric(tdgbl);
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 134);
					// msg 134 trigger
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 110, &isc_189, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}

	if (tdgbl->gbl_sw_incremental)
	{
		/*COMMIT*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
		// existing ON_ERROR continues past error, beck
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			BURP_print (false, 94, name);
			// msg 94 trigger %s is invalid
			BURP_print_status (false, tdgbl->status_vector);
			/*ROLLBACK;*/
			{
			isc_rollback_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
		/*END_ERROR;*/
		   }
		}
		/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_19);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_20);
			SQLCODE = isc_sqlcode(isc_status);
			}
	}

	return true;
}

bool get_trigger_message(BurpGlobals* tdgbl)
{
   struct isc_179_struct {
          char  isc_180 [1024];	/* RDB$MESSAGE */
          char  isc_181 [32];	/* RDB$TRIGGER_NAME */
          short isc_182;	/* RDB$MESSAGE_NUMBER */
   } isc_179;
   struct isc_186_struct {
          short isc_187;	/* isc_utility */
   } isc_186;
   struct isc_184_struct {
          char  isc_185 [32];	/* RDB$TRIGGER_NAME */
   } isc_184;
/**************************************
 *
 *	g e t _ t r i g g e r _ m e s s a g e
 *
 **************************************
 *
 * Functional description
 *	Get a trigger message text.
 *
 **************************************/
	att_type	attribute;
	scan_attr_t		scan_next_attr;

	/*BASED_ON RDB$TRIGGER_MESSAGES.RDB$TRIGGER_NAME name;*/
	char
	   name[32];

	/*BASED_ON RDB$TRIGGER_MESSAGES.RDB$MESSAGE_NUMBER number*/
	short
	   number
 = -1;
	/*BASED_ON RDB$TRIGGER_MESSAGES.RDB$MESSAGE message;*/
	char
	   message[1024];


	bool sysflag = false;
	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
	{
		switch (attribute)
		{
		case att_trigmsg_name:
			GET_TEXT(name);
			sysflag = false;
			/*FOR (REQUEST_HANDLE tdgbl->handles_get_trigger_message_req_handle1)
				FIRST 1 X IN RDB$TRIGGERS WITH
				X.RDB$SYSTEM_FLAG EQ 1 AND X.RDB$TRIGGER_NAME EQ name*/
			{
                        if (!tdgbl->handles_get_trigger_message_req_handle1)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_message_req_handle1, (short) sizeof(isc_183), (char*) isc_183);
			isc_vtov ((const char*) name, (char*) isc_184.isc_185, 32);
			if (tdgbl->handles_get_trigger_message_req_handle1)
			   {
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_message_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_184, (short) 0);
			   }
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_message_req_handle1, (short) 1, (short) 2, &isc_186, (short) 0);
			   if (!isc_186.isc_187 || isc_status [1]) break;
				sysflag = true;
			/*END_FOR;*/
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
			BURP_verbose (127, name);
			// msg 127 restoring trigger message for %s
			break;

		case att_trigmsg_number:
			number = (USHORT) get_numeric(tdgbl);
			break;

		case att_trigmsg_text:
			GET_TEXT(message);
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 135);
			// msg 135  trigger message
			break;
		}
	}

	if (sysflag)
		return true;

	// Versions prior to FB2.0 don't support a field longer than varchar(78).
	if (tdgbl->RESTORE_ods < DB_VERSION_DDL11)
		message[78] = 0;

	isc_tr_handle local_trans = tdgbl->global_trans ? tdgbl->global_trans : gds_trans;

	/*STORE (TRANSACTION_HANDLE local_trans
			REQUEST_HANDLE tdgbl->handles_get_trigger_message_req_handle2)
		X IN RDB$TRIGGER_MESSAGES*/
	{
	
        if (!tdgbl->handles_get_trigger_message_req_handle2)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_message_req_handle2, (short) sizeof(isc_178), (char*) isc_178);
	if (tdgbl->handles_get_trigger_message_req_handle2)
	   {
		strcpy (/*X.RDB$TRIGGER_NAME*/
			isc_179.isc_181, name);
		/*X.RDB$MESSAGE_NUMBER*/
		isc_179.isc_182 = number;
		strcpy (/*X.RDB$MESSAGE*/
			isc_179.isc_180, message);
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_message_req_handle2, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 1058, &isc_179, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	if (tdgbl->gbl_sw_incremental)
	{
		/*COMMIT*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
		// existing ON_ERROR continues past error, beck
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			BURP_print (false, 94, name);
			// msg 94 trigger %s is invalid
			BURP_print_status (false, tdgbl->status_vector);
			/*ROLLBACK;*/
			{
			isc_rollback_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
		/*END_ERROR;*/
		   }
		}
		/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_21);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_22);
			SQLCODE = isc_sqlcode(isc_status);
			}
	}

	return true;
}

bool get_type(BurpGlobals* tdgbl)
{
   struct isc_170_struct {
          char  isc_171 [32];	/* RDB$FIELD_NAME */
          char  isc_172 [32];	/* RDB$TYPE_NAME */
          ISC_QUAD isc_173;	/* RDB$DESCRIPTION */
          short isc_174;	/* RDB$TYPE */
          short isc_175;	/* gds__null_flag */
          short isc_176;	/* RDB$SYSTEM_FLAG */
          short isc_177;	/* gds__null_flag */
   } isc_170;
/**************************************
 *
 *	g e t _ t y p e
 *
 **************************************
 *
 * Functional description
 *	Get a type definition in rdb$types.
 *
 **************************************/
	att_type	attribute;
	ULONG		l;
	TEXT		temp[GDS_NAME_LEN];
	scan_attr_t		scan_next_attr;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_type_req_handle1)
		X IN RDB$TYPES*/
	{
	
        if (!tdgbl->handles_get_type_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_type_req_handle1, (short) sizeof(isc_169), (char*) isc_169);
	if (tdgbl->handles_get_type_req_handle1)
	   {
	   isc_170.isc_173 = isc_blob_null;

		/*X.RDB$DESCRIPTION.NULL*/
		isc_170.isc_177 = TRUE;
		/*X.RDB$SYSTEM_FLAG*/
		isc_170.isc_176 = 0;
		/*X.RDB$SYSTEM_FLAG.NULL*/
		isc_170.isc_175 = FALSE;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_type_name:
				l = GET_TEXT(/*X.RDB$TYPE_NAME*/
					     isc_170.isc_172);
				break;

			case att_type_type:
				/*X.RDB$TYPE*/
				isc_170.isc_174 = (USHORT) get_numeric(tdgbl);
				break;

			case att_type_field_name:
				GET_TEXT(/*X.RDB$FIELD_NAME*/
					 isc_170.isc_171);
				break;

			case att_type_description:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_170.isc_177 = FALSE;
				get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
						      isc_170.isc_173, false);
				break;

			case att_type_description2:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_170.isc_177 = FALSE;
				get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							isc_170.isc_173, false);
				break;

			case att_type_system_flag:
				/*X.RDB$SYSTEM_FLAG*/
				isc_170.isc_176 = (USHORT) get_numeric(tdgbl);
				/*X.RDB$SYSTEM_FLAG.NULL*/
				isc_170.isc_175 = FALSE;
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 293);
				// msg 293 type (in RDB$TYPES)
				break;
			}
		}

		MISC_terminate (/*X.RDB$TYPE_NAME*/
				isc_170.isc_172, temp, l, sizeof(temp));
		BURP_verbose (128, SafeArg() << temp << /*X.RDB$FIELD_NAME*/
							isc_170.isc_171);
		// msg 128  restoring type %s for field %s

	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_type_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 80, &isc_170, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

bool get_user_privilege(BurpGlobals* tdgbl)
{
   struct isc_156_struct {
          char  isc_157 [32];	/* RDB$RELATION_NAME */
          char  isc_158 [32];	/* RDB$GRANTOR */
          char  isc_159 [32];	/* RDB$USER */
          char  isc_160 [32];	/* RDB$FIELD_NAME */
          short isc_161;	/* gds__null_flag */
          short isc_162;	/* RDB$USER_TYPE */
          short isc_163;	/* gds__null_flag */
          short isc_164;	/* RDB$GRANT_OPTION */
          short isc_165;	/* gds__null_flag */
          short isc_166;	/* RDB$OBJECT_TYPE */
          short isc_167;	/* gds__null_flag */
          char  isc_168 [7];	/* RDB$PRIVILEGE */
   } isc_156;
/**************************************
 *
 *	g e t _ u s e r _ p r i v i l e g e
 *
 **************************************
 *
 * Functional description
 *	Get a user privilege.
 *	Get next interesting user privilege.
 *
 **************************************/
	att_type	attribute;
	scan_attr_t		scan_next_attr;
	USHORT		flags = 0;

	/*BASED_ON RDB$USER_PRIVILEGES.RDB$USER user;*/
	char
	   user[32];

	/*BASED_ON RDB$USER_PRIVILEGES.RDB$GRANTOR grantor;*/
	char
	   grantor[32];

	/*BASED_ON RDB$USER_PRIVILEGES.RDB$PRIVILEGE privilege;*/
	char
	   privilege[7];

	/*BASED_ON RDB$USER_PRIVILEGES.RDB$GRANT_OPTION grant_option*/
	short
	   grant_option
 = 0;
	/*BASED_ON RDB$USER_PRIVILEGES.RDB$RELATION_NAME relation_name;*/
	char
	   relation_name[32];

	/*BASED_ON RDB$USER_PRIVILEGES.RDB$FIELD_NAME field_name;*/
	char
	   field_name[32];

	/*BASED_ON RDB$USER_PRIVILEGES.RDB$USER_TYPE user_type;*/
	short
	   user_type;

	/*BASED_ON RDB$USER_PRIVILEGES.RDB$OBJECT_TYPE object_type;*/
	short
	   object_type;


	user_type = obj_user;
	object_type = obj_relation;

	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
	{
		switch (attribute)
		{
		case att_priv_user:
			// default USER_TYPE to USER
			flags |= USER_PRIV_USER;
			GET_TEXT(user);
			BURP_verbose (123, user);
			// msg 123 restoring privilege for user %s
			break;

		case att_priv_grantor:
			flags |= USER_PRIV_GRANTOR;
			GET_TEXT(grantor);
			break;

		case att_priv_privilege:
			flags |= USER_PRIV_PRIVILEGE;
			GET_TEXT(privilege);
			break;

		case att_priv_grant_option:
			flags |= USER_PRIV_GRANT_OPTION;
			grant_option = (USHORT) get_numeric(tdgbl);
			break;

		case att_priv_object_name:
			flags |= USER_PRIV_OBJECT_NAME;
			// default OBJECT_TYPE to RELATION
			GET_TEXT(relation_name);
			break;

		case att_priv_field_name:
			flags |= USER_PRIV_FIELD_NAME;
			GET_TEXT(field_name);
			break;

		case att_priv_user_type:
			flags |= USER_PRIV_USER_TYPE;
			user_type = (USHORT) get_numeric(tdgbl);
			break;

		case att_priv_obj_type:
			flags |= USER_PRIV_OBJECT_TYPE;
			object_type = (USHORT) get_numeric(tdgbl);
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 105);
			// msg 105 privilege
			break;
		}
	}

	// Check if object exists
	isc_tr_handle	local_trans = 0;
	bool exists = false;
	switch (object_type)
	{
	case obj_procedure:
		{
		for (const burp_prc* proc = tdgbl->procedures; proc; proc = proc->prc_next)
			if (!strcmp(proc->prc_name, relation_name))
			{
				exists = true;
				local_trans = tdgbl->global_trans ? tdgbl->global_trans : gds_trans;
				break;
			}
		}
		break;

	case obj_relation:
		{
		for (const burp_rel* rel = tdgbl->relations; rel; rel = rel->rel_next)
			if (!strcmp(rel->rel_name, relation_name))
			{
				exists = true;
				if (rel->rel_flags & REL_view)
					local_trans = tdgbl->global_trans ? tdgbl->global_trans : gds_trans;
			break;
			}
		}
		break;

		default:
			exists = true;
			break;
	}

	if (tdgbl->RESTORE_ods <= DB_VERSION_DDL8)
	{
		// Discard roles for IB4.
		if (user_type == obj_sql_role || object_type == obj_sql_role)
			exists = false;
	}

	if (exists)
	{
		if (!local_trans)
			local_trans = gds_trans;

		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_user_privilege_req_handle1)
			X IN RDB$USER_PRIVILEGES*/
		{
		
                if (!tdgbl->handles_get_user_privilege_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_user_privilege_req_handle1, (short) sizeof(isc_155), (char*) isc_155);
		if (tdgbl->handles_get_user_privilege_req_handle1)
		   {

			/*X.RDB$FIELD_NAME.NULL*/
			isc_156.isc_167 = TRUE;
			/*X.RDB$OBJECT_TYPE.NULL*/
			isc_156.isc_165 = TRUE;

			if (flags & USER_PRIV_USER)
				strcpy (/*X.RDB$USER*/
					isc_156.isc_159, user);

			if (flags & USER_PRIV_GRANTOR)
				strcpy (/*X.RDB$GRANTOR*/
					isc_156.isc_158, grantor);

			if (flags & USER_PRIV_PRIVILEGE)
				strcpy (/*X.RDB$PRIVILEGE*/
					isc_156.isc_168, privilege);

			if (flags & USER_PRIV_GRANT_OPTION)
			{
				/*X.RDB$GRANT_OPTION*/
				isc_156.isc_164 = grant_option;
					if (grant_option == 0)
						/*X.RDB$GRANT_OPTION.NULL*/
						isc_156.isc_163 = TRUE;
					else
						/*X.RDB$GRANT_OPTION.NULL*/
						isc_156.isc_163 = FALSE;
			}

			if (flags & USER_PRIV_OBJECT_NAME)
				strcpy (/*X.RDB$RELATION_NAME*/
					isc_156.isc_157, relation_name);

			if (flags & USER_PRIV_FIELD_NAME)
			{
				/*X.RDB$FIELD_NAME.NULL*/
				isc_156.isc_167 = FALSE;
				strcpy (/*X.RDB$FIELD_NAME*/
					isc_156.isc_160, field_name);
			}

			// USER_TYPE & OBJECT_TYPE are fields that did not exist before
			// V4.0. So, we have to reconstruct them and initialize them to
			// reasonable values. If they existed before then user_type and
			// object_type contain the proper values. If they didn't exist
			// then user_type and object_type contain the reasonable default
			// values.

			/*X.RDB$USER_TYPE.NULL*/
			isc_156.isc_161 = FALSE;
			/*X.RDB$USER_TYPE*/
			isc_156.isc_162 = user_type;

			/*X.RDB$OBJECT_TYPE.NULL*/
			isc_156.isc_165 = FALSE;
			/*X.RDB$OBJECT_TYPE*/
			isc_156.isc_166 = object_type;



			// If OBJECT_TYPE didn't exist before and we have a field level
			// user privileges, then use obj_field instead.

			// NOTE: Scanning the V4.0 code base, obj_field has never been
			// used at all. The following code should be uncommented
			// in case we ever introduce obj_field to the picture.

/***********************************************************
			if ( !(flags & USER_PRIV_OBJECT_TYPE) )
			{
				if ( flags & USER_PRIV_FIELD_NAME )
				{
					X.RDB$OBJECT_TYPE = obj_field;
				}
			}
***********************************************************/

		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_user_privilege_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 149, &isc_156, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}

	return true;
}

bool get_view(BurpGlobals*	tdgbl,
			  burp_rel*		relation)
{
   struct isc_150_struct {
          char  isc_151 [256];	/* RDB$CONTEXT_NAME */
          char  isc_152 [32];	/* RDB$RELATION_NAME */
          char  isc_153 [32];	/* RDB$VIEW_NAME */
          short isc_154;	/* RDB$VIEW_CONTEXT */
   } isc_150;
/**************************************
 *
 *	g e t _ v i e w
 *
 **************************************
 *
 * Functional description
 *	Store a record in RDB$VIEW_RELATIONS.
 *
 **************************************/
	att_type	attribute;
	scan_attr_t		scan_next_attr;

	// If there is a global transaction then use it

	isc_tr_handle local_trans = tdgbl->global_trans ? tdgbl->global_trans : gds_trans;

	/*STORE (TRANSACTION_HANDLE local_trans
			REQUEST_HANDLE tdgbl->handles_get_view_req_handle1)
		X IN RDB$VIEW_RELATIONS*/
	{
	
        if (!tdgbl->handles_get_view_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_view_req_handle1, (short) sizeof(isc_149), (char*) isc_149);
	if (tdgbl->handles_get_view_req_handle1)
	   {
		strcpy (/*X.RDB$VIEW_NAME*/
			isc_150.isc_153, relation->rel_name);

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_view_relation_name:
				GET_TEXT(/*X.RDB$RELATION_NAME*/
					 isc_150.isc_152);
				break;

			case att_view_context_name:
				GET_TEXT(/*X.RDB$CONTEXT_NAME*/
					 isc_150.isc_151);
				if (tdgbl->RESTORE_ods < DB_VERSION_DDL11_2) {
					/*X.RDB$CONTEXT_NAME*/
					isc_150.isc_151[31] = 0;
				}
				break;

			case att_view_context_id:
				/*X.RDB$VIEW_CONTEXT*/
				isc_150.isc_154 = (USHORT) get_numeric(tdgbl);
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 140);
				// msg 140 view
				break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_view_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 322, &isc_150, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

void ignore_array(BurpGlobals*	tdgbl,
				  burp_rel*		relation)
{
/**************************************
 *
 *	i g n o r e _ a r r a y
 *
 **************************************
 *
 * Functional description
 *	Ignore data from input file, like a
 *	dummy get_array().
 *
 **************************************/
	burp_fld* field = NULL;
	att_type attribute;
	SLONG* range;
	const SLONG* end_ranges;
	USHORT field_number;
	scan_attr_t scan_next_attr;

	// Pick up attributes

	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_blob_data)
	{
		switch (attribute)
		{
		case att_blob_field_number:
			field_number = (USHORT) get_numeric(tdgbl);
			for (field = relation->rel_fields; field; field = field->fld_next) {
				if (field->fld_number == field_number)
					break;
			}
			if (!field)
				BURP_error_redirect (NULL, 36);
				// msg 36 Can't find field for blob
			break;

		case att_array_dimensions:
			field->fld_dimensions = (SSHORT) get_numeric(tdgbl);
			end_ranges = field->fld_ranges + 2 * field->fld_dimensions;
			for (range = field->fld_ranges; range < end_ranges; range += 2)
			{
				if (get_attribute(&attribute, tdgbl) != att_array_range_low)
					bad_attribute (scan_next_attr, attribute, 58);
					// msg 58 array
				else
					range[0] = get_numeric(tdgbl);
				if (get_attribute(&attribute, tdgbl) != att_array_range_high)
					bad_attribute (scan_next_attr, attribute, 58);
					// msg 58 array
				else
					range[1] = get_numeric(tdgbl);
			}
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 58);
			// msg 58 array
			break;
		}
	}

	SLONG length = get(tdgbl);
	length |= get(tdgbl) << 8;
	length |= get(tdgbl) << 16;
	length |= get(tdgbl) << 24;

	SLONG lcount = 0;
	if (tdgbl->gbl_sw_transportable)
	{
		if (get_attribute(&attribute, tdgbl) != att_xdr_array)
			BURP_error_redirect (NULL, 55);
			// msg 55 Expected XDR record length
		else
		{
			lcount = get(tdgbl);
			lcount |= get(tdgbl) << 8;
			lcount |= get(tdgbl) << 16;
			lcount |= get(tdgbl) << 24;
		}
	}
	else
	{
		lcount = length;
	}

	if (lcount)
		get_skip(tdgbl, lcount);
}

void ignore_blob(BurpGlobals* tdgbl)
{
/**************************************
 *
 *	i g n o r e _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Skip over blob data records.
 *
 **************************************/
	att_type	attribute;
	scan_attr_t		scan_next_attr;

	// Pick up attributes

	SLONG segments = 0;

	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_blob_data)
	{
		switch (attribute)
		{
		case att_blob_field_number:
			get_numeric(tdgbl);
			break;

		case att_blob_max_segment:
			get_numeric(tdgbl);
			break;

		case att_blob_number_segments:
			segments = get_numeric(tdgbl);
			break;

		case att_blob_type:
			get_numeric(tdgbl);
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 64);
			// msg 64 blob
			break;
		}
	}

	// Eat up blob segments

	while (--segments >= 0)
	{
		USHORT length = get(tdgbl);
		length |= get(tdgbl) << 8;
		if (length)
			get_skip(tdgbl, length);
	}
}

rec_type ignore_data(BurpGlobals*	tdgbl,
					 burp_rel*		relation)
{
/**************************************
 *
 *	i g n o r e _ d a t a
 *
 **************************************
 *
 * Functional description
 *	Ignore data records for a relation.
 *
 **************************************/
	ULONG records = 0;
	rec_type record;

	while (true)
	{
		if (get(tdgbl) != att_data_length)
			BURP_error_redirect (NULL, 39);
			// msg 39 expected record length
		USHORT l = (USHORT) get_numeric(tdgbl);
		if (tdgbl->gbl_sw_transportable)
		{
			if (get(tdgbl) != att_xdr_length)
				BURP_error_redirect (NULL, 55);
				// msg 55 Expected XDR record length
			else
				l = (USHORT) get_numeric(tdgbl);
		}
		if (get(tdgbl) != att_data_data)
			BURP_error_redirect (NULL, 41);
			// msg 41 expected data attribute
		if (l) {
			if (tdgbl->gbl_sw_compress)
			{
				UCHAR* buffer = (UCHAR*) BURP_alloc (l);
				decompress (tdgbl, buffer, l);
				BURP_free (buffer);
			}
			else
				get_skip(tdgbl, l);
		}
		++records;

		while (get_record(&record, tdgbl))
		{
			if (record == rec_blob)
				ignore_blob(tdgbl);
			else if (record == rec_array)
				ignore_array (tdgbl, relation);
			else
				break;
		}
		if (record != rec_data)
			break;
	}

	BURP_verbose (106, SafeArg() << records);
	// msg 106 %ld records ignored

	return record;
}

void realign(BurpGlobals*		tdgbl,
			 UCHAR*				buffer,
			 const burp_rel*	relation)
{
/**************************************
 *
 *	r e a l i g n
 *
 **************************************
 *
 * Functional description
 *	Miserable input record is misaligned.
 *	Shuffle fields around.  N.B. this one
 *	only works if the old buffer is longer
 *	than the new.
 *
 **************************************/
	UCHAR* p = 0;
	const UCHAR* q = 0;

	for (const burp_fld* field = relation->rel_fields; field; field = field->fld_next)
	{
		if (field->fld_flags & FLD_computed)
			continue;

		p = buffer + field->fld_offset;
		q = buffer + field->fld_old_offset;
		USHORT l = field->fld_length;

		// CVC: This code assumes fld_offset < fld_old_offset,
		// why not use memmove() instead?

		// Beware of overlaps here - don't use memcpy
		while (l--) {
			*p++ = *q++;
		}

		if (field->fld_type == blr_varying)
		{
			*p++ = *q++;
			*p++ = *q++;
		}
	}

	// If this is format version 2 or greater, build fields for null flags

	if (tdgbl->RESTORE_format >= 2)
	{
		for (const burp_fld* field = relation->rel_fields; field; field = field->fld_next)
		{
			if (field->fld_flags & FLD_computed)
				continue;
			p = buffer + FB_ALIGN(p - buffer, sizeof(SSHORT));
			q = buffer + FB_ALIGN(q - buffer, sizeof(SSHORT));
			*p++ = *q++;
			*p++ = *q++;
		}
	}
}

#ifdef sparc
USHORT recompute_length(BurpGlobals*	tdgbl,
						burp_rel*		relation)
{
/**************************************
 *
 *	r e c o m p u t e _ l e n g t h
 *
 **************************************
 *
 * Functional description
 *	Recompute length of a record using an old
 *	alignment if there is one.  At the moment,
 *	only SPARC has one.
 *
 **************************************/

	ULONG	offset = 0; // there was garbage, possibly nobody uses sparc define?
	const SSHORT* alignments = old_sparcs;

	for (burp_fld* field = relation->rel_fields; field; field = field->fld_next)
	{
		if (field->fld_flags & FLD_computed)
			continue;
		ULONG length = field->fld_length;
		// ULONG alignment = 4; useless, see assignment below

		// arrays are of various fld_types but are really blobs

		ULONG dtype = field->fld_type;

		if (field->fld_flags & FLD_array)
		{
			dtype = blr_blob;
			length = 8;
		}

		const ULONG alignment = alignments[gds_cvt_blr_dtype[field->fld_type]];
		if (dtype == blr_varying)
			length += sizeof(USHORT);

		if (alignment)
			offset = FB_ALIGN(offset, alignment);
		field->fld_old_offset = offset;
		offset += length;
	}

	// If this is format version 2, build fields for null flags

	if (tdgbl->RESTORE_format >= 2)
	{
		for (const burp_fld* field = relation->rel_fields; field; field = field->fld_next)
		{
			if (field->fld_flags & FLD_computed)
				continue;
			offset = FB_ALIGN(offset, sizeof(SSHORT));
			offset += sizeof(SSHORT);
		}
	}

	return offset;
}
#endif

bool restore(BurpGlobals*	tdgbl,
			 const TEXT*	file_name,
			 const TEXT*	database_name)
{
   struct isc_101_struct {
          short isc_102;	/* isc_utility */
   } isc_101;
   struct isc_98_struct {
          double isc_99;	/* RDB$STATISTICS */
          short isc_100;	/* gds__null_flag */
   } isc_98;
   struct isc_94_struct {
          double isc_95;	/* RDB$STATISTICS */
          short isc_96;	/* isc_utility */
          short isc_97;	/* gds__null_flag */
   } isc_94;
   struct isc_108_struct {
          short isc_109;	/* isc_utility */
   } isc_108;
   struct isc_106_struct {
          short isc_107;	/* isc_utility */
   } isc_106;
   struct isc_104_struct {
          short isc_105;	/* isc_utility */
   } isc_104;
   struct isc_119_struct {
          short isc_120;	/* isc_utility */
   } isc_119;
   struct isc_116_struct {
          char  isc_117 [32];	/* RDB$DEFAULT_COLLATE_NAME */
          short isc_118;	/* gds__null_flag */
   } isc_116;
   struct isc_111_struct {
          char  isc_112 [32];	/* RDB$DEFAULT_COLLATE_NAME */
          char  isc_113 [32];	/* RDB$CHARACTER_SET_NAME */
          short isc_114;	/* isc_utility */
          short isc_115;	/* gds__null_flag */
   } isc_111;
   struct isc_124_struct {
          short isc_125;	/* isc_utility */
          short isc_126;	/* RDB$CHARACTER_SET_ID */
   } isc_124;
   struct isc_122_struct {
          char  isc_123 [32];	/* RDB$CHARACTER_SET_NAME */
   } isc_122;
   struct isc_130_struct {
          short isc_131;	/* isc_utility */
          short isc_132;	/* RDB$CHARACTER_SET_ID */
   } isc_130;
   struct isc_128_struct {
          char  isc_129 [32];	/* RDB$CHARACTER_SET_NAME */
   } isc_128;
   struct isc_139_struct {
          short isc_140;	/* isc_utility */
   } isc_139;
   struct isc_137_struct {
          char  isc_138 [32];	/* RDB$CHARACTER_SET_NAME */
   } isc_137;
   struct isc_134_struct {
          char  isc_135 [32];	/* RDB$CHARACTER_SET_NAME */
          short isc_136;	/* isc_utility */
   } isc_134;
   struct isc_147_struct {
          short isc_148;	/* isc_utility */
   } isc_147;
   struct isc_145_struct {
          ISC_QUAD isc_146;	/* RDB$DESCRIPTION */
   } isc_145;
   struct isc_142_struct {
          ISC_QUAD isc_143;	/* RDB$DESCRIPTION */
          short isc_144;	/* isc_utility */
   } isc_142;
/**************************************
 *
 *	r e s t o r e
 *
 **************************************
 *
 * Functional description
 *	Perform the body of restore.
 *
 **************************************/

	// Read burp record first

	MVOL_init_read (file_name, &tdgbl->RESTORE_format, &tdgbl->io_cnt, &tdgbl->io_ptr);

	if (tdgbl->gbl_sw_transportable)
		BURP_verbose (133);
		// msg 133 transportable backup -- data in XDR format
	if (tdgbl->gbl_sw_compress)
		BURP_verbose (61);
		// msg 61 backup file is compressed


	// restore only from those backup files created by current or previous GBAK

	if (tdgbl->RESTORE_format < 1 || tdgbl->RESTORE_format > ATT_BACKUP_FORMAT)
	{
		BURP_error(44, true, SafeArg() << tdgbl->RESTORE_format);
		// msg 44 Expected backup version 1..8.  Found %ld
	}

	create_database(tdgbl, database_name);

	/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
	{
	isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_23);
	SQLCODE = isc_sqlcode(isc_status);
	}
	if (gds_status[1])
		/*EXEC SQL SET TRANSACTION;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_24);
		SQLCODE = isc_sqlcode(isc_status);
		}

	// For V4.0, start a read commited transaction.  This will be used
	// to create blobs for global fields and update the record in the
	// RDB$FIELDS table.

	/*EXEC SQL SET TRANSACTION NAME tdgbl->global_trans ISOLATION LEVEL READ COMMITTED;*/
	{
	isc_start_transaction (isc_status, (FB_API_HANDLE*) &tdgbl->global_trans, (short) 1, &DB, (short) 5, isc_tpb_25);
	SQLCODE = isc_sqlcode(isc_status);
	}

	check_db_version(tdgbl);
	if (tdgbl->RESTORE_ods < DB_VERSION_OLDEST_SUPPORTED)
	{
		BURP_error(51, true, SafeArg() << tdgbl->RESTORE_ods);
		// msg 51 database format %ld is too old to restore to
	}

	BURP_verbose (129);
	// msg 129 started transaction

	att_type	attribute;
	isc_req_handle  req_handle2 = 0, req_handle3 = 0;

	while (get_attribute(&attribute, tdgbl) != att_end)
	{
		switch (attribute)
		{
		case att_database_security_class:
			// Instead of updating the security class in RDB$DATABASE,
			// just store the value in tdgbl. It will be updated at
			// the very end to prevent security class validation
			// failures during change table ownership operation
			GET_TEXT(tdgbl->database_security_class);
			break;

		case att_database_description:
		case att_database_description2:
			/*FOR (REQUEST_HANDLE req_handle2)
				X IN RDB$DATABASE*/
			{
                        if (!req_handle2)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle2, (short) sizeof(isc_141), (char*) isc_141);
			if (req_handle2)
			   {
                           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle2, (FB_API_HANDLE*) &gds_trans, (short) 0);
			   }
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 0, (short) 10, &isc_142, (short) 0);
			   if (!isc_142.isc_144 || isc_status [1]) break;
				/*MODIFY X USING*/
				{
					if (attribute == att_database_description2)
						get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
									isc_142.isc_143, false);
					else
						get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								      isc_142.isc_143, false);
				/*END_MODIFY;*/
				isc_145.isc_146 = isc_142.isc_143;
                                isc_send (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 1, (short) 8, &isc_145, (short) 0);;
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
			/*END_FOR;*/
                           isc_send (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 2, (short) 2, &isc_147, (short) 0);
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
			break;

		case att_database_dfl_charset:
			/*FOR (REQUEST_HANDLE req_handle3)
				X IN RDB$DATABASE*/
			{
                        if (!req_handle3)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle3, (short) sizeof(isc_133), (char*) isc_133);
			if (req_handle3)
			   {
                           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle3, (FB_API_HANDLE*) &gds_trans, (short) 0);
			   }
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle3, (short) 0, (short) 34, &isc_134, (short) 0);
			   if (!isc_134.isc_136 || isc_status [1]) break;
				/*MODIFY X USING*/
				{
					GET_TEXT(/*X.RDB$CHARACTER_SET_NAME*/
						 isc_134.isc_135);
				/*END_MODIFY;*/
				isc_ftof (isc_134.isc_135, 32, isc_137.isc_138, 32);
                                isc_send (isc_status, (FB_API_HANDLE*) &req_handle3, (short) 1, (short) 32, &isc_137, (short) 0);;
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
			/*END_FOR;*/
                           isc_send (isc_status, (FB_API_HANDLE*) &req_handle3, (short) 2, (short) 2, &isc_139, (short) 0);
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
			break;

		default:
			{
			SSHORT l = get(tdgbl);
			if (l)
				get_skip(tdgbl, l);
			break;
			}
		}
	}

	MISC_release_request_silent(req_handle2);
	MISC_release_request_silent(req_handle3);

	if (tdgbl->gbl_sw_fix_fss_data)
	{
		bool found = false;
		Firebird::string name = tdgbl->gbl_sw_fix_fss_data;
		name.upper();

		req_handle3 = 0;

		/*FOR (REQUEST_HANDLE req_handle3)
			X IN RDB$CHARACTER_SETS
			WITH X.RDB$CHARACTER_SET_NAME EQ name.c_str()*/
		{
                if (!req_handle3)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle3, (short) sizeof(isc_127), (char*) isc_127);
		isc_vtov ((const char*) name.c_str(), (char*) isc_128.isc_129, 32);
		if (req_handle3)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle3, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_128, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle3, (short) 1, (short) 4, &isc_130, (short) 0);
		   if (!isc_130.isc_131 || isc_status [1]) break;

			tdgbl->gbl_sw_fix_fss_data_id = /*X.RDB$CHARACTER_SET_ID*/
							isc_130.isc_132;
			found = true;

		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

		MISC_release_request_silent(req_handle3);

		if (!found)
			BURP_error(305, true, SafeArg() << tdgbl->gbl_sw_fix_fss_data);
	}

	if (tdgbl->gbl_sw_fix_fss_metadata)
	{
		bool found = false;
		Firebird::string name = tdgbl->gbl_sw_fix_fss_metadata;
		name.upper();

		req_handle3 = 0;

		/*FOR (REQUEST_HANDLE req_handle3)
			X IN RDB$CHARACTER_SETS
			WITH X.RDB$CHARACTER_SET_NAME EQ name.c_str()*/
		{
                if (!req_handle3)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle3, (short) sizeof(isc_121), (char*) isc_121);
		isc_vtov ((const char*) name.c_str(), (char*) isc_122.isc_123, 32);
		if (req_handle3)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle3, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_122, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle3, (short) 1, (short) 4, &isc_124, (short) 0);
		   if (!isc_124.isc_125 || isc_status [1]) break;

			tdgbl->gbl_sw_fix_fss_metadata_id = /*X.RDB$CHARACTER_SET_ID*/
							    isc_124.isc_126;
			found = true;

		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

		MISC_release_request_silent(req_handle3);

		if (!found)
			BURP_error(305, true, SafeArg() << tdgbl->gbl_sw_fix_fss_metadata);
	}

	// If this should be a multi-file database, add the files

	if (tdgbl->gbl_sw_files && tdgbl->gbl_sw_files->fil_next)
		add_files(tdgbl, database_name);

	// Get global fields and relations

	bool flag_norel = true;	// To fix bug 10098
	bool flag = false;
	rec_type record;

	while (get_record(&record, tdgbl) != rec_end)
	{
		switch (record)
		{
		case rec_charset:
			if (!get_character_set(tdgbl))
				return false;
			flag = true;
			break;

		case rec_collation:
			if (!get_collation(tdgbl))
				return false;
			flag = true;
			break;

		case rec_chk_constraint:
			if (!get_chk_constraint(tdgbl))
				return false;
			flag = true;
			break;

		case rec_global_field:
			if (!get_global_field(tdgbl))
				return false;
			flag = true;
			break;

		case rec_field_dimensions:
			if (!get_field_dimensions(tdgbl))
				return false;
			flag = true;
			break;

		case rec_relation:
			if (!get_relation(tdgbl))
				return false;
			flag = true;
			flag_norel = false;
			break;

		case rec_ref_constraint:
			if (!get_ref_constraint(tdgbl))
				return false;
			flag = true;
			break;

		case rec_rel_constraint:
			if (!get_rel_constraint(tdgbl))
				return false;
			flag = true;
			break;

		case rec_function:
			if (!get_function(tdgbl))
				return false;
			flag = true;
			break;

		case rec_procedure:
			if (!get_procedure(tdgbl))
				return false;
			flag = true;
			break;

		case rec_exception:
			if (!get_exception(tdgbl))
				return false;
			flag = true;
			break;

		case rec_system_type:  // rdb$types
			if (!get_type(tdgbl))
				return false;
			flag = true;
			break;

		case rec_filter:  // rdb$filters
			if (!get_filter(tdgbl))
				return false;
			flag = true;
			break;

		case rec_generator:
			if (!get_generator(tdgbl))
				return false;
			flag = true;
			break;

		case rec_relation_data:
			if (flag)
			{
				BURP_verbose (68);
				// msg 68 committing meta data
				/*COMMIT;*/
				{
				isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
				/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
				{
				isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_26);
				SQLCODE = isc_sqlcode(isc_status);
				}
				if (gds_status[1])
					/*EXEC SQL SET TRANSACTION;*/
					{
					isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_27);
					SQLCODE = isc_sqlcode(isc_status);
					}
				flag = false;
			}
			if (!get_relation_data(tdgbl))
				return false;
			break;

		case rec_trigger:  // new trigger type
			if (!get_trigger(tdgbl))
				return false;
			flag = true;
			break;

		case rec_trigger_message:
			if (!get_trigger_message(tdgbl))
				return false;
			flag = true;
			break;

		case rec_user_privilege:
			if (!get_user_privilege(tdgbl))
				return false;
			flag = true;
			break;

		case rec_security_class:
			if (!get_security_class(tdgbl))
				return false;
			flag = true;
			break;

		case rec_files:
			if (!get_files(tdgbl))
				return false;
			flag = true;
			break;

		case rec_sql_roles:
			if (!get_sql_roles(tdgbl))
				return false;
			flag = true;
			break;

		case rec_mapping:
			if (!get_mapping(tdgbl))
				return false;
			flag = true;
			break;

		default:
			BURP_error(43, true, SafeArg() << record);
			// msg 43 don't recognize record type %ld
			break;
		}
	}

	if (tdgbl->defaultCollations.getCount() > 0)
	{
		isc_req_handle req_handle4 = 0;

		/*FOR (REQUEST_HANDLE req_handle4)
			CS IN RDB$CHARACTER_SETS*/
		{
                if (!req_handle4)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle4, (short) sizeof(isc_110), (char*) isc_110);
		if (req_handle4)
		   {
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle4, (FB_API_HANDLE*) &gds_trans, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 0, (short) 68, &isc_111, (short) 0);
		   if (!isc_111.isc_114 || isc_status [1]) break;

			for (size_t i = 0; i < tdgbl->defaultCollations.getCount(); ++i)
			{
				if (tdgbl->defaultCollations[i].first == /*CS.RDB$CHARACTER_SET_NAME*/
									 isc_111.isc_113)
				{
					/*MODIFY CS*/
					{;
						/*CS.RDB$DEFAULT_COLLATE_NAME.NULL*/
						isc_111.isc_115 = FALSE;
						strcpy(/*CS.RDB$DEFAULT_COLLATE_NAME*/
						       isc_111.isc_112,
							tdgbl->defaultCollations[i].second.c_str());
					/*END_MODIFY;*/
					isc_ftof (isc_111.isc_112, 32, isc_116.isc_117, 32);
					isc_116.isc_118 = isc_111.isc_115;
                                        isc_send (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 1, (short) 34, &isc_116, (short) 0);;
					/*ON_ERROR*/
					if (isc_status [1])
					   {
						general_on_error ();
					/*END_ERROR;*/
					   }
					}
				}
			}
		/*END_FOR;*/
                   isc_send (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 2, (short) 2, &isc_119, (short) 0);
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

		MISC_release_request_silent(req_handle4);
	}

	// This piece of code is to fix bug 10098: restore of database with
	// only domains and no relations aborts with the message ERROR: deadlock
	// This is because insertion of domains into RDB$FIELDS is happening in
	// the default transaction, whereas updation of RDB$FIELDS to add
	// constraints to the domains is done in tdgbl->global_trans. In case of
	// no relations, no COMMIT of default transaction occurs till this point
	// because of which rows in RDB$FIELDS for domains are still locked by
	// default transaction. The below code COMMITs the default transaction
	// in that particular situation

	if (flag_norel)
	{
		/*COMMIT;*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
		/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_28);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_29);
			SQLCODE = isc_sqlcode(isc_status);
			}
	}

	// put validation clauses for global fields

	update_global_field(tdgbl);

	// Purge shadow metadata if necessary

	if (tdgbl->gbl_sw_kill)
	{
		isc_req_handle req_handle4 = 0;

		/*FOR (REQUEST_HANDLE req_handle4)
			FIL IN RDB$FILES WITH FIL.RDB$SHADOW_NUMBER NOT MISSING
			AND FIL.RDB$SHADOW_NUMBER NE 0*/
		{
                if (!req_handle4)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle4, (short) sizeof(isc_103), (char*) isc_103);
		if (req_handle4)
		   {
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle4, (FB_API_HANDLE*) &gds_trans, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 0, (short) 2, &isc_104, (short) 0);
		   if (!isc_104.isc_105 || isc_status [1]) break;
		/*ERASE FIL;*/
		{
                isc_send (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 1, (short) 2, &isc_106, (short) 0);
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
		/*END_FOR;*/
                   isc_send (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 2, (short) 2, &isc_108, (short) 0);
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

		MISC_release_request_silent(req_handle4);
	}

	// update statistics for system indices
	isc_req_handle req_handle5 = 0;

	/*FOR (REQUEST_HANDLE req_handle5)
		IND IN RDB$INDICES WITH IND.RDB$SYSTEM_FLAG EQ 1*/
	{
        if (!req_handle5)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle5, (short) sizeof(isc_93), (char*) isc_93);
	if (req_handle5)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle5, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle5, (short) 0, (short) 12, &isc_94, (short) 0);
	   if (!isc_94.isc_96 || isc_status [1]) break;
		/*MODIFY IND*/
		{
			/*IND.RDB$STATISTICS.NULL*/
			isc_94.isc_97 = FALSE;
			/*IND.RDB$STATISTICS*/
			isc_94.isc_95 = -1;
		/*END_MODIFY*/
		isc_98.isc_99 = isc_94.isc_95;
		isc_98.isc_100 = isc_94.isc_97;
                isc_send (isc_status, (FB_API_HANDLE*) &req_handle5, (short) 1, (short) 10, &isc_98, (short) 0);;
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	/*END_FOR;*/
           isc_send (isc_status, (FB_API_HANDLE*) &req_handle5, (short) 2, (short) 2, &isc_101, (short) 0);
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	MISC_release_request_silent(req_handle5);

	return true;
}

void restore_security_class(BurpGlobals*	tdgbl,
							const TEXT*		owner_nm,
							const TEXT*		sec_class_nm)
{
   struct isc_91_struct {
          short isc_92;	/* isc_utility */
   } isc_91;
   struct isc_89_struct {
          ISC_QUAD isc_90;	/* RDB$ACL */
   } isc_89;
   struct isc_86_struct {
          ISC_QUAD isc_87;	/* RDB$ACL */
          short isc_88;	/* isc_utility */
   } isc_86;
   struct isc_84_struct {
          char  isc_85 [32];	/* RDB$SECURITY_CLASS */
   } isc_84;
/**************************************
 *
 *	r e s t o r e _ s e c u r i t y _ c l a s s
 *
 **************************************
 *
 * Functional description
 *	restore the ownership of the relation in the ACL list
 *
 **************************************/
	isc_req_handle  req_handle2 = 0;

	//isc_tr_handle local_trans = gds_trans;

	/*FOR (REQUEST_HANDLE req_handle2)
		X IN RDB$SECURITY_CLASSES WITH X.RDB$SECURITY_CLASS EQ sec_class_nm*/
	{
        if (!req_handle2)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle2, (short) sizeof(isc_83), (char*) isc_83);
	isc_vtov ((const char*) sec_class_nm, (char*) isc_84.isc_85, 32);
	if (req_handle2)
	   {
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle2, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_84, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 1, (short) 10, &isc_86, (short) 0);
	   if (!isc_86.isc_88 || isc_status [1]) break;

		ISC_QUAD new_blob_id;
		new_blob_id.gds_quad_high = 0;
		new_blob_id.gds_quad_low  = 0;
		get_acl(tdgbl, owner_nm, &/*X.RDB$ACL*/
					  isc_86.isc_87, &new_blob_id);

		/*MODIFY X*/
		{;
			memcpy(&/*X.RDB$ACL*/
				isc_86.isc_87, &new_blob_id, sizeof(ISC_QUAD));
		/*END_MODIFY;*/
		isc_89.isc_90 = isc_86.isc_87;
                isc_send (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 2, (short) 8, &isc_89, (short) 0);;
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			MISC_release_request_silent(req_handle2);
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

	/*END_FOR;*/
           isc_send (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 3, (short) 2, &isc_91, (short) 0);
	   }
	   };

	/*ON_ERROR*/
	if (isc_status [1])
	   {
		MISC_release_request_silent(req_handle2);
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	MISC_release_request_silent(req_handle2);
}


USHORT get_view_base_relation_count(BurpGlobals*	tdgbl,
									const TEXT*		current_view_name,
									USHORT			depth)
{
   struct isc_78_struct {
          char  isc_79 [32];	/* RDB$RELATION_NAME */
          ISC_QUAD isc_80;	/* RDB$VIEW_BLR */
          short isc_81;	/* isc_utility */
          short isc_82;	/* gds__null_flag */
   } isc_78;
   struct isc_76_struct {
          char  isc_77 [32];	/* RDB$VIEW_NAME */
   } isc_76;
/**************************************
 *
 *	g e t _ v i e w _ b a s e _ r e l a t i o n _ c o u n t
 *
 **************************************
 *
 * Functional description
 *	Return the number of base relations
 *  (tables) from a view. When a view is
 *  referenced in the view this function
 *  is called recursively.
 *
 **************************************/

	depth++;
	if (depth > MAX_UPDATE_DBKEY_RECURSION_DEPTH) {
		return 0;
	}

	isc_req_handle  req_handle1 = 0;

	USHORT result = 0;

	/*FOR (REQUEST_HANDLE req_handle1)
		V IN RDB$VIEW_RELATIONS
		CROSS R IN RDB$RELATIONS
		WITH
		  V.RDB$VIEW_NAME EQ current_view_name AND
		  R.RDB$RELATION_NAME EQ V.RDB$RELATION_NAME*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_75), (char*) isc_75);
	isc_vtov ((const char*) current_view_name, (char*) isc_76.isc_77, 32);
	if (req_handle1)
	   {
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_76, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 1, (short) 44, &isc_78, (short) 0);
	   if (!isc_78.isc_81 || isc_status [1]) break;

		if (/*R.RDB$VIEW_BLR.NULL*/
		    isc_78.isc_82) {
			// This relation is a table, so increment count
			result++;
		}
		else {
			// Call recursive for VIEWS that are referenced in VIEWS
			result += get_view_base_relation_count(tdgbl, /*V.RDB$RELATION_NAME*/
								      isc_78.isc_79, depth);
		}
	/*END_FOR;*/
	   }
	   };

	/*ON_ERROR*/
	if (isc_status [1])
	   {
		MISC_release_request_silent(req_handle1);
		general_on_error();
	/*END_ERROR;*/
	   }
	}

	MISC_release_request_silent(req_handle1);

	return result;
}


void store_blr_gen_id(BurpGlobals*		tdgbl,
					  const TEXT*		gen_name,	// TEXT GDS_NAME[GDS_NAME_LEN]
					  SINT64			value,
					  const ISC_QUAD*	gen_desc)
{
   struct isc_64_struct {
          char  isc_65 [32];	/* RDB$GENERATOR_NAME */
          short isc_66;	/* gds__null_flag */
          short isc_67;	/* RDB$SYSTEM_FLAG */
   } isc_64;
   struct isc_69_struct {
          ISC_QUAD isc_70;	/* RDB$DESCRIPTION */
          char  isc_71 [32];	/* RDB$GENERATOR_NAME */
          short isc_72;	/* gds__null_flag */
          short isc_73;	/* RDB$SYSTEM_FLAG */
          short isc_74;	/* gds__null_flag */
   } isc_69;
/**************************************
 *
 *	s t o r e _ b l r _ g e n _ i d
 *
 **************************************
 *
 * Functional description
 *	Store the blr_gen_id for the relation.
 *
 **************************************/
	if (tdgbl->RESTORE_ods >= DB_VERSION_DDL11)
	{
		/*STORE (REQUEST_HANDLE tdgbl->handles_store_blr_gen_id_req_handle1)
			X IN RDB$GENERATORS*/
		{
		
                if (!tdgbl->handles_store_blr_gen_id_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_store_blr_gen_id_req_handle1, (short) sizeof(isc_68), (char*) isc_68);
		if (tdgbl->handles_store_blr_gen_id_req_handle1)
		   {
		   isc_69.isc_70 = isc_blob_null;
			strcpy (/*X.RDB$GENERATOR_NAME*/
				isc_69.isc_71, gen_name);
			/*X.RDB$DESCRIPTION.NULL*/
			isc_69.isc_74 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_69.isc_73 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_69.isc_72 = FALSE;
			if (gen_desc)
			{
				/*X.RDB$DESCRIPTION*/
				isc_69.isc_70 = *gen_desc;
				/*X.RDB$DESCRIPTION.NULL*/
				isc_69.isc_74 = FALSE;
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_store_blr_gen_id_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 46, &isc_69, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*STORE (REQUEST_HANDLE tdgbl->handles_store_blr_gen_id_req_handle1)
			X IN RDB$GENERATORS*/
		{
		
                if (!tdgbl->handles_store_blr_gen_id_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_store_blr_gen_id_req_handle1, (short) sizeof(isc_63), (char*) isc_63);
		if (tdgbl->handles_store_blr_gen_id_req_handle1)
		   {
			strcpy (/*X.RDB$GENERATOR_NAME*/
				isc_64.isc_65, gen_name);
			/*X.RDB$SYSTEM_FLAG*/
			isc_64.isc_67 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_64.isc_66 = FALSE;
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_store_blr_gen_id_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 36, &isc_64, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}

	if (!value)
	{
		BURP_verbose (185, SafeArg() << gen_name << 0);
		// msg 185 restoring generator %s value: %ld
		return;
	}


	FB_API_HANDLE gen_id_reqh = 0;
	UCHAR blr_buffer[100];  // enough to fit blr
	UCHAR* blr = blr_buffer;

	// build the blr with the right relation name

	if (tdgbl->RESTORE_ods >= DB_VERSION_DDL10)
	{
		add_byte(blr, blr_version5);
	}
	else
	{
		add_byte(blr, blr_version4);
	}
	add_byte(blr, blr_begin);
	if (tdgbl->RESTORE_ods >= DB_VERSION_DDL10)
	{
		add_byte(blr, blr_dcl_variable);
		add_word(blr, 0);
		add_byte(blr, blr_int64);
		add_byte(blr, 0);
	}
	else
	{
		add_byte(blr, blr_dcl_variable);
		add_word(blr, 0);
		add_byte(blr, blr_long);
		add_byte(blr, 0);
	}
	add_byte(blr, blr_begin);
	add_byte(blr, blr_assignment);
	add_byte(blr, blr_gen_id);
	add_string(blr, gen_name);
	if (tdgbl->RESTORE_ods >= DB_VERSION_DDL10)
	{
		add_byte(blr, blr_literal);
		add_byte(blr, blr_int64);
		add_byte(blr, 0);
		add_int64(blr, value);
	}
	else
	{
		add_byte(blr, blr_literal);
		add_byte(blr, blr_long);
		add_byte(blr, 0);
		add_long(blr, (SLONG)value);
	}
	add_byte(blr, blr_variable);
	add_word(blr, 0);
	add_byte(blr, blr_end);
	add_byte(blr, blr_end);
	add_byte(blr, blr_eoc);

	const USHORT blr_length = blr - blr_buffer;
	fb_assert(blr_length <= sizeof(blr_buffer));

	ISC_STATUS_ARRAY status_vector;
	if (isc_compile_request (status_vector, &DB, &gen_id_reqh,
							 blr_length, (const SCHAR*) blr_buffer))
	{
		fb_print_blr(blr_buffer, blr_length, NULL, NULL, 0);
		BURP_error_redirect (status_vector, 42);
		// msg 42 Failed in store_blr_gen_id
	}

	if (isc_start_request (status_vector, &gen_id_reqh,
						   &gds_trans, // use the same one generated by gpre
						   0))
	{
		fb_print_blr(blr_buffer, blr_length, NULL, NULL, 0);
		BURP_error_redirect (status_vector, 42);
		// msg 42 Failed in store_blr_gen_id
	}

	BURP_verbose (185, SafeArg() << gen_name << value);
	// msg 185 restoring generator %s value: %ld

	isc_release_request (status_vector, &gen_id_reqh);
}


void update_global_field(BurpGlobals* tdgbl)
{
   struct isc_61_struct {
          short isc_62;	/* isc_utility */
   } isc_61;
   struct isc_52_struct {
          ISC_QUAD isc_53;	/* RDB$VALIDATION_BLR */
          ISC_QUAD isc_54;	/* RDB$VALIDATION_SOURCE */
          ISC_QUAD isc_55;	/* RDB$COMPUTED_BLR */
          ISC_QUAD isc_56;	/* RDB$COMPUTED_SOURCE */
          short isc_57;	/* gds__null_flag */
          short isc_58;	/* gds__null_flag */
          short isc_59;	/* gds__null_flag */
          short isc_60;	/* gds__null_flag */
   } isc_52;
   struct isc_42_struct {
          ISC_QUAD isc_43;	/* RDB$COMPUTED_SOURCE */
          ISC_QUAD isc_44;	/* RDB$COMPUTED_BLR */
          ISC_QUAD isc_45;	/* RDB$VALIDATION_SOURCE */
          ISC_QUAD isc_46;	/* RDB$VALIDATION_BLR */
          short isc_47;	/* isc_utility */
          short isc_48;	/* gds__null_flag */
          short isc_49;	/* gds__null_flag */
          short isc_50;	/* gds__null_flag */
          short isc_51;	/* gds__null_flag */
   } isc_42;
   struct isc_40_struct {
          char  isc_41 [32];	/* RDB$FIELD_NAME */
   } isc_40;
/**************************************
 *
 *	u p d a t e _ g l o b a l _ f i e l d
 *
 **************************************
 *
 * Functional description
 *	Update the global field definition to add constraints.
 *	The blobs have been created already.
 *
 **************************************/
	isc_req_handle  req_handle1 = 0;

	for (gfld* gfield = tdgbl->gbl_global_fields; gfield; )
	{
		/*FOR (TRANSACTION_HANDLE tdgbl->global_trans REQUEST_HANDLE req_handle1)
			X IN RDB$FIELDS WITH X.RDB$FIELD_NAME EQ gfield->gfld_name*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_39), (char*) isc_39);
		isc_vtov ((const char*) gfield->gfld_name, (char*) isc_40.isc_41, 32);
		if (req_handle1)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &tdgbl->global_trans, (short) 0, (short) 32, &isc_40, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 1, (short) 42, &isc_42, (short) 0);
		   if (!isc_42.isc_47 || isc_status [1]) break;
			/*MODIFY X*/
			{

				if (gfield->gfld_flags & GFLD_validation_blr)
				{
					/*X.RDB$VALIDATION_BLR.NULL*/
					isc_42.isc_51 = FALSE;
					memcpy(&/*X.RDB$VALIDATION_BLR*/
						isc_42.isc_46, &gfield->gfld_vb, sizeof(ISC_QUAD));
				}

				if (gfield->gfld_flags & GFLD_validation_source)
				{
					/*X.RDB$VALIDATION_SOURCE.NULL*/
					isc_42.isc_50 = FALSE;
					memcpy(&/*X.RDB$VALIDATION_SOURCE*/
						isc_42.isc_45, &gfield->gfld_vs, sizeof(ISC_QUAD));
				}

				if (gfield->gfld_flags & GFLD_validation_source2)
				{
					/*X.RDB$VALIDATION_SOURCE.NULL*/
					isc_42.isc_50 = FALSE;
					memcpy(&/*X.RDB$VALIDATION_SOURCE*/
						isc_42.isc_45, &gfield->gfld_vs2, sizeof(ISC_QUAD));
				}

				if (gfield->gfld_flags & GFLD_computed_blr)
				{
					/*X.RDB$COMPUTED_BLR.NULL*/
					isc_42.isc_49 = FALSE;
					memcpy(&/*X.RDB$COMPUTED_BLR*/
						isc_42.isc_44, &gfield->gfld_computed_blr, sizeof(ISC_QUAD));
				}

				if (gfield->gfld_flags & GFLD_computed_source)
				{
					/*X.RDB$COMPUTED_SOURCE.NULL*/
					isc_42.isc_48 = FALSE;
					memcpy(&/*X.RDB$COMPUTED_SOURCE*/
						isc_42.isc_43, &gfield->gfld_computed_source, sizeof(ISC_QUAD));
				}

				if (gfield->gfld_flags & GFLD_computed_source2)
				{
					/*X.RDB$COMPUTED_SOURCE.NULL*/
					isc_42.isc_48 = FALSE;
					memcpy(&/*X.RDB$COMPUTED_SOURCE*/
						isc_42.isc_43, &gfield->gfld_computed_source2, sizeof(ISC_QUAD));
				}

			/*END_MODIFY;*/
			isc_52.isc_53 = isc_42.isc_46;
			isc_52.isc_54 = isc_42.isc_45;
			isc_52.isc_55 = isc_42.isc_44;
			isc_52.isc_56 = isc_42.isc_43;
			isc_52.isc_57 = isc_42.isc_51;
			isc_52.isc_58 = isc_42.isc_50;
			isc_52.isc_59 = isc_42.isc_49;
			isc_52.isc_60 = isc_42.isc_48;
                        isc_send (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 2, (short) 40, &isc_52, (short) 0);;
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}

		/*END_FOR;*/
                   isc_send (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 3, (short) 2, &isc_61, (short) 0);
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
		gfld* n_gfield = gfield->gfld_next;
		BURP_free (gfield);
		gfield = n_gfield;
	}
	MISC_release_request_silent(req_handle1);

	tdgbl->gbl_global_fields = NULL;
}


void update_view_dbkey_lengths(BurpGlobals* tdgbl)
{
   struct isc_37_struct {
          short isc_38;	/* isc_utility */
   } isc_37;
   struct isc_35_struct {
          short isc_36;	/* RDB$DBKEY_LENGTH */
   } isc_35;
   struct isc_31_struct {
          char  isc_32 [32];	/* RDB$RELATION_NAME */
          short isc_33;	/* isc_utility */
          short isc_34;	/* RDB$DBKEY_LENGTH */
   } isc_31;
/**************************************
 *
 *	u p d a t e _ v i e w _ d b k e y _ l e n g t h s
 *
 **************************************
 *
 * Functional description
 *	During the restore process VIEWs could
 *  be created that holds other VIEWs and
 *  which weren't restored yet.
 *  Then the RDB$DBKEY_LENGTH for VIEWs is
 *  calculated wrong. Therefore we need to
 *  recalculate the DBKEY_LENGTH else we
 *  get our famous "arithmetic exception,
 *  numeric overflow, or string truncation" error.
 *
 **************************************/
	isc_req_handle  req_handle2 = 0;

	/*FOR (REQUEST_HANDLE req_handle2)
		R IN RDB$RELATIONS
		WITH
		  R.RDB$VIEW_BLR NOT MISSING AND
		  (R.RDB$SYSTEM_FLAG NE 1 OR R.RDB$SYSTEM_FLAG MISSING)*/
	{
        if (!req_handle2)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle2, (short) sizeof(isc_30), (char*) isc_30);
	if (req_handle2)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle2, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 0, (short) 36, &isc_31, (short) 0);
	   if (!isc_31.isc_33 || isc_status [1]) break;

		const USHORT result = get_view_base_relation_count(tdgbl, /*R.RDB$RELATION_NAME*/
									  isc_31.isc_32, 0);

		/*MODIFY R*/
		{;
			/*R.RDB$DBKEY_LENGTH*/
			isc_31.isc_34 = (result * 8); // is a constant for DBKEY coded somewhere?
		/*END_MODIFY;*/
		isc_35.isc_36 = isc_31.isc_34;
                isc_send (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 1, (short) 2, &isc_35, (short) 0);;
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			MISC_release_request_silent(req_handle2);
			general_on_error();
		/*END_ERROR;*/
		   }
		}

	/*END_FOR;*/
           isc_send (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 2, (short) 2, &isc_37, (short) 0);
	   }
	   };

	/*ON_ERROR*/
	if (isc_status [1])
	   {
		MISC_release_request_silent(req_handle2);
		general_on_error();
	/*END_ERROR;*/
	   }
	}

	MISC_release_request_silent(req_handle2);
}

struct FixGenerator
{
	const char* name;
	const char* table;
	const char* field;
	const char* prefix;
};

void fix_generator(BurpGlobals* tdgbl, const FixGenerator* g)
{
/**************************************
 *
 *	f i x G e n e r a t o r
 *
 **************************************
 *
 * Functional description
 *	Set value of system generator based on
 *	current state of related table.
 *
 **************************************/

	int start = strlen(g->prefix) + 1;

	Firebird::string sql;
	sql.printf("EXECUTE BLOCK AS "
			   "DECLARE VARIABLE maxInTable INT; "
			   "DECLARE VARIABLE currentGen INT; "
			   "BEGIN "
			   " SELECT FIRST(1) CAST(SUBSTRING(%s FROM %d FOR 32) AS INT) FROM %s "
			   " WHERE SUBSTRING(%s FROM %d FOR 32) SIMILAR TO '[0-9]+ *' "
			   "   AND %s STARTING WITH '%s' ORDER BY 1 DESC INTO :maxInTable; "
			   " "
			   " currentGen = gen_id(%s, 0); "
			   " IF (currentGen < maxInTable) THEN "
			   "  EXECUTE STATEMENT 'SET GENERATOR %s TO ' || maxInTable; "
			   "END",
			   /* SELECT 1 */ g->field, start, g->table, g->field, start, g->field, g->prefix,
			   /* SELECT 2 */ g->name,
			   /* SET GEN  */ g->name);

	if (isc_execute_immediate(isc_status, &DB, &gds_trans, 0, sql.c_str()) != 0)
		general_on_error();
}

const FixGenerator genToFix[] = 
{
	{  "RDB$CONSTRAINT_NAME",	"RDB$RELATION_CONSTRAINTS",	"RDB$CONSTRAINT_NAME",	"INTEG_" },
	{  "RDB$FIELD_NAME",		"RDB$FIELDS",				"RDB$FIELD_NAME",		"RDB$" },
	{  "RDB$INDEX_NAME",		"RDB$INDICES", 				"RDB$INDEX_NAME",		"RDB$" },
	{  "RDB$INDEX_NAME",		"RDB$INDICES", 				"RDB$INDEX_NAME",		"RDB$PRIMARY" },
	{  "RDB$INDEX_NAME",		"RDB$INDICES", 				"RDB$INDEX_NAME",		"RDB$FOREIGN" },
	{  "RDB$TRIGGER_NAME",		"RDB$TRIGGERS",				"RDB$TRIGGER_NAME",		"CHECK_" },
	{ NULL, NULL, NULL, NULL }
};

void fix_system_generators(BurpGlobals* tdgbl)
{
/**************************************
 *
 *	f i x A l l G e n e r a t o r s
 *
 **************************************
 *
 * Functional description
 *	Set value of system generators based on
 *	current state of related tables.
 *
 **************************************/

	for (const FixGenerator* g = genToFix; g->name; ++g)
	{
		fix_generator(tdgbl, g);
	}
}

} // namespace


